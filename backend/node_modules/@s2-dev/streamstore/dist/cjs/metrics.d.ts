import type { DataToObject, S2RequestOptions } from "./common.js";
import type { Client } from "./generated/client/types.gen.js";
import { type AccountMetricsData, type BasinMetricsData, type StreamMetricsData } from "./generated/index.js";
export interface AccountMetricsArgs extends DataToObject<AccountMetricsData> {
}
export interface BasinMetricsArgs extends DataToObject<BasinMetricsData> {
}
export interface StreamMetricsArgs extends DataToObject<StreamMetricsData> {
}
export declare class S2Metrics {
    readonly client: Client;
    constructor(client: Client);
    /**
     * Account-level metrics.
     *
     * @param args.set Metric set to return
     * @param args.start Optional start timestamp (Unix seconds)
     * @param args.end Optional end timestamp (Unix seconds)
     * @param args.interval Optional aggregation interval for timeseries sets
     */
    account(args: AccountMetricsArgs, options?: S2RequestOptions): Promise<import("./generated/types.gen.js").MetricSetResponse>;
    /**
     * Basin-level metrics.
     *
     * @param args.basin Basin name
     * @param args.set Metric set to return
     * @param args.start Optional start timestamp (Unix seconds)
     * @param args.end Optional end timestamp (Unix seconds)
     * @param args.interval Optional aggregation interval for timeseries sets
     */
    basin(args: BasinMetricsArgs, options?: S2RequestOptions): Promise<import("./generated/types.gen.js").MetricSetResponse>;
    /**
     * Stream-level metrics.
     *
     * @param args.basin Basin name
     * @param args.stream Stream name
     * @param args.set Metric set to return
     * @param args.start Optional start timestamp (Unix seconds)
     * @param args.end Optional end timestamp (Unix seconds)
     * @param args.interval Optional aggregation interval for timeseries sets
     */
    stream(args: StreamMetricsArgs, options?: S2RequestOptions): Promise<import("./generated/types.gen.js").MetricSetResponse>;
}
//# sourceMappingURL=metrics.d.ts.map