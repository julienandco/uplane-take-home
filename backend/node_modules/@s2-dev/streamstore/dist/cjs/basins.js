"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.S2Basins = void 0;
const error_js_1 = require("./error.js");
const index_js_1 = require("./generated/index.js");
class S2Basins {
    client;
    constructor(client) {
        this.client = client;
    }
    /**
     * List basins.
     *
     * @param args.prefix Return basins whose names start with the given prefix
     * @param args.start_after Name to start after (for pagination)
     * @param args.limit Max results (up to 1000)
     */
    async list(args, options) {
        const response = await (0, index_js_1.listBasins)({
            client: this.client,
            query: args,
            ...options,
        });
        if (response.error) {
            throw new error_js_1.S2Error({
                message: response.error.message,
                code: response.error.code ?? undefined,
                status: response.response.status,
            });
        }
        return response.data;
    }
    /**
     * Create a basin.
     *
     * @param args.basin Globally unique basin name (8-48 chars, lowercase letters, numbers, hyphens; cannot begin or end with a hyphen)
     * @param args.config Optional basin configuration (e.g. default stream config)
     * @param args.scope Basin scope
     */
    async create(args, options) {
        const response = await (0, index_js_1.createBasin)({
            client: this.client,
            body: args,
            ...options,
        });
        if (response.error) {
            throw new error_js_1.S2Error({
                message: response.error.message,
                code: response.error.code ?? undefined,
                status: response.response.status,
            });
        }
        return response.data;
    }
    /**
     * Get basin configuration.
     *
     * @param args.basin Basin name
     */
    async getConfig(args, options) {
        const response = await (0, index_js_1.getBasinConfig)({
            client: this.client,
            path: args,
            ...options,
        });
        if (response.error) {
            throw new error_js_1.S2Error({
                message: response.error.message,
                code: response.error.code ?? undefined,
                status: response.response.status,
            });
        }
        return response.data;
    }
    /**
     * Delete a basin.
     *
     * @param args.basin Basin name
     */
    async delete(args, options) {
        const response = await (0, index_js_1.deleteBasin)({
            client: this.client,
            path: args,
            ...options,
        });
        if (response.error) {
            throw new error_js_1.S2Error({
                message: response.error.message,
                code: response.error.code ?? undefined,
                status: response.response.status,
            });
        }
        return response.data;
    }
    /**
     * Reconfigure a basin.
     *
     * @param args.basin Basin name
     * @param args.body Configuration fields to change (e.g. default stream config)
     */
    async reconfigure(args, options) {
        const response = await (0, index_js_1.reconfigureBasin)({
            client: this.client,
            path: args,
            body: args,
            ...options,
        });
        if (response.error) {
            throw new error_js_1.S2Error({
                message: response.error.message,
                code: response.error.code ?? undefined,
                status: response.response.status,
            });
        }
        return response.data;
    }
}
exports.S2Basins = S2Basins;
//# sourceMappingURL=basins.js.map