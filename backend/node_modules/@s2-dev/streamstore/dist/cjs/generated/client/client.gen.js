"use strict";
// This file is auto-generated by @hey-api/openapi-ts
Object.defineProperty(exports, "__esModule", { value: true });
exports.createClient = void 0;
const serverSentEvents_gen_js_1 = require("../core/serverSentEvents.gen.js");
const utils_gen_js_1 = require("../core/utils.gen.js");
const utils_gen_js_2 = require("./utils.gen.js");
const createClient = (config = {}) => {
    let _config = (0, utils_gen_js_2.mergeConfigs)((0, utils_gen_js_2.createConfig)(), config);
    const getConfig = () => ({ ..._config });
    const setConfig = (config) => {
        _config = (0, utils_gen_js_2.mergeConfigs)(_config, config);
        return getConfig();
    };
    const interceptors = (0, utils_gen_js_2.createInterceptors)();
    const beforeRequest = async (options) => {
        const opts = {
            ..._config,
            ...options,
            fetch: options.fetch ?? _config.fetch ?? globalThis.fetch,
            headers: (0, utils_gen_js_2.mergeHeaders)(_config.headers, options.headers),
            serializedBody: undefined,
        };
        if (opts.security) {
            await (0, utils_gen_js_2.setAuthParams)({
                ...opts,
                security: opts.security,
            });
        }
        if (opts.requestValidator) {
            await opts.requestValidator(opts);
        }
        if (opts.body !== undefined && opts.bodySerializer) {
            opts.serializedBody = opts.bodySerializer(opts.body);
        }
        // remove Content-Type header if body is empty to avoid sending invalid requests
        if (opts.body === undefined || opts.serializedBody === '') {
            opts.headers.delete('Content-Type');
        }
        const url = (0, utils_gen_js_2.buildUrl)(opts);
        return { opts, url };
    };
    const request = async (options) => {
        // @ts-expect-error
        const { opts, url } = await beforeRequest(options);
        const requestInit = {
            redirect: 'follow',
            ...opts,
            body: (0, utils_gen_js_1.getValidRequestBody)(opts),
        };
        let request = new Request(url, requestInit);
        for (const fn of interceptors.request.fns) {
            if (fn) {
                request = await fn(request, opts);
            }
        }
        // fetch must be assigned here, otherwise it would throw the error:
        // TypeError: Failed to execute 'fetch' on 'Window': Illegal invocation
        const _fetch = opts.fetch;
        let response = await _fetch(request);
        for (const fn of interceptors.response.fns) {
            if (fn) {
                response = await fn(response, request, opts);
            }
        }
        const result = {
            request,
            response,
        };
        if (response.ok) {
            const parseAs = (opts.parseAs === 'auto'
                ? (0, utils_gen_js_2.getParseAs)(response.headers.get('Content-Type'))
                : opts.parseAs) ?? 'json';
            if (response.status === 204 ||
                response.headers.get('Content-Length') === '0') {
                let emptyData;
                switch (parseAs) {
                    case 'arrayBuffer':
                    case 'blob':
                    case 'text':
                        emptyData = await response[parseAs]();
                        break;
                    case 'formData':
                        emptyData = new FormData();
                        break;
                    case 'stream':
                        emptyData = response.body;
                        break;
                    case 'json':
                    default:
                        emptyData = {};
                        break;
                }
                return opts.responseStyle === 'data'
                    ? emptyData
                    : {
                        data: emptyData,
                        ...result,
                    };
            }
            let data;
            switch (parseAs) {
                case 'arrayBuffer':
                case 'blob':
                case 'formData':
                case 'json':
                case 'text':
                    data = await response[parseAs]();
                    break;
                case 'stream':
                    return opts.responseStyle === 'data'
                        ? response.body
                        : {
                            data: response.body,
                            ...result,
                        };
            }
            if (parseAs === 'json') {
                if (opts.responseValidator) {
                    await opts.responseValidator(data);
                }
                if (opts.responseTransformer) {
                    data = await opts.responseTransformer(data);
                }
            }
            return opts.responseStyle === 'data'
                ? data
                : {
                    data,
                    ...result,
                };
        }
        const textError = await response.text();
        let jsonError;
        try {
            jsonError = JSON.parse(textError);
        }
        catch {
            // noop
        }
        const error = jsonError ?? textError;
        let finalError = error;
        for (const fn of interceptors.error.fns) {
            if (fn) {
                finalError = (await fn(error, response, request, opts));
            }
        }
        finalError = finalError || {};
        if (opts.throwOnError) {
            throw finalError;
        }
        // TODO: we probably want to return error and improve types
        return opts.responseStyle === 'data'
            ? undefined
            : {
                error: finalError,
                ...result,
            };
    };
    const makeMethodFn = (method) => (options) => request({ ...options, method });
    const makeSseFn = (method) => async (options) => {
        const { opts, url } = await beforeRequest(options);
        return (0, serverSentEvents_gen_js_1.createSseClient)({
            ...opts,
            body: opts.body,
            headers: opts.headers,
            method,
            onRequest: async (url, init) => {
                let request = new Request(url, init);
                for (const fn of interceptors.request.fns) {
                    if (fn) {
                        request = await fn(request, opts);
                    }
                }
                return request;
            },
            url,
        });
    };
    return {
        buildUrl: utils_gen_js_2.buildUrl,
        connect: makeMethodFn('CONNECT'),
        delete: makeMethodFn('DELETE'),
        get: makeMethodFn('GET'),
        getConfig,
        head: makeMethodFn('HEAD'),
        interceptors,
        options: makeMethodFn('OPTIONS'),
        patch: makeMethodFn('PATCH'),
        post: makeMethodFn('POST'),
        put: makeMethodFn('PUT'),
        request,
        setConfig,
        sse: {
            connect: makeSseFn('CONNECT'),
            delete: makeSseFn('DELETE'),
            get: makeSseFn('GET'),
            head: makeSseFn('HEAD'),
            options: makeSseFn('OPTIONS'),
            patch: makeSseFn('PATCH'),
            post: makeSseFn('POST'),
            put: makeSseFn('PUT'),
            trace: makeSseFn('TRACE'),
        },
        trace: makeMethodFn('TRACE'),
    };
};
exports.createClient = createClient;
//# sourceMappingURL=client.gen.js.map