import type { S2RequestOptions } from "./common.js";
import type { Client } from "./generated/client/types.gen.js";
import { type AppendAck } from "./generated/index.js";
import type { AppendArgs, AppendRecord, AppendSession, AppendSessionOptions, ReadArgs, ReadBatch, ReadSession, TransportConfig } from "./lib/stream/types.js";
export declare class S2Stream {
    private readonly client;
    private readonly transportConfig;
    private _transport?;
    readonly name: string;
    constructor(name: string, client: Client, transportConfig: TransportConfig);
    /**
     * Get or create the transport instance
     */
    private getTransport;
    /**
     * Check the tail of the stream.
     *
     * Returns the next sequence number and timestamp to be assigned (`tail`).
     */
    checkTail(options?: S2RequestOptions): Promise<import("./generated/types.gen.js").TailResponse>;
    /**
     * Read records from the stream.
     *
     * - When `as: "bytes"` is provided, bodies and headers are decoded from base64 to `Uint8Array`.
     * - Supports starting position by `seq_num`, `timestamp`, or `tail_offset` and can clamp to the tail.
     * - Non-streaming reads are bounded by `count` and `bytes` (defaults 1000 and 1 MiB).
     * - Use `readSession` for streaming reads
     */
    read<Format extends "string" | "bytes" = "string">(args?: ReadArgs<Format>, options?: S2RequestOptions): Promise<ReadBatch<Format>>;
    /**
     * Append one or more records to the stream.
     *
     * - Automatically base64-encodes when format is "bytes".
     * - Supports conditional appends via `fencing_token` and `match_seq_num`.
     * - Returns the acknowledged range and the stream tail after the append.
     *
     * All records in a single append call must use the same format (either all string or all bytes).
     * For high-throughput sequential appends, use `appendSession()` instead.
     *
     * @param records The record(s) to append
     * @param args Optional append arguments (fencing_token, match_seq_num)
     * @param options Optional request options
     */
    append(records: AppendRecord | AppendRecord[], args?: Omit<AppendArgs, "records">, options?: S2RequestOptions): Promise<AppendAck>;
    /**
     * Open a streaming read session
     *
     * Use the returned session as an async iterable or as a readable stream.
     * When `as: "bytes"` is provided, bodies and headers are decoded to `Uint8Array`.
     */
    readSession<Format extends "string" | "bytes" = "string">(args?: ReadArgs<Format>, options?: S2RequestOptions): Promise<ReadSession<Format>>;
    /**
     * Create an append session that guarantees ordering of submissions.
     *
     * Use this to coordinate high-throughput, sequential appends with backpressure.
     * Records can be either string or bytes format - the format is specified in each record.
     *
     * @param options Optional request options
     */
    appendSession(sessionOptions?: AppendSessionOptions, requestOptions?: S2RequestOptions): Promise<AppendSession>;
}
//# sourceMappingURL=stream.d.ts.map