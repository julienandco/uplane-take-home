import { SerializableJson } from "@trigger.dev/core";
import { ApiError, ApiRequestOptions, InitOutput, Queue, QueueOptions, SubtaskUnwrapError, TaskFromIdentifier, TaskRunContext, TaskRunPromise } from "@trigger.dev/core/v3";
import type { AnyRunHandle, AnyTask, BatchByIdAndWaitItem, BatchByIdItem, BatchByIdResult, BatchByTaskAndWaitItem, BatchByTaskItem, BatchByTaskResult, BatchItem, BatchResult, BatchRunHandle, BatchRunHandleFromTypes, BatchTasksRunHandleFromTypes, BatchTriggerAndWaitOptions, BatchTriggerOptions, InferRunTypes, RunHandle, RunHandleFromTypes, RunHandleOutput, RunHandlePayload, Task, TaskBatchOutputHandle, TaskIdentifier, TaskOptions, TaskOptionsWithSchema, TaskOutput, TaskOutputHandle, TaskPayload, TaskRunResult, TaskSchema, TaskWithSchema, TaskWithSchemaOptions, TaskWithToolOptions, ToolTask, ToolTaskParameters, TriggerAndWaitOptions, TriggerApiRequestOptions, TriggerOptions } from "@trigger.dev/core/v3";
export type { AnyRunHandle, AnyTask, BatchItem, BatchResult, BatchRunHandle, BatchTriggerOptions, Queue, RunHandle, RunHandleOutput, RunHandlePayload, SerializableJson, Task, TaskBatchOutputHandle, TaskFromIdentifier, TaskIdentifier, TaskOptions, TaskOutput, TaskOutputHandle, TaskPayload, TaskRunResult, TriggerOptions, TaskWithSchema, TaskWithSchemaOptions, TaskSchema, TaskOptionsWithSchema, };
export { SubtaskUnwrapError, TaskRunPromise };
export type Context = TaskRunContext;
export declare function queue(options: QueueOptions): Queue;
export declare function createTask<TIdentifier extends string, TOutput = unknown, TInitOutput extends InitOutput = any>(params: TaskOptionsWithSchema<TIdentifier, TOutput, TInitOutput>): Task<TIdentifier, any, TOutput>;
export declare function createTask<TIdentifier extends string, TInput = void, TOutput = unknown, TInitOutput extends InitOutput = any>(params: TaskOptions<TIdentifier, TInput, TOutput, TInitOutput>): Task<TIdentifier, TInput, TOutput>;
/**
 * @deprecated use ai.tool() instead
 */
export declare function createToolTask<TIdentifier extends string, TParameters extends ToolTaskParameters, TOutput = unknown, TInitOutput extends InitOutput = any>(params: TaskWithToolOptions<TIdentifier, TParameters, TOutput, TInitOutput>): ToolTask<TIdentifier, TParameters, TOutput>;
export declare function createSchemaTask<TIdentifier extends string, TSchema extends TaskSchema | undefined = undefined, TOutput = unknown, TInitOutput extends InitOutput = any>(params: TaskWithSchemaOptions<TIdentifier, TSchema, TOutput, TInitOutput>): TaskWithSchema<TIdentifier, TSchema, TOutput>;
/**
 * Trigger a task by its identifier with the given payload. Returns a typesafe `RunHandle`.
 *
 * @example
 *
 * ```ts
 * import { tasks, runs } from "@trigger.dev/sdk/v3";
 * import type { myTask } from "./myTasks"; // Import just the type of the task
 *
 * const handle = await tasks.trigger<typeof myTask>("my-task", { foo: "bar" }); // The id and payload are fully typesafe
 * const run = await runs.retrieve(handle);
 * console.log(run.output) // The output is also fully typed
 * ```
 *
 * @returns {RunHandle} An object with the `id` of the run. Can be used to retrieve the completed run output in a typesafe manner.
 */
export declare function trigger<TTask extends AnyTask>(id: TaskIdentifier<TTask>, payload: TaskPayload<TTask>, options?: TriggerOptions, requestOptions?: TriggerApiRequestOptions): Promise<RunHandleFromTypes<InferRunTypes<TTask>>>;
/**
 * Trigger a task with the given payload, and wait for the result. Returns the result of the task run
 * @param id - The id of the task to trigger
 * @param payload
 * @param options - Options for the task run
 * @returns TaskRunResult
 * @example
 * ```ts
 * import { tasks } from "@trigger.dev/sdk/v3";
 * const result = await tasks.triggerAndWait("my-task", { foo: "bar" });
 *
 * if (result.ok) {
 *  console.log(result.output);
 * } else {
 *  console.error(result.error);
 * }
 * ```
 */
export declare function triggerAndWait<TTask extends AnyTask>(id: TaskIdentifier<TTask>, payload: TaskPayload<TTask>, options?: TriggerAndWaitOptions, requestOptions?: ApiRequestOptions): TaskRunPromise<TaskIdentifier<TTask>, TaskOutput<TTask>>;
/**
 * Batch trigger multiple task runs with the given payloads, and wait for the results. Returns the results of the task runs.
 * @param id - The id of the task to trigger
 * @param items
 * @returns BatchResult
 * @example
 *
 * ```ts
 * import { tasks } from "@trigger.dev/sdk/v3";
 *
 * const result = await tasks.batchTriggerAndWait("my-task", [
 *  { payload: { foo: "bar" } },
 *  { payload: { foo: "baz" } },
 * ]);
 *
 * for (const run of result.runs) {
 *  if (run.ok) {
 *    console.log(run.output);
 *  } else {
 *    console.error(run.error);
 *  }
 * }
 * ```
 */
export declare function batchTriggerAndWait<TTask extends AnyTask>(id: TaskIdentifier<TTask>, items: Array<BatchItem<TaskPayload<TTask>>>, options?: BatchTriggerAndWaitOptions, requestOptions?: ApiRequestOptions): Promise<BatchResult<TaskIdentifier<TTask>, TaskOutput<TTask>>>;
export declare function batchTrigger<TTask extends AnyTask>(id: TaskIdentifier<TTask>, items: Array<BatchItem<TaskPayload<TTask>>>, options?: BatchTriggerOptions, requestOptions?: TriggerApiRequestOptions): Promise<BatchRunHandleFromTypes<InferRunTypes<TTask>>>;
/**
 * Triggers multiple runs of different tasks with specified payloads and options.
 *
 * @template TTask - The type of task(s) to be triggered, extends AnyTask
 *
 * @param {Array<BatchByIdItem<InferRunTypes<TTask>>>} items - Array of task items to trigger
 * @param {BatchTriggerOptions} [options] - Optional batch-level trigger options
 * @param {TriggerApiRequestOptions} [requestOptions] - Optional API request configuration
 *
 * @returns {Promise<BatchRunHandleFromTypes<InferRunTypes<TTask>>>} A promise that resolves with the batch run handle
 * containing batch ID, cached status, idempotency info, runs, and public access token
 *
 * @example
 * ```ts
 * import { batch } from "@trigger.dev/sdk/v3";
 * import type { myTask1, myTask2 } from "~/trigger/myTasks";
 *
 * // Trigger multiple tasks with different payloads
 * const result = await batch.trigger<typeof myTask1 | typeof myTask2>([
 *   {
 *     id: "my-task-1",
 *     payload: { some: "data" },
 *     options: {
 *       queue: "default",
 *       concurrencyKey: "key",
 *       idempotencyKey: "unique-key",
 *       delay: "5m",
 *       tags: ["tag1", "tag2"]
 *     }
 *   },
 *   {
 *     id: "my-task-2",
 *     payload: { other: "data" }
 *   }
 * ]);
 *
 * // Or stream items from an async iterable
 * async function* generateItems() {
 *   for (let i = 0; i < 1000; i++) {
 *     yield { id: "my-task", payload: { index: i } };
 *   }
 * }
 *
 * const streamResult = await batch.trigger<typeof myTask>(generateItems());
 * ```
 *
 * @description
 * Each task item in the array can include:
 * - `id`: The unique identifier of the task
 * - `payload`: The data to pass to the task
 * - `options`: Optional task-specific settings including:
 *   - `queue`: Specify a queue for the task
 *   - `concurrencyKey`: Control concurrent execution
 *   - `idempotencyKey`: Prevent duplicate runs
 *   - `idempotencyKeyTTL`: Time-to-live for idempotency key
 *   - `delay`: Delay before task execution
 *   - `ttl`: Time-to-live for the task
 *   - `tags`: Array of tags for the task
 *   - `maxAttempts`: Maximum retry attempts
 *   - `metadata`: Additional metadata
 *   - `maxDuration`: Maximum execution duration
 */
export declare function batchTriggerById<TTask extends AnyTask>(items: Array<BatchByIdItem<InferRunTypes<TTask>>>, options?: BatchTriggerOptions, requestOptions?: TriggerApiRequestOptions): Promise<BatchRunHandleFromTypes<InferRunTypes<TTask>>>;
export declare function batchTriggerById<TTask extends AnyTask>(items: AsyncIterable<BatchByIdItem<InferRunTypes<TTask>>> | ReadableStream<BatchByIdItem<InferRunTypes<TTask>>>, options?: BatchTriggerOptions, requestOptions?: TriggerApiRequestOptions): Promise<BatchRunHandleFromTypes<InferRunTypes<TTask>>>;
/**
 * Triggers multiple tasks and waits for all of them to complete before returning their results.
 * This function must be called from within a task.run() context.
 *
 * @template TTask - Union type of tasks to be triggered, extends AnyTask
 *
 * @param {Array<BatchByIdAndWaitItem<InferRunTypes<TTask>>>} items - Array of task items to trigger
 * @param {TriggerApiRequestOptions} [requestOptions] - Optional API request configuration
 *
 * @returns {Promise<BatchByIdResult<TTask>>} A promise that resolves with the batch results, including
 * success/failure status and strongly-typed outputs for each task
 *
 * @throws {Error} If called outside of a task.run() context
 * @throws {Error} If no API client is configured
 *
 * @example
 * ```ts
 * import { batch, task } from "@trigger.dev/sdk/v3";
 *
 * export const parentTask = task({
 *   id: "parent-task",
 *   run: async (payload: string) => {
 *     const results = await batch.triggerAndWait<typeof childTask1 | typeof childTask2>([
 *       {
 *         id: "child-task-1",
 *         payload: { foo: "World" },
 *         options: {
 *           queue: "default",
 *           delay: "5m",
 *           tags: ["batch", "child1"]
 *         }
 *       },
 *       {
 *         id: "child-task-2",
 *         payload: { bar: 42 }
 *       }
 *     ]);
 *
 *     // Type-safe result handling
 *     for (const result of results) {
 *       if (result.ok) {
 *         switch (result.taskIdentifier) {
 *           case "child-task-1":
 *             console.log("Child task 1 output:", result.output); // string type
 *             break;
 *           case "child-task-2":
 *             console.log("Child task 2 output:", result.output); // number type
 *             break;
 *         }
 *       } else {
 *         console.error("Task failed:", result.error);
 *       }
 *     }
 *   }
 * });
 * ```
 *
 * @description
 * Each task item in the array can include:
 * - `id`: The task identifier (must match one of the tasks in the union type)
 * - `payload`: Strongly-typed payload matching the task's input type
 * - `options`: Optional task-specific settings including:
 *   - `queue`: Specify a queue for the task
 *   - `concurrencyKey`: Control concurrent execution
 *   - `delay`: Delay before task execution
 *   - `ttl`: Time-to-live for the task
 *   - `tags`: Array of tags for the task
 *   - `maxAttempts`: Maximum retry attempts
 *   - `metadata`: Additional metadata
 *   - `maxDuration`: Maximum execution duration
 *
 * The function provides full type safety for:
 * - Task IDs
 * - Payload types
 * - Return value types
 * - Error handling
 *
 * You can also pass an AsyncIterable or ReadableStream to stream items:
 *
 * @example
 * ```ts
 * // Stream items from an async iterable
 * async function* generateItems() {
 *   for (let i = 0; i < 1000; i++) {
 *     yield { id: "child-task", payload: { index: i } };
 *   }
 * }
 *
 * const results = await batch.triggerAndWait<typeof childTask>(generateItems());
 * ```
 */
export declare function batchTriggerByIdAndWait<TTask extends AnyTask>(items: Array<BatchByIdAndWaitItem<InferRunTypes<TTask>>>, options?: BatchTriggerAndWaitOptions, requestOptions?: TriggerApiRequestOptions): Promise<BatchByIdResult<TTask>>;
export declare function batchTriggerByIdAndWait<TTask extends AnyTask>(items: AsyncIterable<BatchByIdAndWaitItem<InferRunTypes<TTask>>> | ReadableStream<BatchByIdAndWaitItem<InferRunTypes<TTask>>>, options?: BatchTriggerAndWaitOptions, requestOptions?: TriggerApiRequestOptions): Promise<BatchByIdResult<TTask>>;
/**
 * Triggers multiple tasks and waits for all of them to complete before returning their results.
 * This function must be called from within a task.run() context.
 *
 * @template TTask - Union type of tasks to be triggered, extends AnyTask
 *
 * @param {Array<BatchByIdAndWaitItem<InferRunTypes<TTask>>>} items - Array of task items to trigger
 * @param {TriggerApiRequestOptions} [requestOptions] - Optional API request configuration
 *
 * @returns {Promise<BatchByIdResult<TTask>>} A promise that resolves with the batch results, including
 * success/failure status and strongly-typed outputs for each task
 *
 * @throws {Error} If called outside of a task.run() context
 * @throws {Error} If no API client is configured
 *
 * @example
 * ```ts
 * import { batch, task } from "@trigger.dev/sdk/v3";
 *
 * export const parentTask = task({
 *   id: "parent-task",
 *   run: async (payload: string) => {
 *     const results = await batch.triggerAndWait<typeof childTask1 | typeof childTask2>([
 *       {
 *         id: "child-task-1",
 *         payload: { foo: "World" },
 *         options: {
 *           queue: "default",
 *           delay: "5m",
 *           tags: ["batch", "child1"]
 *         }
 *       },
 *       {
 *         id: "child-task-2",
 *         payload: { bar: 42 }
 *       }
 *     ]);
 *
 *     // Type-safe result handling
 *     for (const result of results) {
 *       if (result.ok) {
 *         switch (result.taskIdentifier) {
 *           case "child-task-1":
 *             console.log("Child task 1 output:", result.output); // string type
 *             break;
 *           case "child-task-2":
 *             console.log("Child task 2 output:", result.output); // number type
 *             break;
 *         }
 *       } else {
 *         console.error("Task failed:", result.error);
 *       }
 *     }
 *   }
 * });
 * ```
 *
 * @description
 * Each task item in the array can include:
 * - `id`: The task identifier (must match one of the tasks in the union type)
 * - `payload`: Strongly-typed payload matching the task's input type
 * - `options`: Optional task-specific settings including:
 *   - `queue`: Specify a queue for the task
 *   - `concurrencyKey`: Control concurrent execution
 *   - `delay`: Delay before task execution
 *   - `ttl`: Time-to-live for the task
 *   - `tags`: Array of tags for the task
 *   - `maxAttempts`: Maximum retry attempts
 *   - `metadata`: Additional metadata
 *   - `maxDuration`: Maximum execution duration
 *
 * The function provides full type safety for:
 * - Task IDs
 * - Payload types
 * - Return value types
 * - Error handling
 *
 * You can also pass an AsyncIterable or ReadableStream to stream items:
 *
 * @example
 * ```ts
 * // Stream items from an async iterable
 * async function* generateItems() {
 *   for (let i = 0; i < 1000; i++) {
 *     yield { task: childTask, payload: { index: i } };
 *   }
 * }
 *
 * const result = await batch.triggerByTask([childTask], generateItems());
 * ```
 */
export declare function batchTriggerTasks<TTasks extends readonly AnyTask[]>(items: {
    [K in keyof TTasks]: BatchByTaskItem<TTasks[K]>;
}, options?: BatchTriggerOptions, requestOptions?: TriggerApiRequestOptions): Promise<BatchTasksRunHandleFromTypes<TTasks>>;
export declare function batchTriggerTasks<TTasks extends readonly AnyTask[]>(items: AsyncIterable<BatchByTaskItem<TTasks[number]>> | ReadableStream<BatchByTaskItem<TTasks[number]>>, options?: BatchTriggerOptions, requestOptions?: TriggerApiRequestOptions): Promise<BatchTasksRunHandleFromTypes<TTasks>>;
/**
 * Triggers multiple tasks and waits for all of them to complete before returning their results.
 * This function must be called from within a task.run() context.
 *
 * @template TTask - Union type of tasks to be triggered, extends AnyTask
 *
 * @param {Array<BatchByIdAndWaitItem<InferRunTypes<TTask>>>} items - Array of task items to trigger
 * @param {TriggerApiRequestOptions} [requestOptions] - Optional API request configuration
 *
 * @returns {Promise<BatchByIdResult<TTask>>} A promise that resolves with the batch results, including
 * success/failure status and strongly-typed outputs for each task
 *
 * @throws {Error} If called outside of a task.run() context
 * @throws {Error} If no API client is configured
 *
 * @example
 * ```ts
 * import { batch, task } from "@trigger.dev/sdk/v3";
 *
 * export const parentTask = task({
 *   id: "parent-task",
 *   run: async (payload: string) => {
 *     const results = await batch.triggerAndWait<typeof childTask1 | typeof childTask2>([
 *       {
 *         id: "child-task-1",
 *         payload: { foo: "World" },
 *         options: {
 *           queue: "default",
 *           delay: "5m",
 *           tags: ["batch", "child1"]
 *         }
 *       },
 *       {
 *         id: "child-task-2",
 *         payload: { bar: 42 }
 *       }
 *     ]);
 *
 *     // Type-safe result handling
 *     for (const result of results) {
 *       if (result.ok) {
 *         switch (result.taskIdentifier) {
 *           case "child-task-1":
 *             console.log("Child task 1 output:", result.output); // string type
 *             break;
 *           case "child-task-2":
 *             console.log("Child task 2 output:", result.output); // number type
 *             break;
 *         }
 *       } else {
 *         console.error("Task failed:", result.error);
 *       }
 *     }
 *   }
 * });
 * ```
 *
 * @description
 * Each task item in the array can include:
 * - `id`: The task identifier (must match one of the tasks in the union type)
 * - `payload`: Strongly-typed payload matching the task's input type
 * - `options`: Optional task-specific settings including:
 *   - `queue`: Specify a queue for the task
 *   - `concurrencyKey`: Control concurrent execution
 *   - `delay`: Delay before task execution
 *   - `ttl`: Time-to-live for the task
 *   - `tags`: Array of tags for the task
 *   - `maxAttempts`: Maximum retry attempts
 *   - `metadata`: Additional metadata
 *   - `maxDuration`: Maximum execution duration
 *
 * The function provides full type safety for:
 * - Task IDs
 * - Payload types
 * - Return value types
 * - Error handling
 *
 * You can also pass an AsyncIterable or ReadableStream to stream items:
 *
 * @example
 * ```ts
 * // Stream items from an async iterable
 * async function* generateItems() {
 *   for (let i = 0; i < 1000; i++) {
 *     yield { task: childTask, payload: { index: i } };
 *   }
 * }
 *
 * const results = await batch.triggerByTaskAndWait([childTask], generateItems());
 * ```
 */
export declare function batchTriggerAndWaitTasks<TTasks extends readonly AnyTask[]>(items: {
    [K in keyof TTasks]: BatchByTaskAndWaitItem<TTasks[K]>;
}, options?: BatchTriggerAndWaitOptions, requestOptions?: TriggerApiRequestOptions): Promise<BatchByTaskResult<TTasks>>;
export declare function batchTriggerAndWaitTasks<TTasks extends readonly AnyTask[]>(items: AsyncIterable<BatchByTaskAndWaitItem<TTasks[number]>> | ReadableStream<BatchByTaskAndWaitItem<TTasks[number]>>, options?: BatchTriggerAndWaitOptions, requestOptions?: TriggerApiRequestOptions): Promise<BatchByTaskResult<TTasks>>;
/**
 * Error thrown when batch trigger operations fail.
 * Includes context about which phase failed and the batch details.
 *
 * When the underlying error is a rate limit (429), additional properties are exposed:
 * - `isRateLimited`: true
 * - `retryAfterMs`: milliseconds until the rate limit resets
 */
export declare class BatchTriggerError extends Error {
    readonly phase: "create" | "stream";
    readonly batchId?: string;
    readonly itemCount: number;
    /** True if the error was caused by rate limiting (HTTP 429) */
    readonly isRateLimited: boolean;
    /** Milliseconds until the rate limit resets. Only set when `isRateLimited` is true. */
    readonly retryAfterMs?: number;
    /** The underlying API error, if the cause was an ApiError */
    readonly apiError?: ApiError;
    /** The underlying cause of the error */
    readonly cause?: unknown;
    constructor(message: string, options: {
        cause?: unknown;
        phase: "create" | "stream";
        batchId?: string;
        itemCount: number;
    });
}
