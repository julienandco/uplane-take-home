"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const vitest_1 = require("vitest");
const shared_js_1 = require("./shared.js");
(0, vitest_1.describe)("readableStreamToAsyncIterable", () => {
    (0, vitest_1.it)("yields all values from the stream", async () => {
        const values = [1, 2, 3, 4, 5];
        const stream = new ReadableStream({
            start(controller) {
                for (const value of values) {
                    controller.enqueue(value);
                }
                controller.close();
            },
        });
        const result = [];
        for await (const value of (0, shared_js_1.readableStreamToAsyncIterable)(stream)) {
            result.push(value);
        }
        (0, vitest_1.expect)(result).toEqual(values);
    });
    (0, vitest_1.it)("cancels the stream when consumer breaks early", async () => {
        let cancelCalled = false;
        const stream = new ReadableStream({
            start(controller) {
                controller.enqueue(1);
                controller.enqueue(2);
                controller.enqueue(3);
                controller.enqueue(4);
                controller.enqueue(5);
                controller.close();
            },
            cancel() {
                cancelCalled = true;
            },
        });
        const result = [];
        for await (const value of (0, shared_js_1.readableStreamToAsyncIterable)(stream)) {
            result.push(value);
            if (value === 2) {
                break; // Early termination
            }
        }
        (0, vitest_1.expect)(result).toEqual([1, 2]);
        (0, vitest_1.expect)(cancelCalled).toBe(true);
    });
    (0, vitest_1.it)("cancels the stream when consumer throws an error", async () => {
        let cancelCalled = false;
        const stream = new ReadableStream({
            start(controller) {
                controller.enqueue(1);
                controller.enqueue(2);
                controller.enqueue(3);
                controller.close();
            },
            cancel() {
                cancelCalled = true;
            },
        });
        const result = [];
        const testError = new Error("Test error");
        await (0, vitest_1.expect)(async () => {
            for await (const value of (0, shared_js_1.readableStreamToAsyncIterable)(stream)) {
                result.push(value);
                if (value === 2) {
                    throw testError;
                }
            }
        }).rejects.toThrow(testError);
        (0, vitest_1.expect)(result).toEqual([1, 2]);
        (0, vitest_1.expect)(cancelCalled).toBe(true);
    });
    (0, vitest_1.it)("handles stream that produces values asynchronously", async () => {
        const values = ["a", "b", "c"];
        let index = 0;
        const stream = new ReadableStream({
            async pull(controller) {
                if (index < values.length) {
                    // Simulate async data production
                    await new Promise((resolve) => setTimeout(resolve, 1));
                    controller.enqueue(values[index]);
                    index++;
                }
                else {
                    controller.close();
                }
            },
        });
        const result = [];
        for await (const value of (0, shared_js_1.readableStreamToAsyncIterable)(stream)) {
            result.push(value);
        }
        (0, vitest_1.expect)(result).toEqual(values);
    });
    (0, vitest_1.it)("cancels async stream when consumer breaks early", async () => {
        let cancelCalled = false;
        let producedCount = 0;
        const stream = new ReadableStream({
            async pull(controller) {
                // Simulate async data production
                await new Promise((resolve) => setTimeout(resolve, 1));
                producedCount++;
                controller.enqueue(producedCount);
                // Never close - infinite stream
            },
            cancel() {
                cancelCalled = true;
            },
        });
        const result = [];
        for await (const value of (0, shared_js_1.readableStreamToAsyncIterable)(stream)) {
            result.push(value);
            if (value >= 3) {
                break;
            }
        }
        (0, vitest_1.expect)(result).toEqual([1, 2, 3]);
        (0, vitest_1.expect)(cancelCalled).toBe(true);
    });
    (0, vitest_1.it)("does not throw when cancelling an already-closed stream", async () => {
        const stream = new ReadableStream({
            start(controller) {
                controller.enqueue(1);
                controller.close();
            },
        });
        // Normal iteration should complete without errors
        const result = [];
        for await (const value of (0, shared_js_1.readableStreamToAsyncIterable)(stream)) {
            result.push(value);
        }
        (0, vitest_1.expect)(result).toEqual([1]);
    });
    (0, vitest_1.it)("does not throw when cancelling an errored stream", async () => {
        const streamError = new Error("Stream error");
        let errorIndex = 0;
        const stream = new ReadableStream({
            pull(controller) {
                errorIndex++;
                if (errorIndex <= 2) {
                    controller.enqueue(errorIndex);
                }
                else {
                    controller.error(streamError);
                }
            },
        });
        const result = [];
        // The stream error should propagate
        await (0, vitest_1.expect)(async () => {
            for await (const value of (0, shared_js_1.readableStreamToAsyncIterable)(stream)) {
                result.push(value);
            }
        }).rejects.toThrow(streamError);
        // We should have gotten the values before the error
        (0, vitest_1.expect)(result).toEqual([1, 2]);
    });
    (0, vitest_1.it)("signals upstream producer to stop via cancel", async () => {
        const producedValues = [];
        let isProducing = true;
        const stream = new ReadableStream({
            async pull(controller) {
                if (!isProducing)
                    return;
                await new Promise((resolve) => setTimeout(resolve, 5));
                const value = producedValues.length + 1;
                producedValues.push(value);
                controller.enqueue(value);
            },
            cancel() {
                isProducing = false;
            },
        });
        const consumed = [];
        for await (const value of (0, shared_js_1.readableStreamToAsyncIterable)(stream)) {
            consumed.push(value);
            if (value >= 2) {
                break;
            }
        }
        // Wait a bit to ensure no more values are produced
        await new Promise((resolve) => setTimeout(resolve, 20));
        (0, vitest_1.expect)(consumed).toEqual([1, 2]);
        // Producer should have stopped after cancel
        (0, vitest_1.expect)(isProducing).toBe(false);
        // No more values should have been produced after breaking
        (0, vitest_1.expect)(producedValues.length).toBeLessThanOrEqual(3);
    });
});
//# sourceMappingURL=shared.test.js.map