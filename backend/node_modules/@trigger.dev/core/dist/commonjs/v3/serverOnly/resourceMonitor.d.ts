export type DiskMetrics = {
    total: number;
    used: number;
    free: number;
    percentUsed: number;
    warning?: string;
};
export type MemoryMetrics = {
    total: number;
    free: number;
    used: number;
    percentUsed: number;
};
export type NodeProcessMetrics = {
    memoryUsage: number;
    memoryUsagePercent: number;
    heapUsed: number;
    heapSizeLimit: number;
    heapUsagePercent: number;
    availableHeap: number;
    isNearHeapLimit: boolean;
};
export type TargetProcessMetrics = {
    method: string;
    processName: string;
    count: number;
    processes: ProcessInfo[];
    averages: {
        cpu: number;
        memory: number;
        rss: number;
        vsz: number;
    } | null;
    totals: {
        cpu: number;
        memory: number;
        rss: number;
        vsz: number;
    } | null;
};
export type ProcessMetrics = {
    node: NodeProcessMetrics;
    targetProcess: TargetProcessMetrics | null;
};
type GCSummary = {
    count: number;
    totalDuration: number;
    avgDuration: number;
    maxDuration: number;
    kinds: Record<string, {
        count: number;
        totalDuration: number;
        avgDuration: number;
        maxDuration: number;
    }>;
};
type ProcessInfo = {
    user: string;
    pid: number;
    cpu: number;
    mem: number;
    vsz: number;
    rss: number;
    command: string;
};
export type SystemMetrics = {
    disk: DiskMetrics;
    memory: MemoryMetrics;
};
export type ResourceMonitorConfig = {
    dirName?: string;
    processName?: string;
    ctx: Record<string, unknown>;
    compactLogging?: boolean;
    verbose?: boolean;
};
export declare class ResourceMonitor {
    private logInterval;
    private dirName;
    private processName;
    private ctx;
    private verbose;
    private compactLogging;
    private gcObserver;
    private bufferedGcEntries;
    constructor(config: ResourceMonitorConfig);
    /**
     * Start periodic resource monitoring
     * @param intervalMs Monitoring interval in milliseconds
     */
    startMonitoring(intervalMs?: number): void;
    /**
     * Stop resource monitoring
     */
    stopMonitoring(): void;
    private logResources;
    /**
     * Get combined system metrics (disk and memory)
     */
    private getSystemMetrics;
    /**
     * Get disk space information
     */
    private getDiskMetrics;
    /**
     * Get memory metrics
     */
    private getMemoryMetrics;
    /**
     * Get process-specific metrics using /proc filesystem
     */
    private getProcMetrics;
    /**
     * Find PIDs for a process name using /proc filesystem
     */
    private findPidsByName;
    /**
     * Get process-specific metrics
     */
    private getProcessMetrics;
    /**
     * Log a snapshot of current resource usage
     */
    logResourceSnapshot(label?: string): Promise<void>;
    /**
     * Create an enhanced log label with key metrics for quick scanning
     */
    private createEnhancedLabel;
    /**
     * Get text-based indicator for percentage values
     */
    private getTextIndicator;
    /**
     * Create a compact version of the enhanced label for high-frequency logging
     */
    private createCompactLabel;
    getResourceSnapshotPayload(): Promise<{
        system: {
            disk: {
                limitGiB: number;
                dirName: string;
                usedGiB: string;
                freeGiB: string;
                percentUsed: string;
                warning: string | undefined;
            };
            memory: {
                freeGB: string;
                percentUsed: string;
            };
        };
        gc: GCSummary;
        constraints: {
            cpu: number;
            memoryGB: number;
            note: string;
        };
        process: {
            node: {
                heapStats?: import("v8").HeapInfo | undefined;
                memoryUsageMB: string;
                memoryUsagePercent: string;
                heapUsedMB: string;
                heapSizeLimitMB: string;
                heapUsagePercent: string;
                availableHeapMB: string;
                isNearHeapLimit: boolean;
            };
            targetProcess: {
                method: string;
                processName: string;
                count: number;
                averages: {
                    cpuPercent: string;
                    memoryPercent: string;
                    rssMB: string;
                    vszMB: string;
                } | null;
                totals: {
                    cpuPercent: string;
                    memoryPercent: string;
                    rssMB: string;
                    vszMB: string;
                } | null;
            } | null;
        };
        timestamp: string;
    }>;
}
export {};
