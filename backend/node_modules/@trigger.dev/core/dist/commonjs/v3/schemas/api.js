"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FailDeploymentRequestBody = exports.DeploymentErrorData = exports.GenerateRegistryCredentialsResponseBody = exports.RemoteBuildProviderStatusResponseBody = exports.InitializeDeploymentRequestBody = exports.InitializeDeploymentResponseBody = exports.CreateArtifactResponseBody = exports.CreateArtifactRequestBody = exports.UpsertBranchResponseBody = exports.UpsertBranchRequestBody = exports.BuildServerMetadata = exports.DeploymentTriggeredVia = exports.ExternalBuildData = exports.CancelDeploymentRequestBody = exports.ProgressDeploymentRequestBody = exports.FinalizeDeploymentRequestBody = exports.StartDeploymentIndexingResponseBody = exports.StartDeploymentIndexingRequestBody = exports.GetEnvironmentVariablesResponseBody = exports.RescheduleRunRequestBody = exports.AddTagsRequestBody = exports.GetBatchResponseBody = exports.BatchTriggerTaskResponse = exports.StreamBatchItemsResponse = exports.BatchItemNDJSON = exports.CreateBatchResponse = exports.CreateBatchRequestBody = exports.BatchTriggerTaskV3Response = exports.BatchTriggerTaskV3RequestBody = exports.BatchTriggerTaskV2Response = exports.BatchTriggerTaskV2RequestBody = exports.BatchTriggerTaskItem = exports.BatchTriggerTaskRequestBody = exports.TriggerTaskResponse = exports.TriggerTaskRequestBody = exports.IdempotencyKeyOptionsSchema = exports.RunTags = exports.CreateBackgroundWorkerResponse = exports.CreateBackgroundWorkerRequestBody = exports.GetJWTResponse = exports.GetJWTRequestBody = exports.GetWorkerByTagResponse = exports.GetWorkerTaskResponse = exports.GetProjectEnvResponse = exports.CreateProjectRequestBody = exports.GetOrgsResponseBody = exports.GetProjectsResponseBody = exports.GetProjectResponseBody = exports.WhoAmIResponseSchema = exports.RunEngineVersion = void 0;
exports.RetrieveBatchResponse = exports.BatchStatus = exports.SubscribeRunRawShape = exports.UpdateMetadataResponseBody = exports.UpdateMetadataRequestBody = exports.EnvironmentVariableWithSecret = exports.EnvironmentVariables = exports.EnvironmentVariable = exports.EnvironmentVariableValue = exports.EnvironmentVariableResponseBody = exports.ImportEnvironmentVariablesRequestBody = exports.UpdateEnvironmentVariableRequestBody = exports.CreateEnvironmentVariableRequestBody = exports.ListRunResponse = exports.ListRunResponseItem = exports.RetrieveRunResponse = exports.RelatedRunDetails = exports.TriggerFunction = exports.RunScheduleDetails = exports.RunEnvironmentDetails = exports.AttemptStatus = exports.RunStatus = exports.TimezonesResult = exports.ListScheduleOptions = exports.ListSchedulesResult = exports.DeletedScheduleObject = exports.ScheduleObject = exports.ScheduleGenerator = exports.UpdateScheduleOptions = exports.CreateScheduleOptions = exports.ScheduledTaskPayload = exports.ScheduleType = exports.ResetIdempotencyKeyResponse = exports.CanceledRunResponse = exports.ReplayRunResponse = exports.DevDequeueResponseBody = exports.DevDequeueRequestBody = exports.DevConfigResponseBody = exports.WorkersCreateResponseBody = exports.WorkersCreateRequestBody = exports.WorkersListResponseBody = exports.CreateUploadPayloadUrlResponseBody = exports.DeploymentEventFromString = exports.DeploymentEvent = exports.DeploymentFinalizedEvent = exports.DeploymentLogEvent = exports.GetLatestDeploymentResponseBody = exports.GetDeploymentResponseBody = exports.PromoteDeploymentResponseBody = exports.FailDeploymentResponseBody = void 0;
exports.AppendToStreamResponseBody = exports.CreateStreamResponseBody = exports.RetrieveRunTraceResponseBody = exports.RetrieveRunTraceSpan = exports.RetrieveRunTraceSpanSchema = exports.ApiBranchListResponseBody = exports.ApiDeploymentListResponseItem = exports.ApiDeploymentListSearchParams = exports.ApiDeploymentListOptions = exports.ApiDeploymentListParams = exports.WaitForDurationResponseBody = exports.WaitForDurationRequestBody = exports.WaitForWaitpointTokenResponseBody = exports.CompleteWaitpointTokenResponseBody = exports.CompleteWaitpointTokenRequestBody = exports.WaitpointRetrieveTokenResponse = exports.WaitpointListTokenItem = exports.WaitpointTokenItem = exports.WaitpointTokenStatus = exports.waitpointTokenStatuses = exports.CreateWaitpointTokenResponseBody = exports.CreateWaitpointTokenRequestBody = exports.TimePeriod = exports.SubscribeRealtimeStreamChunkRawShape = exports.RetrieveBatchV2Response = void 0;
exports.isWaitpointOutputTimeout = isWaitpointOutputTimeout;
exports.timeoutError = timeoutError;
const zod_1 = require("zod");
const json_js_1 = require("../../schemas/json.js");
const common_js_1 = require("./common.js");
const resources_js_1 = require("./resources.js");
const runEngine_js_1 = require("./runEngine.js");
exports.RunEngineVersion = zod_1.z.union([zod_1.z.literal("V1"), zod_1.z.literal("V2")]);
exports.WhoAmIResponseSchema = zod_1.z.object({
    userId: zod_1.z.string(),
    email: zod_1.z.string().email(),
    dashboardUrl: zod_1.z.string(),
    project: zod_1.z
        .object({
        name: zod_1.z.string(),
        url: zod_1.z.string(),
        orgTitle: zod_1.z.string(),
    })
        .optional(),
});
exports.GetProjectResponseBody = zod_1.z.object({
    id: zod_1.z.string(),
    externalRef: zod_1.z
        .string()
        .describe("The external reference for the project, also known as the project ref, a unique identifier starting with proj_"),
    name: zod_1.z.string(),
    slug: zod_1.z.string(),
    createdAt: zod_1.z.coerce.date(),
    organization: zod_1.z.object({
        id: zod_1.z.string(),
        title: zod_1.z.string(),
        slug: zod_1.z.string(),
        createdAt: zod_1.z.coerce.date(),
    }),
});
exports.GetProjectsResponseBody = zod_1.z.array(exports.GetProjectResponseBody);
exports.GetOrgsResponseBody = zod_1.z.array(zod_1.z.object({
    id: zod_1.z.string(),
    title: zod_1.z.string(),
    slug: zod_1.z.string(),
    createdAt: zod_1.z.coerce.date(),
}));
exports.CreateProjectRequestBody = zod_1.z.object({
    name: zod_1.z
        .string()
        .trim()
        .min(1, "Name is required")
        .max(255, "Name must be less than 255 characters"),
});
exports.GetProjectEnvResponse = zod_1.z.object({
    apiKey: zod_1.z.string(),
    name: zod_1.z.string(),
    apiUrl: zod_1.z.string(),
    projectId: zod_1.z.string(),
});
// Zod schema for the response body type
exports.GetWorkerTaskResponse = zod_1.z.object({
    id: zod_1.z.string(),
    slug: zod_1.z.string(),
    filePath: zod_1.z.string(),
    triggerSource: zod_1.z.string(),
    createdAt: zod_1.z.coerce.date(),
    payloadSchema: zod_1.z.any().nullish(),
});
exports.GetWorkerByTagResponse = zod_1.z.object({
    worker: zod_1.z.object({
        id: zod_1.z.string(),
        version: zod_1.z.string(),
        engine: zod_1.z.string().nullish(),
        sdkVersion: zod_1.z.string().nullish(),
        cliVersion: zod_1.z.string().nullish(),
        tasks: zod_1.z.array(exports.GetWorkerTaskResponse),
    }),
    urls: zod_1.z.object({
        runs: zod_1.z.string(),
    }),
});
exports.GetJWTRequestBody = zod_1.z.object({
    claims: zod_1.z
        .object({
        scopes: zod_1.z.array(zod_1.z.string()).default([]),
    })
        .optional(),
    expirationTime: zod_1.z.union([zod_1.z.number(), zod_1.z.string()]).optional(),
});
exports.GetJWTResponse = zod_1.z.object({
    token: zod_1.z.string(),
});
exports.CreateBackgroundWorkerRequestBody = zod_1.z.object({
    localOnly: zod_1.z.boolean(),
    metadata: resources_js_1.BackgroundWorkerMetadata,
    engine: exports.RunEngineVersion.optional(),
    supportsLazyAttempts: zod_1.z.boolean().optional(),
    buildPlatform: zod_1.z.string().optional(),
    targetPlatform: zod_1.z.string().optional(),
});
exports.CreateBackgroundWorkerResponse = zod_1.z.object({
    id: zod_1.z.string(),
    version: zod_1.z.string(),
    contentHash: zod_1.z.string(),
});
//an array of 1, 2, or 3 strings
const RunTag = zod_1.z.string().max(128, "Tags must be less than 128 characters");
exports.RunTags = zod_1.z.union([RunTag, RunTag.array()]);
/** Stores the original user-provided idempotency key and scope */
exports.IdempotencyKeyOptionsSchema = zod_1.z.object({
    key: zod_1.z.string(),
    scope: zod_1.z.enum(["run", "attempt", "global"]),
});
exports.TriggerTaskRequestBody = zod_1.z.object({
    payload: zod_1.z.any(),
    context: zod_1.z.any(),
    options: zod_1.z
        .object({
        /** @deprecated engine v1 only */
        dependentAttempt: zod_1.z.string().optional(),
        /** @deprecated engine v1 only */
        parentAttempt: zod_1.z.string().optional(),
        /** @deprecated engine v1 only */
        dependentBatch: zod_1.z.string().optional(),
        /**
         * If triggered in a batch, this is the BatchTaskRun id
         */
        parentBatch: zod_1.z.string().optional(),
        /**
         * RunEngine v2
         * If triggered inside another run, the parentRunId is the friendly ID of the parent run.
         */
        parentRunId: zod_1.z.string().optional(),
        /**
         * RunEngine v2
         * Should be `true` if `triggerAndWait` or `batchTriggerAndWait`
         */
        resumeParentOnCompletion: zod_1.z.boolean().optional(),
        /**
         * Locks the version to the passed value.
         * Automatically set when using `triggerAndWait` or `batchTriggerAndWait`
         */
        lockToVersion: zod_1.z.string().optional(),
        queue: zod_1.z
            .object({
            name: zod_1.z.string(),
            // @deprecated, this is now specified on the queue
            concurrencyLimit: zod_1.z.number().int().optional(),
        })
            .optional(),
        concurrencyKey: zod_1.z.string().optional(),
        delay: zod_1.z.string().or(zod_1.z.coerce.date()).optional(),
        idempotencyKey: zod_1.z.string().optional(),
        idempotencyKeyTTL: zod_1.z.string().optional(),
        /** The original user-provided idempotency key and scope */
        idempotencyKeyOptions: exports.IdempotencyKeyOptionsSchema.optional(),
        machine: common_js_1.MachinePresetName.optional(),
        maxAttempts: zod_1.z.number().int().optional(),
        maxDuration: zod_1.z.number().optional(),
        metadata: zod_1.z.any(),
        metadataType: zod_1.z.string().optional(),
        payloadType: zod_1.z.string().optional(),
        tags: exports.RunTags.optional(),
        test: zod_1.z.boolean().optional(),
        ttl: zod_1.z.string().or(zod_1.z.number().nonnegative().int()).optional(),
        priority: zod_1.z.number().optional(),
        bulkActionId: zod_1.z.string().optional(),
        region: zod_1.z.string().optional(),
        debounce: zod_1.z
            .object({
            key: zod_1.z.string().max(512),
            delay: zod_1.z.string(),
            mode: zod_1.z.enum(["leading", "trailing"]).optional(),
        })
            .optional(),
    })
        .optional(),
});
exports.TriggerTaskResponse = zod_1.z.object({
    id: zod_1.z.string(),
    isCached: zod_1.z.boolean().optional(),
});
exports.BatchTriggerTaskRequestBody = zod_1.z.object({
    items: exports.TriggerTaskRequestBody.array(),
    dependentAttempt: zod_1.z.string().optional(),
});
exports.BatchTriggerTaskItem = zod_1.z.object({
    task: zod_1.z.string(),
    payload: zod_1.z.any(),
    context: zod_1.z.any(),
    options: zod_1.z
        .object({
        concurrencyKey: zod_1.z.string().optional(),
        delay: zod_1.z.string().or(zod_1.z.coerce.date()).optional(),
        idempotencyKey: zod_1.z.string().optional(),
        idempotencyKeyTTL: zod_1.z.string().optional(),
        /** The original user-provided idempotency key and scope */
        idempotencyKeyOptions: exports.IdempotencyKeyOptionsSchema.optional(),
        lockToVersion: zod_1.z.string().optional(),
        machine: common_js_1.MachinePresetName.optional(),
        maxAttempts: zod_1.z.number().int().optional(),
        maxDuration: zod_1.z.number().optional(),
        metadata: zod_1.z.any(),
        metadataType: zod_1.z.string().optional(),
        parentAttempt: zod_1.z.string().optional(),
        payloadType: zod_1.z.string().optional(),
        queue: zod_1.z
            .object({
            name: zod_1.z.string(),
        })
            .optional(),
        tags: exports.RunTags.optional(),
        test: zod_1.z.boolean().optional(),
        ttl: zod_1.z.string().or(zod_1.z.number().nonnegative().int()).optional(),
        priority: zod_1.z.number().optional(),
        region: zod_1.z.string().optional(),
        debounce: zod_1.z
            .object({
            key: zod_1.z.string().max(512),
            delay: zod_1.z.string(),
            mode: zod_1.z.enum(["leading", "trailing"]).optional(),
        })
            .optional(),
    })
        .optional(),
});
exports.BatchTriggerTaskV2RequestBody = zod_1.z.object({
    items: exports.BatchTriggerTaskItem.array(),
    /** @deprecated engine v1 only */
    dependentAttempt: zod_1.z.string().optional(),
    /**
     * RunEngine v2
     * If triggered inside another run, the parentRunId is the friendly ID of the parent run.
     */
    parentRunId: zod_1.z.string().optional(),
    /**
     * RunEngine v2
     * Should be `true` if `triggerAndWait` or `batchTriggerAndWait`
     */
    resumeParentOnCompletion: zod_1.z.boolean().optional(),
});
exports.BatchTriggerTaskV2Response = zod_1.z.object({
    id: zod_1.z.string(),
    isCached: zod_1.z.boolean(),
    idempotencyKey: zod_1.z.string().optional(),
    runs: zod_1.z.array(zod_1.z.object({
        id: zod_1.z.string(),
        taskIdentifier: zod_1.z.string(),
        isCached: zod_1.z.boolean(),
        idempotencyKey: zod_1.z.string().optional(),
    })),
});
exports.BatchTriggerTaskV3RequestBody = zod_1.z.object({
    items: exports.BatchTriggerTaskItem.array(),
    /**
     * RunEngine v2
     * If triggered inside another run, the parentRunId is the friendly ID of the parent run.
     */
    parentRunId: zod_1.z.string().optional(),
    /**
     * RunEngine v2
     * Should be `true` if `triggerAndWait` or `batchTriggerAndWait`
     */
    resumeParentOnCompletion: zod_1.z.boolean().optional(),
});
exports.BatchTriggerTaskV3Response = zod_1.z.object({
    id: zod_1.z.string(),
    runCount: zod_1.z.number(),
});
// ============================================================================
// 2-Phase Batch API (v3) - Streaming NDJSON Support
// ============================================================================
/**
 * Phase 1: Create batch request body
 * Creates the batch record and optionally blocks parent run for batchTriggerAndWait
 */
exports.CreateBatchRequestBody = zod_1.z.object({
    /** Expected number of items in the batch */
    runCount: zod_1.z.number().int().positive(),
    /** Parent run ID for batchTriggerAndWait (friendly ID) */
    parentRunId: zod_1.z.string().optional(),
    /** Whether to resume parent on completion (true for batchTriggerAndWait) */
    resumeParentOnCompletion: zod_1.z.boolean().optional(),
    /** Idempotency key for the batch */
    idempotencyKey: zod_1.z.string().optional(),
    /** The original user-provided idempotency key and scope */
    idempotencyKeyOptions: exports.IdempotencyKeyOptionsSchema.optional(),
});
/**
 * Phase 1: Create batch response
 */
exports.CreateBatchResponse = zod_1.z.object({
    /** The batch ID (friendly ID) */
    id: zod_1.z.string(),
    /** The expected run count */
    runCount: zod_1.z.number(),
    /** Whether this response came from a cached/idempotent batch */
    isCached: zod_1.z.boolean(),
    /** The idempotency key if provided */
    idempotencyKey: zod_1.z.string().optional(),
});
/**
 * Phase 2: Individual item in the NDJSON stream
 * Each line in the NDJSON body should match this schema
 */
exports.BatchItemNDJSON = zod_1.z.object({
    /** Zero-based index of this item (used for idempotency and ordering) */
    index: zod_1.z.number().int().nonnegative(),
    /** The task identifier to trigger */
    task: zod_1.z.string(),
    /** The payload for this task run */
    payload: zod_1.z.unknown().optional(),
    /** Options for this specific item */
    options: zod_1.z.record(zod_1.z.unknown()).optional(),
});
/**
 * Phase 2: Stream items response
 * Returned after the NDJSON stream completes
 */
exports.StreamBatchItemsResponse = zod_1.z.object({
    /** The batch ID */
    id: zod_1.z.string(),
    /** Number of items successfully accepted */
    itemsAccepted: zod_1.z.number(),
    /** Number of items that were deduplicated (already enqueued) */
    itemsDeduplicated: zod_1.z.number(),
    /** Whether the batch was sealed and is ready for processing.
     * If false, the batch needs more items before processing can start.
     * Clients should check this field and retry with missing items if needed. */
    sealed: zod_1.z.boolean(),
    /** Total items currently enqueued (only present when sealed=false to help with retries) */
    enqueuedCount: zod_1.z.number().optional(),
    /** Expected total item count (only present when sealed=false to help with retries) */
    expectedCount: zod_1.z.number().optional(),
});
exports.BatchTriggerTaskResponse = zod_1.z.object({
    batchId: zod_1.z.string(),
    runs: zod_1.z.string().array(),
});
exports.GetBatchResponseBody = zod_1.z.object({
    id: zod_1.z.string(),
    items: zod_1.z.array(zod_1.z.object({
        id: zod_1.z.string(),
        taskRunId: zod_1.z.string(),
        status: zod_1.z.enum(["PENDING", "CANCELED", "COMPLETED", "FAILED"]),
    })),
});
exports.AddTagsRequestBody = zod_1.z.object({
    tags: exports.RunTags,
});
exports.RescheduleRunRequestBody = zod_1.z.object({
    delay: zod_1.z.string().or(zod_1.z.coerce.date()),
});
exports.GetEnvironmentVariablesResponseBody = zod_1.z.object({
    variables: zod_1.z.record(zod_1.z.string()),
});
exports.StartDeploymentIndexingRequestBody = zod_1.z.object({
    imageReference: zod_1.z.string(),
    selfHosted: zod_1.z.boolean().optional(),
});
exports.StartDeploymentIndexingResponseBody = zod_1.z.object({
    id: zod_1.z.string(),
    contentHash: zod_1.z.string(),
});
exports.FinalizeDeploymentRequestBody = zod_1.z.object({
    skipPromotion: zod_1.z.boolean().optional(),
    imageDigest: zod_1.z.string().optional(),
    skipPushToRegistry: zod_1.z.boolean().optional(),
});
exports.ProgressDeploymentRequestBody = zod_1.z.object({
    contentHash: zod_1.z.string().optional(),
    gitMeta: common_js_1.GitMeta.optional(),
    runtime: zod_1.z.string().optional(),
});
exports.CancelDeploymentRequestBody = zod_1.z.object({
    reason: zod_1.z.string().max(200, "Reason must be less than 200 characters").optional(),
});
exports.ExternalBuildData = zod_1.z.object({
    buildId: zod_1.z.string(),
    buildToken: zod_1.z.string(),
    projectId: zod_1.z.string(),
});
const anyString = zod_1.z.custom((v) => typeof v === "string");
exports.DeploymentTriggeredVia = zod_1.z
    .enum([
    "cli:manual",
    "cli:ci_other",
    "cli:github_actions",
    "cli:gitlab_ci",
    "cli:circleci",
    "cli:jenkins",
    "cli:azure_pipelines",
    "cli:bitbucket_pipelines",
    "cli:travis_ci",
    "cli:buildkite",
    "git_integration:github",
    "dashboard",
])
    .or(anyString);
exports.BuildServerMetadata = zod_1.z.object({
    buildId: zod_1.z.string().optional(),
    isNativeBuild: zod_1.z.boolean().optional(),
    artifactKey: zod_1.z.string().optional(),
    skipPromotion: zod_1.z.boolean().optional(),
    configFilePath: zod_1.z.string().optional(),
});
exports.UpsertBranchRequestBody = zod_1.z.object({
    git: common_js_1.GitMeta.optional(),
    env: zod_1.z.enum(["preview"]),
    branch: zod_1.z.string(),
});
exports.UpsertBranchResponseBody = zod_1.z.object({
    id: zod_1.z.string(),
});
exports.CreateArtifactRequestBody = zod_1.z.object({
    type: zod_1.z.enum(["deployment_context"]).default("deployment_context"),
    contentType: zod_1.z.string().default("application/gzip"),
    contentLength: zod_1.z.number().optional(),
});
exports.CreateArtifactResponseBody = zod_1.z.object({
    artifactKey: zod_1.z.string(),
    uploadUrl: zod_1.z.string(),
    uploadFields: zod_1.z.record(zod_1.z.string()),
    expiresAt: zod_1.z.string().datetime(),
});
exports.InitializeDeploymentResponseBody = zod_1.z.object({
    id: zod_1.z.string(),
    contentHash: zod_1.z.string(),
    shortCode: zod_1.z.string(),
    version: zod_1.z.string(),
    imageTag: zod_1.z.string(),
    imagePlatform: zod_1.z.string(),
    externalBuildData: exports.ExternalBuildData.optional().nullable(),
    eventStream: zod_1.z
        .object({
        s2: zod_1.z.object({
            basin: zod_1.z.string(),
            stream: zod_1.z.string(),
            accessToken: zod_1.z.string(),
        }),
    })
        .optional(),
});
exports.InitializeDeploymentRequestBody = zod_1.z
    .object({
    contentHash: zod_1.z.string(),
    userId: zod_1.z.string().optional(),
    /** @deprecated This is now determined by the webapp. This is only used to warn users with old CLI versions. */
    selfHosted: zod_1.z.boolean().optional(),
    gitMeta: common_js_1.GitMeta.optional(),
    type: zod_1.z.enum(["MANAGED", "UNMANAGED", "V1"]).optional(),
    runtime: zod_1.z.string().optional(),
    initialStatus: zod_1.z.enum(["PENDING", "BUILDING"]).optional(),
    triggeredVia: exports.DeploymentTriggeredVia.optional(),
    buildId: zod_1.z.string().optional(),
})
    .and(zod_1.z.preprocess((val) => {
    const obj = val;
    if (!obj || !obj.isNativeBuild) {
        return { ...obj, isNativeBuild: false };
    }
    return obj;
}, zod_1.z.discriminatedUnion("isNativeBuild", [
    zod_1.z.object({
        isNativeBuild: zod_1.z.literal(true),
        skipPromotion: zod_1.z.boolean(),
        artifactKey: zod_1.z.string(),
        configFilePath: zod_1.z.string().optional(),
    }),
    zod_1.z.object({
        isNativeBuild: zod_1.z.literal(false),
    }),
])));
exports.RemoteBuildProviderStatusResponseBody = zod_1.z.object({
    status: zod_1.z.enum(["operational", "degraded", "unknown"]),
    message: zod_1.z.string(),
});
exports.GenerateRegistryCredentialsResponseBody = zod_1.z.object({
    username: zod_1.z.string(),
    password: zod_1.z.string(),
    expiresAt: zod_1.z.string(),
    repositoryUri: zod_1.z.string(),
});
exports.DeploymentErrorData = zod_1.z.object({
    name: zod_1.z.string(),
    message: zod_1.z.string(),
    stack: zod_1.z.string().optional(),
    stderr: zod_1.z.string().optional(),
});
exports.FailDeploymentRequestBody = zod_1.z.object({
    error: exports.DeploymentErrorData,
});
exports.FailDeploymentResponseBody = zod_1.z.object({
    id: zod_1.z.string(),
});
exports.PromoteDeploymentResponseBody = zod_1.z.object({
    id: zod_1.z.string(),
    version: zod_1.z.string(),
    shortCode: zod_1.z.string(),
});
exports.GetDeploymentResponseBody = zod_1.z.object({
    id: zod_1.z.string(),
    status: zod_1.z.enum([
        "PENDING",
        "INSTALLING",
        "BUILDING",
        "DEPLOYING",
        "DEPLOYED",
        "FAILED",
        "CANCELED",
        "TIMED_OUT",
    ]),
    contentHash: zod_1.z.string(),
    shortCode: zod_1.z.string(),
    version: zod_1.z.string(),
    imageReference: zod_1.z.string().nullish(),
    imagePlatform: zod_1.z.string(),
    externalBuildData: exports.ExternalBuildData.optional().nullable(),
    errorData: exports.DeploymentErrorData.nullish(),
    worker: zod_1.z
        .object({
        id: zod_1.z.string(),
        version: zod_1.z.string(),
        tasks: zod_1.z.array(zod_1.z.object({
            id: zod_1.z.string(),
            slug: zod_1.z.string(),
            filePath: zod_1.z.string(),
            exportName: zod_1.z.string().optional(),
        })),
    })
        .optional(),
});
exports.GetLatestDeploymentResponseBody = exports.GetDeploymentResponseBody.omit({
    worker: true,
});
exports.DeploymentLogEvent = zod_1.z.object({
    type: zod_1.z.literal("log"),
    data: zod_1.z.object({
        level: zod_1.z.enum(["debug", "info", "warn", "error"]).optional().default("info"),
        message: zod_1.z.string(),
    }),
});
exports.DeploymentFinalizedEvent = zod_1.z.object({
    type: zod_1.z.literal("finalized"),
    data: zod_1.z.object({
        result: zod_1.z.enum(["succeeded", "failed", "timed_out", "canceled"]).or(anyString),
        message: zod_1.z.string().optional(),
    }),
});
exports.DeploymentEvent = zod_1.z.discriminatedUnion("type", [
    exports.DeploymentLogEvent,
    exports.DeploymentFinalizedEvent,
]);
exports.DeploymentEventFromString = zod_1.z
    .string()
    .transform((s, ctx) => {
    try {
        return JSON.parse(s);
    }
    catch {
        ctx.addIssue({ code: zod_1.z.ZodIssueCode.custom, message: "Invalid JSON" });
        return zod_1.z.NEVER;
    }
})
    .pipe(exports.DeploymentEvent);
exports.CreateUploadPayloadUrlResponseBody = zod_1.z.object({
    presignedUrl: zod_1.z.string(),
});
exports.WorkersListResponseBody = zod_1.z
    .object({
    type: zod_1.z.string(),
    name: zod_1.z.string(),
    description: zod_1.z.string().nullish(),
    latestVersion: zod_1.z.string().nullish(),
    lastHeartbeatAt: zod_1.z.string().nullish(),
    isDefault: zod_1.z.boolean(),
    updatedAt: zod_1.z.coerce.date(),
})
    .array();
exports.WorkersCreateRequestBody = zod_1.z.object({
    name: zod_1.z.string().optional(),
    description: zod_1.z.string().optional(),
});
exports.WorkersCreateResponseBody = zod_1.z.object({
    workerGroup: zod_1.z.object({
        name: zod_1.z.string(),
        description: zod_1.z.string().nullish(),
    }),
    token: zod_1.z.object({
        plaintext: zod_1.z.string(),
    }),
});
exports.DevConfigResponseBody = zod_1.z.object({
    environmentId: zod_1.z.string(),
    dequeueIntervalWithRun: zod_1.z.number(),
    dequeueIntervalWithoutRun: zod_1.z.number(),
    maxConcurrentRuns: zod_1.z.number(),
    engineUrl: zod_1.z.string(),
});
exports.DevDequeueRequestBody = zod_1.z.object({
    currentWorker: zod_1.z.string(),
    oldWorkers: zod_1.z.string().array(),
    maxResources: runEngine_js_1.MachineResources.optional(),
});
exports.DevDequeueResponseBody = zod_1.z.object({
    dequeuedMessages: runEngine_js_1.DequeuedMessage.array(),
});
exports.ReplayRunResponse = zod_1.z.object({
    id: zod_1.z.string(),
});
exports.CanceledRunResponse = zod_1.z.object({
    id: zod_1.z.string(),
});
exports.ResetIdempotencyKeyResponse = zod_1.z.object({
    id: zod_1.z.string(),
});
exports.ScheduleType = zod_1.z.union([zod_1.z.literal("DECLARATIVE"), zod_1.z.literal("IMPERATIVE")]);
exports.ScheduledTaskPayload = zod_1.z.object({
    /** The schedule id associated with this run (you can have many schedules for the same task).
      You can use this to remove the schedule, update it, etc */
    scheduleId: zod_1.z.string(),
    /** The type of schedule – `"DECLARATIVE"` or `"IMPERATIVE"`.
     *
     * **DECLARATIVE** – defined inline on your `schedules.task` using the `cron` property. They can only be created, updated or deleted by modifying the `cron` property on your task.
     *
     * **IMPERATIVE** – created using the `schedules.create` functions or in the dashboard.
     */
    type: exports.ScheduleType,
    /** When the task was scheduled to run.
     * Note this will be slightly different from `new Date()` because it takes a few ms to run the task.
     *
     * This date is UTC. To output it as a string with a timezone you would do this:
     * ```ts
     * const formatted = payload.timestamp.toLocaleString("en-US", {
          timeZone: payload.timezone,
      });
      ```  */
    timestamp: zod_1.z.date(),
    /** When the task was last run (it has been).
      This can be undefined if it's never been run. This date is UTC. */
    lastTimestamp: zod_1.z.date().optional(),
    /** You can optionally provide an external id when creating the schedule.
      Usually you would use a userId or some other unique identifier.
      This defaults to undefined if you didn't provide one. */
    externalId: zod_1.z.string().optional(),
    /** The IANA timezone the schedule is set to. The default is UTC.
     * You can see the full list of supported timezones here: https://cloud.trigger.dev/timezones
     */
    timezone: zod_1.z.string(),
    /** The next 5 dates this task is scheduled to run */
    upcoming: zod_1.z.array(zod_1.z.date()),
});
exports.CreateScheduleOptions = zod_1.z.object({
    /** The id of the task you want to attach to. */
    task: zod_1.z.string(),
    /**  The schedule in CRON format.
     *
     * ```txt
  *    *    *    *    *    *
  ┬    ┬    ┬    ┬    ┬
  │    │    │    │    |
  │    │    │    │    └ day of week (0 - 7, 1L - 7L) (0 or 7 is Sun)
  │    │    │    └───── month (1 - 12)
  │    │    └────────── day of month (1 - 31, L)
  │    └─────────────── hour (0 - 23)
  └──────────────────── minute (0 - 59)
     * ```
  
  "L" means the last. In the "day of week" field, 1L means the last Monday of the month. In the day of month field, L means the last day of the month.
  
     */
    cron: zod_1.z.string(),
    /** You can only create one schedule with this key. If you use it twice, the second call will update the schedule.
     *
     * This is required to prevent you from creating duplicate schedules. */
    deduplicationKey: zod_1.z.string(),
    /** Optionally, you can specify your own IDs (like a user ID) and then use it inside the run function of your task.
     *
     * This allows you to have per-user CRON tasks.
     */
    externalId: zod_1.z.string().optional(),
    /** Optionally, you can specify a timezone in the IANA format. If unset it will use UTC.
     * If specified then the CRON will be evaluated in that timezone and will respect daylight savings.
     *
     * If you set the CRON to `0 0 * * *` and the timezone to `America/New_York` then the task will run at midnight in New York time, no matter whether it's daylight savings or not.
     *
     * You can see the full list of supported timezones here: https://cloud.trigger.dev/timezones
     *
     * @example "America/New_York", "Europe/London", "Asia/Tokyo", "Africa/Cairo"
     *
     */
    timezone: zod_1.z.string().optional(),
});
exports.UpdateScheduleOptions = exports.CreateScheduleOptions.omit({ deduplicationKey: true });
exports.ScheduleGenerator = zod_1.z.object({
    type: zod_1.z.literal("CRON"),
    expression: zod_1.z.string(),
    description: zod_1.z.string(),
});
exports.ScheduleObject = zod_1.z.object({
    id: zod_1.z.string(),
    type: exports.ScheduleType,
    task: zod_1.z.string(),
    active: zod_1.z.boolean(),
    deduplicationKey: zod_1.z.string().nullish(),
    externalId: zod_1.z.string().nullish(),
    generator: exports.ScheduleGenerator,
    timezone: zod_1.z.string(),
    nextRun: zod_1.z.coerce.date().nullish(),
    environments: zod_1.z.array(zod_1.z.object({
        id: zod_1.z.string(),
        type: zod_1.z.string(),
        userName: zod_1.z.string().nullish(),
    })),
});
exports.DeletedScheduleObject = zod_1.z.object({
    id: zod_1.z.string(),
});
exports.ListSchedulesResult = zod_1.z.object({
    data: zod_1.z.array(exports.ScheduleObject),
    pagination: zod_1.z.object({
        currentPage: zod_1.z.number(),
        totalPages: zod_1.z.number(),
        count: zod_1.z.number(),
    }),
});
exports.ListScheduleOptions = zod_1.z.object({
    page: zod_1.z.number().optional(),
    perPage: zod_1.z.number().optional(),
});
exports.TimezonesResult = zod_1.z.object({
    timezones: zod_1.z.array(zod_1.z.string()),
});
exports.RunStatus = zod_1.z.enum([
    /// Task is waiting for a version update because it cannot execute without additional information (task, queue, etc.)
    "PENDING_VERSION",
    /// Task is waiting to be executed by a worker
    "QUEUED",
    /// Task is waiting to be executed by a worker
    "DEQUEUED",
    /// Task is currently being executed by a worker
    "EXECUTING",
    /// Task has been paused by the system, and will be resumed by the system
    "WAITING",
    /// Task has been completed successfully
    "COMPLETED",
    /// Task has been canceled by the user
    "CANCELED",
    /// Task has been completed with errors
    "FAILED",
    /// Task has crashed and won't be retried, most likely the worker ran out of resources, e.g. memory or storage
    "CRASHED",
    /// Task has failed to complete, due to an error in the system
    "SYSTEM_FAILURE",
    /// Task has been scheduled to run at a specific time
    "DELAYED",
    /// Task has expired and won't be executed
    "EXPIRED",
    /// Task has reached it's maxDuration and has been stopped
    "TIMED_OUT",
]);
exports.AttemptStatus = zod_1.z.enum([
    "PENDING",
    "EXECUTING",
    "PAUSED",
    "COMPLETED",
    "FAILED",
    "CANCELED",
]);
exports.RunEnvironmentDetails = zod_1.z.object({
    id: zod_1.z.string(),
    name: zod_1.z.string(),
    user: zod_1.z.string().optional(),
});
exports.RunScheduleDetails = zod_1.z.object({
    id: zod_1.z.string(),
    externalId: zod_1.z.string().optional(),
    deduplicationKey: zod_1.z.string().optional(),
    generator: exports.ScheduleGenerator,
});
exports.TriggerFunction = zod_1.z.enum([
    "triggerAndWait",
    "trigger",
    "batchTriggerAndWait",
    "batchTrigger",
]);
const CommonRunFields = {
    id: zod_1.z.string(),
    status: exports.RunStatus,
    taskIdentifier: zod_1.z.string(),
    idempotencyKey: zod_1.z.string().optional(),
    version: zod_1.z.string().optional(),
    isQueued: zod_1.z.boolean(),
    isExecuting: zod_1.z.boolean(),
    isWaiting: zod_1.z.boolean(),
    isCompleted: zod_1.z.boolean(),
    isSuccess: zod_1.z.boolean(),
    isFailed: zod_1.z.boolean(),
    isCancelled: zod_1.z.boolean(),
    isTest: zod_1.z.boolean(),
    createdAt: zod_1.z.coerce.date(),
    updatedAt: zod_1.z.coerce.date(),
    startedAt: zod_1.z.coerce.date().optional(),
    finishedAt: zod_1.z.coerce.date().optional(),
    delayedUntil: zod_1.z.coerce.date().optional(),
    ttl: zod_1.z.string().optional(),
    expiredAt: zod_1.z.coerce.date().optional(),
    tags: zod_1.z.string().array(),
    costInCents: zod_1.z.number(),
    baseCostInCents: zod_1.z.number(),
    durationMs: zod_1.z.number(),
    metadata: zod_1.z.record(zod_1.z.any()).optional(),
};
const RetrieveRunCommandFields = {
    ...CommonRunFields,
    depth: zod_1.z.number(),
    triggerFunction: zod_1.z.enum(["triggerAndWait", "trigger", "batchTriggerAndWait", "batchTrigger"]),
    batchId: zod_1.z.string().optional(),
};
exports.RelatedRunDetails = zod_1.z.object(RetrieveRunCommandFields);
exports.RetrieveRunResponse = zod_1.z.object({
    ...RetrieveRunCommandFields,
    payload: zod_1.z.any().optional(),
    payloadPresignedUrl: zod_1.z.string().optional(),
    output: zod_1.z.any().optional(),
    outputPresignedUrl: zod_1.z.string().optional(),
    error: common_js_1.SerializedError.optional(),
    schedule: exports.RunScheduleDetails.optional(),
    relatedRuns: zod_1.z.object({
        root: exports.RelatedRunDetails.optional(),
        parent: exports.RelatedRunDetails.optional(),
        children: zod_1.z.array(exports.RelatedRunDetails).optional(),
    }),
    attemptCount: zod_1.z.number().default(0),
});
exports.ListRunResponseItem = zod_1.z.object({
    ...CommonRunFields,
    env: exports.RunEnvironmentDetails,
});
exports.ListRunResponse = zod_1.z.object({
    data: zod_1.z.array(exports.ListRunResponseItem),
    pagination: zod_1.z.object({
        next: zod_1.z.string().optional(),
        previous: zod_1.z.string().optional(),
    }),
});
exports.CreateEnvironmentVariableRequestBody = zod_1.z.object({
    name: zod_1.z.string(),
    value: zod_1.z.string(),
});
exports.UpdateEnvironmentVariableRequestBody = zod_1.z.object({
    value: zod_1.z.string(),
});
exports.ImportEnvironmentVariablesRequestBody = zod_1.z.object({
    variables: zod_1.z.record(zod_1.z.string()),
    parentVariables: zod_1.z.record(zod_1.z.string()).optional(),
    override: zod_1.z.boolean().optional(),
});
exports.EnvironmentVariableResponseBody = zod_1.z.object({
    success: zod_1.z.boolean(),
});
exports.EnvironmentVariableValue = zod_1.z.object({
    value: zod_1.z.string(),
});
exports.EnvironmentVariable = zod_1.z.object({
    name: zod_1.z.string(),
    value: zod_1.z.string(),
});
exports.EnvironmentVariables = zod_1.z.array(exports.EnvironmentVariable);
exports.EnvironmentVariableWithSecret = zod_1.z.object({
    /** The name of the env var, e.g. `DATABASE_URL` */
    name: zod_1.z.string(),
    /** The value of the env var. If it's a secret, this will be a redacted value, not the real value.  */
    value: zod_1.z.string(),
    /**
     * Whether the env var is a secret or not.
     * When you create env vars you can mark them as secrets.
     *
     * You can't view the value of a secret env var after setting it initially.
     * For a secret env var, the value will be redacted.
     */
    isSecret: zod_1.z.boolean(),
});
exports.UpdateMetadataRequestBody = common_js_1.FlushedRunMetadata;
exports.UpdateMetadataResponseBody = zod_1.z.object({
    metadata: zod_1.z.record(json_js_1.DeserializedJsonSchema),
});
const RawShapeDate = zod_1.z
    .string()
    .transform((val) => `${val}Z`)
    .pipe(zod_1.z.coerce.date());
const RawOptionalShapeDate = zod_1.z
    .string()
    .nullish()
    .transform((val) => (val ? new Date(`${val}Z`) : val));
exports.SubscribeRunRawShape = zod_1.z.object({
    id: zod_1.z.string(),
    taskIdentifier: zod_1.z.string(),
    friendlyId: zod_1.z.string(),
    status: zod_1.z.string(),
    createdAt: RawShapeDate,
    updatedAt: RawShapeDate,
    startedAt: RawOptionalShapeDate,
    delayUntil: RawOptionalShapeDate,
    queuedAt: RawOptionalShapeDate,
    expiredAt: RawOptionalShapeDate,
    completedAt: RawOptionalShapeDate,
    idempotencyKey: zod_1.z.string().nullish(),
    number: zod_1.z.number().default(0),
    isTest: zod_1.z.boolean().default(false),
    usageDurationMs: zod_1.z.number().default(0),
    costInCents: zod_1.z.number().default(0),
    baseCostInCents: zod_1.z.number().default(0),
    ttl: zod_1.z.string().nullish(),
    payload: zod_1.z.string().nullish(),
    payloadType: zod_1.z.string().nullish(),
    metadata: zod_1.z.string().nullish(),
    metadataType: zod_1.z.string().nullish(),
    output: zod_1.z.string().nullish(),
    outputType: zod_1.z.string().nullish(),
    runTags: zod_1.z.array(zod_1.z.string()).nullish().default([]),
    error: common_js_1.TaskRunError.nullish(),
    realtimeStreams: zod_1.z.array(zod_1.z.string()).nullish().default([]),
});
exports.BatchStatus = zod_1.z.enum([
    "PENDING",
    "PROCESSING",
    "COMPLETED",
    "PARTIAL_FAILED",
    "ABORTED",
]);
exports.RetrieveBatchResponse = zod_1.z.object({
    id: zod_1.z.string(),
    status: exports.BatchStatus,
    idempotencyKey: zod_1.z.string().optional(),
    createdAt: zod_1.z.coerce.date(),
    updatedAt: zod_1.z.coerce.date(),
    runCount: zod_1.z.number(),
    runs: zod_1.z.array(zod_1.z.string()),
});
exports.RetrieveBatchV2Response = zod_1.z.object({
    id: zod_1.z.string(),
    status: exports.BatchStatus,
    idempotencyKey: zod_1.z.string().optional(),
    createdAt: zod_1.z.coerce.date(),
    updatedAt: zod_1.z.coerce.date(),
    runCount: zod_1.z.number(),
    runs: zod_1.z.array(zod_1.z.string()),
    processing: zod_1.z.object({
        completedAt: zod_1.z.coerce.date().optional(),
        errors: zod_1.z.array(zod_1.z.object({
            index: zod_1.z.number(),
            taskIdentifier: zod_1.z.string(),
            error: zod_1.z.string(),
            errorCode: zod_1.z.string().optional(),
        })),
    }),
});
exports.SubscribeRealtimeStreamChunkRawShape = zod_1.z.object({
    id: zod_1.z.string(),
    runId: zod_1.z.string(),
    sequence: zod_1.z.number(),
    key: zod_1.z.string(),
    value: zod_1.z.string(),
    createdAt: zod_1.z.coerce.date(),
});
exports.TimePeriod = zod_1.z.string().or(zod_1.z.coerce.date());
exports.CreateWaitpointTokenRequestBody = zod_1.z.object({
    /**
     * An optional idempotency key for the waitpoint.
     * If you use the same key twice (and the key hasn't expired), you will get the original waitpoint back.
     *
     * Note: This waitpoint may already be complete, in which case when you wait for it, it will immediately continue.
     */
    idempotencyKey: zod_1.z.string().optional(),
    /**
     * When set, this means the passed in idempotency key will expire after this time.
     * This means after that time if you pass the same idempotency key again, you will get a new waitpoint.
     */
    idempotencyKeyTTL: zod_1.z.string().optional(),
    /** The resume token will timeout after this time.
     * If you are waiting for the token in a run, the token will return a result where `ok` is false.
     *
     * You can pass a `Date` object, or a string in this format: "30s", "1m", "2h", "3d", "4w".
     */
    timeout: exports.TimePeriod.optional(),
    /**
     * Tags to attach to the waitpoint. Tags can be used to filter waitpoints in the dashboard.
     *
     * You can set up to 10 tags per waitpoint, they must be less than 128 characters each.
     *
     * We recommend prefixing tags with a namespace using an underscore or colon, like `user_1234567` or `org:9876543`.
     *
     * @example
     *
     * ```ts
     * await wait.createToken({ tags: ["user:1234567", "org:9876543"] });
     * ```
     */
    tags: exports.RunTags.optional(),
});
exports.CreateWaitpointTokenResponseBody = zod_1.z.object({
    id: zod_1.z.string(),
    isCached: zod_1.z.boolean(),
    url: zod_1.z.string(),
});
exports.waitpointTokenStatuses = ["WAITING", "COMPLETED", "TIMED_OUT"];
exports.WaitpointTokenStatus = zod_1.z.enum(exports.waitpointTokenStatuses);
exports.WaitpointTokenItem = zod_1.z.object({
    id: zod_1.z.string(),
    /** If you make a POST request to this URL, it will complete the waitpoint. */
    url: zod_1.z.string(),
    status: exports.WaitpointTokenStatus,
    completedAt: zod_1.z.coerce.date().optional(),
    completedAfter: zod_1.z.coerce.date().optional(),
    timeoutAt: zod_1.z.coerce.date().optional(),
    idempotencyKey: zod_1.z.string().optional(),
    idempotencyKeyExpiresAt: zod_1.z.coerce.date().optional(),
    tags: zod_1.z.array(zod_1.z.string()),
    createdAt: zod_1.z.coerce.date(),
});
exports.WaitpointListTokenItem = exports.WaitpointTokenItem.omit({
    completedAfter: true,
});
exports.WaitpointRetrieveTokenResponse = exports.WaitpointListTokenItem.and(zod_1.z.object({
    output: zod_1.z.string().optional(),
    outputType: zod_1.z.string().optional(),
    outputIsError: zod_1.z.boolean().optional(),
}));
exports.CompleteWaitpointTokenRequestBody = zod_1.z.object({
    data: zod_1.z.any().nullish(),
});
exports.CompleteWaitpointTokenResponseBody = zod_1.z.object({
    success: zod_1.z.literal(true),
});
exports.WaitForWaitpointTokenResponseBody = zod_1.z.object({
    success: zod_1.z.boolean(),
});
exports.WaitForDurationRequestBody = zod_1.z.object({
    /**
     * An optional idempotency key for the waitpoint.
     * If you use the same key twice (and the key hasn't expired), you will get the original waitpoint back.
     *
     * Note: This waitpoint may already be complete, in which case when you wait for it, it will immediately continue.
     */
    idempotencyKey: zod_1.z.string().optional(),
    /**
     * When set, this means the passed in idempotency key will expire after this time.
     * This means after that time if you pass the same idempotency key again, you will get a new waitpoint.
     */
    idempotencyKeyTTL: zod_1.z.string().optional(),
    /**
     * The date that the waitpoint will complete.
     */
    date: zod_1.z.coerce.date(),
});
exports.WaitForDurationResponseBody = zod_1.z.object({
    /**
        If you pass an idempotencyKey, you may actually not need to wait.
        Use this date to determine when to continue.
    */
    waitUntil: zod_1.z.coerce.date(),
    waitpoint: zod_1.z.object({
        id: zod_1.z.string(),
    }),
});
const WAITPOINT_TIMEOUT_ERROR_CODE = "TRIGGER_WAITPOINT_TIMEOUT";
function isWaitpointOutputTimeout(output) {
    try {
        const json = JSON.parse(output);
        return json.code === WAITPOINT_TIMEOUT_ERROR_CODE;
    }
    catch (e) {
        return false;
    }
}
function timeoutError(timeout) {
    return {
        code: WAITPOINT_TIMEOUT_ERROR_CODE,
        message: `Waitpoint timed out at ${timeout.toISOString()}`,
    };
}
const ApiDeploymentCommonShape = {
    from: zod_1.z.string().describe("The date to start the search from, in ISO 8601 format").optional(),
    to: zod_1.z.string().describe("The date to end the search, in ISO 8601 format").optional(),
    period: zod_1.z.string().describe("The period to search within (e.g. 1d, 7d, 3h, etc.)").optional(),
    status: zod_1.z
        .enum(["PENDING", "BUILDING", "DEPLOYING", "DEPLOYED", "FAILED", "CANCELED", "TIMED_OUT"])
        .describe("Filter deployments that are in this status")
        .optional(),
};
const ApiDeploymentListPaginationCursor = zod_1.z
    .string()
    .describe("The deployment ID to start the search from, to get the next page")
    .optional();
const ApiDeploymentListPaginationLimit = zod_1.z.coerce
    .number()
    .describe("The number of deployments to return, defaults to 20 (max 100)")
    .min(1, "Limit must be at least 1")
    .max(100, "Limit must be less than 100")
    .optional();
exports.ApiDeploymentListParams = {
    ...ApiDeploymentCommonShape,
    cursor: ApiDeploymentListPaginationCursor,
    limit: ApiDeploymentListPaginationLimit,
};
exports.ApiDeploymentListOptions = zod_1.z.object(exports.ApiDeploymentListParams);
exports.ApiDeploymentListSearchParams = zod_1.z.object({
    ...ApiDeploymentCommonShape,
    "page[after]": ApiDeploymentListPaginationCursor,
    "page[size]": ApiDeploymentListPaginationLimit,
});
exports.ApiDeploymentListResponseItem = zod_1.z.object({
    id: zod_1.z.string(),
    createdAt: zod_1.z.coerce.date(),
    shortCode: zod_1.z.string(),
    version: zod_1.z.string(),
    runtime: zod_1.z.string(),
    runtimeVersion: zod_1.z.string(),
    status: zod_1.z.enum([
        "PENDING",
        "BUILDING",
        "DEPLOYING",
        "DEPLOYED",
        "FAILED",
        "CANCELED",
        "TIMED_OUT",
    ]),
    deployedAt: zod_1.z.coerce.date().optional(),
    git: zod_1.z.record(zod_1.z.any()).optional(),
    error: exports.DeploymentErrorData.optional(),
});
exports.ApiBranchListResponseBody = zod_1.z.object({
    branches: zod_1.z.array(zod_1.z.object({
        id: zod_1.z.string(),
        name: zod_1.z.string(),
        createdAt: zod_1.z.coerce.date(),
        updatedAt: zod_1.z.coerce.date(),
        git: zod_1.z.record(zod_1.z.any()).optional(),
        isPaused: zod_1.z.boolean(),
    })),
});
exports.RetrieveRunTraceSpanSchema = zod_1.z.object({
    id: zod_1.z.string(),
    parentId: zod_1.z.string().optional(),
    runId: zod_1.z.string(),
    data: zod_1.z.object({
        message: zod_1.z.string(),
        taskSlug: zod_1.z.string().optional(),
        taskPath: zod_1.z.string().optional(),
        events: zod_1.z.array(zod_1.z.any()).optional(),
        startTime: zod_1.z.coerce.date(),
        duration: zod_1.z.number(),
        isError: zod_1.z.boolean(),
        isPartial: zod_1.z.boolean(),
        isCancelled: zod_1.z.boolean(),
        level: zod_1.z.string(),
        workerVersion: zod_1.z.string().optional(),
        queueName: zod_1.z.string().optional(),
        machinePreset: zod_1.z.string().optional(),
        properties: zod_1.z.record(zod_1.z.any()).optional(),
        output: zod_1.z.unknown().optional(),
    }),
});
exports.RetrieveRunTraceSpan = exports.RetrieveRunTraceSpanSchema.extend({
    children: zod_1.z.lazy(() => exports.RetrieveRunTraceSpan.array()),
});
exports.RetrieveRunTraceResponseBody = zod_1.z.object({
    trace: zod_1.z.object({
        traceId: zod_1.z.string(),
        rootSpan: exports.RetrieveRunTraceSpan,
    }),
});
exports.CreateStreamResponseBody = zod_1.z.object({
    version: zod_1.z.string(),
});
exports.AppendToStreamResponseBody = zod_1.z.object({
    ok: zod_1.z.boolean(),
    message: zod_1.z.string().optional(),
});
//# sourceMappingURL=api.js.map