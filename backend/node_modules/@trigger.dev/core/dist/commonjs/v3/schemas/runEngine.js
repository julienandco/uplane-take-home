"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DequeuedMessage = exports.PlacementTag = exports.DequeueMessageCheckpoint = exports.MachineResources = exports.CreateCheckpointResult = exports.RunExecutionData = exports.TaskRunCheckpoint = exports.CheckpointInput = exports.CheckpointType = exports.CheckpointTypeEnum = exports.CompleteRunAttemptResult = exports.StartRunAttemptResult = exports.ExecutionResult = exports.CompletedWaitpoint = exports.WaitpointStatus = exports.WaitpointType = exports.TaskRunStatus = exports.TaskRunExecutionStatus = void 0;
const zod_1 = require("zod");
const common_js_1 = require("./common.js");
const schemas_js_1 = require("./schemas.js");
exports.TaskRunExecutionStatus = {
    RUN_CREATED: "RUN_CREATED",
    QUEUED: "QUEUED",
    QUEUED_EXECUTING: "QUEUED_EXECUTING",
    PENDING_EXECUTING: "PENDING_EXECUTING",
    EXECUTING: "EXECUTING",
    EXECUTING_WITH_WAITPOINTS: "EXECUTING_WITH_WAITPOINTS",
    SUSPENDED: "SUSPENDED",
    PENDING_CANCEL: "PENDING_CANCEL",
    FINISHED: "FINISHED",
    DELAYED: "DELAYED",
};
exports.TaskRunStatus = {
    DELAYED: "DELAYED",
    PENDING: "PENDING",
    PENDING_VERSION: "PENDING_VERSION",
    WAITING_FOR_DEPLOY: "WAITING_FOR_DEPLOY",
    DEQUEUED: "DEQUEUED",
    EXECUTING: "EXECUTING",
    WAITING_TO_RESUME: "WAITING_TO_RESUME",
    RETRYING_AFTER_FAILURE: "RETRYING_AFTER_FAILURE",
    PAUSED: "PAUSED",
    CANCELED: "CANCELED",
    INTERRUPTED: "INTERRUPTED",
    COMPLETED_SUCCESSFULLY: "COMPLETED_SUCCESSFULLY",
    COMPLETED_WITH_ERRORS: "COMPLETED_WITH_ERRORS",
    SYSTEM_FAILURE: "SYSTEM_FAILURE",
    CRASHED: "CRASHED",
    EXPIRED: "EXPIRED",
    TIMED_OUT: "TIMED_OUT",
};
exports.WaitpointType = {
    RUN: "RUN",
    DATETIME: "DATETIME",
    MANUAL: "MANUAL",
    BATCH: "BATCH",
};
const WaitpointStatusValues = {
    PENDING: "PENDING",
    COMPLETED: "COMPLETED",
};
exports.WaitpointStatus = zod_1.z.enum(Object.values(WaitpointStatusValues));
exports.CompletedWaitpoint = zod_1.z.object({
    id: zod_1.z.string(),
    index: zod_1.z.number().optional(),
    friendlyId: zod_1.z.string(),
    type: zod_1.z.enum(Object.values(exports.WaitpointType)),
    completedAt: zod_1.z.coerce.date(),
    idempotencyKey: zod_1.z.string().optional(),
    /** For type === "RUN" */
    completedByTaskRun: zod_1.z
        .object({
        id: zod_1.z.string(),
        friendlyId: zod_1.z.string(),
        /** If the run has an associated batch */
        batch: zod_1.z
            .object({
            id: zod_1.z.string(),
            friendlyId: zod_1.z.string(),
        })
            .optional(),
    })
        .optional(),
    /** For type === "DATETIME" */
    completedAfter: zod_1.z.coerce.date().optional(),
    /** For type === "BATCH" */
    completedByBatch: zod_1.z
        .object({
        id: zod_1.z.string(),
        friendlyId: zod_1.z.string(),
    })
        .optional(),
    output: zod_1.z.string().optional(),
    outputType: zod_1.z.string().optional(),
    outputIsError: zod_1.z.boolean(),
});
const ExecutionSnapshot = zod_1.z.object({
    id: zod_1.z.string(),
    friendlyId: zod_1.z.string(),
    executionStatus: zod_1.z.enum(Object.values(exports.TaskRunExecutionStatus)),
    description: zod_1.z.string(),
    createdAt: zod_1.z.coerce.date(),
});
const BaseRunMetadata = zod_1.z.object({
    id: zod_1.z.string(),
    friendlyId: zod_1.z.string(),
    status: zod_1.z.enum(Object.values(exports.TaskRunStatus)),
    attemptNumber: zod_1.z.number().nullish(),
    taskEventStore: zod_1.z.string().optional(),
});
exports.ExecutionResult = zod_1.z.object({
    snapshot: ExecutionSnapshot,
    run: BaseRunMetadata,
});
/** The response to the Worker when starting an attempt */
exports.StartRunAttemptResult = exports.ExecutionResult.and(zod_1.z.object({
    execution: common_js_1.TaskRunExecution,
}));
/** The response to the Worker when completing an attempt */
const CompleteAttemptStatus = zod_1.z.enum([
    "RUN_FINISHED",
    "RUN_PENDING_CANCEL",
    "RETRY_QUEUED",
    "RETRY_IMMEDIATELY",
]);
exports.CompleteRunAttemptResult = zod_1.z
    .object({
    attemptStatus: CompleteAttemptStatus,
})
    .and(exports.ExecutionResult);
exports.CheckpointTypeEnum = {
    DOCKER: "DOCKER",
    KUBERNETES: "KUBERNETES",
};
exports.CheckpointType = zod_1.z.enum(Object.values(exports.CheckpointTypeEnum));
exports.CheckpointInput = zod_1.z.object({
    type: exports.CheckpointType,
    location: zod_1.z.string(),
    imageRef: zod_1.z.string().nullish(),
    reason: zod_1.z.string().nullish(),
});
exports.TaskRunCheckpoint = exports.CheckpointInput.merge(zod_1.z.object({
    id: zod_1.z.string(),
    friendlyId: zod_1.z.string(),
}));
/** The response when a Worker asks for the latest execution state */
exports.RunExecutionData = zod_1.z.object({
    version: zod_1.z.literal("1"),
    snapshot: ExecutionSnapshot,
    run: BaseRunMetadata,
    batch: zod_1.z
        .object({
        id: zod_1.z.string(),
        friendlyId: zod_1.z.string(),
    })
        .optional(),
    checkpoint: exports.TaskRunCheckpoint.optional(),
    completedWaitpoints: zod_1.z.array(exports.CompletedWaitpoint),
});
exports.CreateCheckpointResult = zod_1.z.discriminatedUnion("ok", [
    zod_1.z
        .object({
        ok: zod_1.z.literal(true),
        checkpoint: exports.TaskRunCheckpoint,
    })
        .merge(exports.ExecutionResult),
    zod_1.z.object({
        ok: zod_1.z.literal(false),
        error: zod_1.z.string(),
    }),
]);
exports.MachineResources = zod_1.z.object({
    cpu: zod_1.z.number(),
    memory: zod_1.z.number(),
});
exports.DequeueMessageCheckpoint = zod_1.z.object({
    id: zod_1.z.string(),
    type: exports.CheckpointType,
    location: zod_1.z.string(),
    imageRef: zod_1.z.string().nullish(),
    reason: zod_1.z.string().nullish(),
});
exports.PlacementTag = zod_1.z.object({
    key: zod_1.z.string(),
    values: zod_1.z.array(zod_1.z.string()).optional(),
});
/** This is sent to a Worker when a run is dequeued (a new run or continuing run) */
exports.DequeuedMessage = zod_1.z.object({
    version: zod_1.z.literal("1"),
    snapshot: ExecutionSnapshot,
    dequeuedAt: zod_1.z.coerce.date(),
    workerQueueLength: zod_1.z.number().optional(),
    image: zod_1.z.string().optional(),
    checkpoint: exports.DequeueMessageCheckpoint.optional(),
    completedWaitpoints: zod_1.z.array(exports.CompletedWaitpoint),
    backgroundWorker: zod_1.z.object({
        id: zod_1.z.string(),
        friendlyId: zod_1.z.string(),
        version: zod_1.z.string(),
    }),
    deployment: zod_1.z.object({
        id: zod_1.z.string().optional(),
        friendlyId: zod_1.z.string().optional(),
        imagePlatform: zod_1.z.string().optional(),
    }),
    run: zod_1.z.object({
        id: zod_1.z.string(),
        friendlyId: zod_1.z.string(),
        isTest: zod_1.z.boolean(),
        machine: common_js_1.MachinePreset,
        attemptNumber: zod_1.z.number(),
        masterQueue: zod_1.z.string(),
        traceContext: zod_1.z.record(zod_1.z.unknown()),
    }),
    environment: zod_1.z.object({
        id: zod_1.z.string(),
        type: schemas_js_1.EnvironmentType,
    }),
    organization: zod_1.z.object({
        id: zod_1.z.string(),
    }),
    project: zod_1.z.object({
        id: zod_1.z.string(),
    }),
    placementTags: zod_1.z.array(exports.PlacementTag).optional(),
});
//# sourceMappingURL=runEngine.js.map