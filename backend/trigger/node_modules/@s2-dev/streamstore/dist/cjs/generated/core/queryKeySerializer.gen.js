"use strict";
// This file is auto-generated by @hey-api/openapi-ts
Object.defineProperty(exports, "__esModule", { value: true });
exports.serializeQueryKeyValue = exports.stringifyToJsonValue = exports.queryKeyJsonReplacer = void 0;
/**
 * Replacer that converts non-JSON values (bigint, Date, etc.) to safe substitutes.
 */
const queryKeyJsonReplacer = (_key, value) => {
    if (value === undefined ||
        typeof value === 'function' ||
        typeof value === 'symbol') {
        return undefined;
    }
    if (typeof value === 'bigint') {
        return value.toString();
    }
    if (value instanceof Date) {
        return value.toISOString();
    }
    return value;
};
exports.queryKeyJsonReplacer = queryKeyJsonReplacer;
/**
 * Safely stringifies a value and parses it back into a JsonValue.
 */
const stringifyToJsonValue = (input) => {
    try {
        const json = JSON.stringify(input, exports.queryKeyJsonReplacer);
        if (json === undefined) {
            return undefined;
        }
        return JSON.parse(json);
    }
    catch {
        return undefined;
    }
};
exports.stringifyToJsonValue = stringifyToJsonValue;
/**
 * Detects plain objects (including objects with a null prototype).
 */
const isPlainObject = (value) => {
    if (value === null || typeof value !== 'object') {
        return false;
    }
    const prototype = Object.getPrototypeOf(value);
    return prototype === Object.prototype || prototype === null;
};
/**
 * Turns URLSearchParams into a sorted JSON object for deterministic keys.
 */
const serializeSearchParams = (params) => {
    const entries = Array.from(params.entries()).sort(([a], [b]) => a.localeCompare(b));
    const result = {};
    for (const [key, value] of entries) {
        const existing = result[key];
        if (existing === undefined) {
            result[key] = value;
            continue;
        }
        if (Array.isArray(existing)) {
            existing.push(value);
        }
        else {
            result[key] = [existing, value];
        }
    }
    return result;
};
/**
 * Normalizes any accepted value into a JSON-friendly shape for query keys.
 */
const serializeQueryKeyValue = (value) => {
    if (value === null) {
        return null;
    }
    if (typeof value === 'string' ||
        typeof value === 'number' ||
        typeof value === 'boolean') {
        return value;
    }
    if (value === undefined ||
        typeof value === 'function' ||
        typeof value === 'symbol') {
        return undefined;
    }
    if (typeof value === 'bigint') {
        return value.toString();
    }
    if (value instanceof Date) {
        return value.toISOString();
    }
    if (Array.isArray(value)) {
        return (0, exports.stringifyToJsonValue)(value);
    }
    if (typeof URLSearchParams !== 'undefined' &&
        value instanceof URLSearchParams) {
        return serializeSearchParams(value);
    }
    if (isPlainObject(value)) {
        return (0, exports.stringifyToJsonValue)(value);
    }
    return undefined;
};
exports.serializeQueryKeyValue = serializeQueryKeyValue;
//# sourceMappingURL=queryKeySerializer.gen.js.map