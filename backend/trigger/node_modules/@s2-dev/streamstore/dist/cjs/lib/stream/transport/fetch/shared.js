"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.streamRead = streamRead;
exports.streamAppend = streamAppend;
const error_js_1 = require("../../../../error.js");
const index_js_1 = require("../../../../generated/index.js");
const utils_js_1 = require("../../../../utils.js");
const base64_js_1 = require("../../../base64.js");
async function streamRead(stream, client, args, options) {
    const { as, ...queryParams } = args ?? {};
    const response = await (0, index_js_1.read)({
        client,
        path: {
            stream,
        },
        headers: {
            ...(as === "bytes" ? { "s2-format": "base64" } : {}),
        },
        query: queryParams,
        ...options,
    });
    if (response.error) {
        if ("message" in response.error) {
            throw new error_js_1.S2Error({
                message: response.error.message,
                code: response.error.code ?? undefined,
                status: response.response.status,
            });
        }
        else {
            // special case for 416 - Range Not Satisfiable
            throw new error_js_1.RangeNotSatisfiableError({
                status: response.response.status,
            });
        }
    }
    if (args?.as === "bytes") {
        const res = {
            ...response.data,
            records: response.data.records?.map((record) => ({
                ...record,
                body: record.body ? (0, base64_js_1.decodeFromBase64)(record.body) : undefined,
                headers: record.headers?.map((header) => header.map((h) => (0, base64_js_1.decodeFromBase64)(h))),
            })),
        };
        return res;
    }
    else {
        const res = {
            ...response.data,
            records: response.data.records.map((record) => ({
                ...record,
                headers: record.headers
                    ? Object.fromEntries(record.headers)
                    : undefined,
            })),
        };
        return res;
    }
}
async function streamAppend(stream, client, records, args, options) {
    const recordsArray = Array.isArray(records) ? records : [records];
    if (recordsArray.length === 0) {
        throw new error_js_1.S2Error({ message: "Cannot append empty array of records" });
    }
    let batchMeteredSize = 0;
    for (const record of recordsArray) {
        batchMeteredSize += (0, utils_js_1.meteredSizeBytes)(record);
    }
    if (batchMeteredSize > 1024 * 1024) {
        throw new error_js_1.S2Error({
            message: `Batch size ${batchMeteredSize} bytes exceeds maximum of 1 MiB (1048576 bytes)`,
        });
    }
    if (recordsArray.length > 1000) {
        throw new error_js_1.S2Error({
            message: `Batch of ${recordsArray.length} exceeds maximum batch size of 1000 records`,
        });
    }
    let encodedRecords = [];
    let hasAnyBytesRecords = false;
    for (const record of recordsArray) {
        const format = (0, utils_js_1.computeAppendRecordFormat)(record);
        if (format === "bytes") {
            const formattedRecord = record;
            const encodedRecord = {
                ...formattedRecord,
                body: formattedRecord.body
                    ? (0, base64_js_1.encodeToBase64)(formattedRecord.body)
                    : undefined,
                headers: formattedRecord.headers?.map((header) => header.map((h) => (0, base64_js_1.encodeToBase64)(h))),
            };
            encodedRecords.push(encodedRecord);
        }
        else {
            // Normalize headers to array format
            const normalizeHeaders = (headers) => {
                if (headers === undefined) {
                    return undefined;
                }
                else if (Array.isArray(headers)) {
                    return headers;
                }
                else {
                    return Object.entries(headers);
                }
            };
            const formattedRecord = record;
            const encodedRecord = {
                ...formattedRecord,
                headers: formattedRecord.headers
                    ? normalizeHeaders(formattedRecord.headers)
                    : undefined,
            };
            encodedRecords.push(encodedRecord);
        }
    }
    const response = await (0, index_js_1.append)({
        client,
        path: {
            stream,
        },
        body: {
            fencing_token: args?.fencing_token,
            match_seq_num: args?.match_seq_num,
            records: encodedRecords,
        },
        headers: {
            ...(hasAnyBytesRecords ? { "s2-format": "base64" } : {}),
        },
        ...options,
    });
    if (response.error) {
        if ("message" in response.error) {
            throw new error_js_1.S2Error({
                message: response.error.message,
                code: response.error.code ?? undefined,
                status: response.response.status,
            });
        }
        else {
            // special case for 412 - append condition failed
            if ("seq_num_mismatch" in response.error) {
                throw new error_js_1.SeqNumMismatchError({
                    message: "Append condition failed: sequence number mismatch",
                    code: "APPEND_CONDITION_FAILED",
                    status: response.response.status,
                    expectedSeqNum: response.error.seq_num_mismatch,
                });
            }
            else if ("fencing_token_mismatch" in response.error) {
                throw new error_js_1.FencingTokenMismatchError({
                    message: "Append condition failed: fencing token mismatch",
                    code: "APPEND_CONDITION_FAILED",
                    status: response.response.status,
                    expectedFencingToken: response.error.fencing_token_mismatch,
                });
            }
            else {
                // fallback for unknown 412 error format
                throw new error_js_1.S2Error({
                    message: "Append condition failed",
                    status: response.response.status,
                });
            }
        }
    }
    return response.data;
}
//# sourceMappingURL=shared.js.map