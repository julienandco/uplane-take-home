import type { S2RequestOptions } from "../../../../common.js";
import { type Client } from "../../../../generated/client/index.js";
import type { AppendAck, StreamPosition } from "../../../../generated/index.js";
import { EventStream } from "../../../event-stream.js";
import type { AppendArgs, AppendRecord, AppendSession, AppendSessionOptions, ReadArgs, ReadRecord, ReadSession, SessionTransport, TransportConfig } from "../../types.js";
export declare class FetchReadSession<Format extends "string" | "bytes" = "string"> extends EventStream<ReadRecord<Format>> {
    static create<Format extends "string" | "bytes" = "string">(client: Client, name: string, args?: ReadArgs<Format>, options?: S2RequestOptions): Promise<FetchReadSession<Format>>;
    private _lastReadPosition;
    private constructor();
    lastReadPosition(): StreamPosition | undefined;
}
declare class AcksStream extends ReadableStream<AppendAck> implements AsyncDisposable {
    constructor(setController: (controller: ReadableStreamDefaultController<AppendAck>) => void);
    [Symbol.asyncDispose](): Promise<void>;
    [Symbol.asyncIterator](): AsyncIterableIterator<AppendAck>;
}
/**
 * Session for appending records to a stream.
 * Queues append requests and ensures only one is in-flight at a time.
 */
export declare class FetchAppendSession implements ReadableWritablePair<AppendAck, AppendArgs>, AsyncDisposable {
    private _lastAckedPosition;
    private queue;
    private pendingResolvers;
    private inFlight;
    private readonly options?;
    private readonly stream;
    private acksController;
    private _readable;
    private _writable;
    private closed;
    private processingPromise;
    private queuedBytes;
    private readonly maxQueuedBytes;
    private waitingForCapacity;
    private readonly client;
    readonly readable: ReadableStream<AppendAck>;
    readonly writable: WritableStream<AppendArgs>;
    static create(stream: string, transportConfig: TransportConfig, sessionOptions?: AppendSessionOptions, requestOptions?: S2RequestOptions): Promise<FetchAppendSession>;
    private constructor();
    [Symbol.asyncDispose](): Promise<void>;
    /**
     * Get a stream of acknowledgements for appends.
     */
    acks(): AcksStream;
    /**
     * Close the append session.
     * Waits for all pending appends to complete before resolving.
     */
    close(): Promise<void>;
    /**
     * Submit an append request to the session.
     * The request will be queued and sent when no other request is in-flight.
     * Returns a promise that resolves when the append is acknowledged or rejects on error.
     */
    submit(records: AppendRecord | AppendRecord[], args?: {
        fencing_token?: string;
        match_seq_num?: number;
    }, precalculatedSize?: number): Promise<AppendAck>;
    /**
     * Main processing loop that sends queued requests one at a time.
     */
    private processLoop;
    private waitForDrain;
    lastAckedPosition(): AppendAck | undefined;
}
/**
 * Fetch-based transport using HTTP/1.1 + JSON
 * Works in all JavaScript environments (browser, Node.js, Deno, etc.)
 */
export declare class FetchTransport implements SessionTransport {
    private readonly client;
    private readonly transportConfig;
    constructor(config: TransportConfig);
    makeAppendSession(stream: string, sessionOptions?: AppendSessionOptions, requestOptions?: S2RequestOptions): Promise<AppendSession>;
    makeReadSession<Format extends "string" | "bytes" = "string">(stream: string, args?: ReadArgs<Format>, options?: S2RequestOptions): Promise<ReadSession<Format>>;
}
export {};
//# sourceMappingURL=index.d.ts.map