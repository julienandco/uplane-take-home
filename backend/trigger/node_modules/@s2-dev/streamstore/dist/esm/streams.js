import { S2Error } from "./error.js";
import { createStream, deleteStream, getStreamConfig, listStreams, reconfigureStream, } from "./generated/index.js";
export class S2Streams {
    client;
    constructor(client) {
        this.client = client;
    }
    /**
     * List streams in the basin.
     *
     * @param args.prefix Return streams whose names start with the given prefix
     * @param args.start_after Name to start after (for pagination)
     * @param args.limit Max results (up to 1000)
     */
    async list(args, options) {
        const response = await listStreams({
            client: this.client,
            query: args,
            ...options,
        });
        if (response.error) {
            throw new S2Error({
                message: response.error.message,
                code: response.error.code ?? undefined,
                status: response.response.status,
            });
        }
        return response.data;
    }
    /**
     * Create a stream.
     *
     * @param args.stream Stream name (1-512 bytes, unique within the basin)
     * @param args.config Stream configuration (retention, storage class, timestamping, delete-on-empty)
     */
    async create(args, options) {
        const response = await createStream({
            client: this.client,
            body: args,
            ...options,
        });
        if (response.error) {
            throw new S2Error({
                message: response.error.message,
                code: response.error.code ?? undefined,
                status: response.response.status,
            });
        }
        return response.data;
    }
    /**
     * Get stream configuration.
     *
     * @param args.stream Stream name
     */
    async getConfig(args, options) {
        const response = await getStreamConfig({
            client: this.client,
            path: args,
            ...options,
        });
        if (response.error) {
            throw new S2Error({
                message: response.error.message,
                code: response.error.code ?? undefined,
                status: response.response.status,
            });
        }
        return response.data;
    }
    /**
     * Delete a stream.
     *
     * @param args.stream Stream name
     */
    async delete(args, options) {
        const response = await deleteStream({
            client: this.client,
            path: args,
            ...options,
        });
        if (response.error) {
            throw new S2Error({
                message: response.error.message,
                code: response.error.code ?? undefined,
                status: response.response.status,
            });
        }
        return response.data;
    }
    /**
     * Reconfigure a stream.
     *
     * @param args.stream Stream name
     * @param args.body Configuration fields to change
     */
    async reconfigure(args, options) {
        const response = await reconfigureStream({
            client: this.client,
            path: args,
            body: args,
            ...options,
        });
        if (response.error) {
            throw new S2Error({
                message: response.error.message,
                code: response.error.code ?? undefined,
                status: response.response.status,
            });
        }
        return response.data;
    }
}
//# sourceMappingURL=streams.js.map