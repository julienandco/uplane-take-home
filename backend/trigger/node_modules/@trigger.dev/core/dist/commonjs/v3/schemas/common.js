"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RuntimeEnvironmentTypeSchema = exports.RuntimeEnvironmentType = exports.SerializedError = exports.WaitpointTokenResult = exports.BatchTaskRunExecutionResult = exports.TaskRunExecutionResult = exports.TaskRunSuccessfulExecutionResult = exports.TaskRunFailedExecutionResult = exports.TaskRunExecutionUsage = exports.TaskRunExecutionRetry = exports.V3TaskRunContext = exports.V3TaskRunExecutionEnvironment = exports.TaskRunContext = exports.V3TaskRunExecution = exports.V3TaskRun = exports.V3TaskRunExecutionAttempt = exports.V3TaskRunExecutionTask = exports.TaskRunExecution = exports.StaticTaskRunExecution = exports.TaskRunExecutionDeployment = exports.TaskRunExecutionBatch = exports.TaskRunExecutionQueue = exports.TaskRunExecutionProject = exports.TaskRunExecutionOrganization = exports.TaskRunExecutionEnvironment = exports.TaskRunExecutionAttempt = exports.TaskRunExecutionTask = exports.GitMeta = exports.TaskRun = exports.TaskRunError = exports.TaskRunErrorCodes = exports.TaskRunInternalError = exports.TaskRunStringError = exports.TaskRunCustomErrorObject = exports.TaskRunBuiltInError = exports.MachinePreset = exports.MachineConfig = exports.MachinePresetName = exports.MachineMemory = exports.MachineCpu = exports.FlushedRunMetadata = exports.RunMetadataChangeOperation = exports.RunMetadataIncrementKeyOperation = exports.RunMetadataRemoveFromKeyOperation = exports.RunMetadataAppendKeyOperation = exports.RunMetadataDeleteKeyOperation = exports.RunMetadataSetKeyOperation = exports.RunMetadataUpdateOperation = void 0;
const zod_1 = require("zod");
const json_js_1 = require("../../schemas/json.js");
exports.RunMetadataUpdateOperation = zod_1.z.object({
    type: zod_1.z.literal("update"),
    value: zod_1.z.record(zod_1.z.unknown()),
});
exports.RunMetadataSetKeyOperation = zod_1.z.object({
    type: zod_1.z.literal("set"),
    key: zod_1.z.string(),
    value: json_js_1.DeserializedJsonSchema,
});
exports.RunMetadataDeleteKeyOperation = zod_1.z.object({
    type: zod_1.z.literal("delete"),
    key: zod_1.z.string(),
});
exports.RunMetadataAppendKeyOperation = zod_1.z.object({
    type: zod_1.z.literal("append"),
    key: zod_1.z.string(),
    value: json_js_1.DeserializedJsonSchema,
});
exports.RunMetadataRemoveFromKeyOperation = zod_1.z.object({
    type: zod_1.z.literal("remove"),
    key: zod_1.z.string(),
    value: json_js_1.DeserializedJsonSchema,
});
exports.RunMetadataIncrementKeyOperation = zod_1.z.object({
    type: zod_1.z.literal("increment"),
    key: zod_1.z.string(),
    value: zod_1.z.number(),
});
exports.RunMetadataChangeOperation = zod_1.z.discriminatedUnion("type", [
    exports.RunMetadataUpdateOperation,
    exports.RunMetadataSetKeyOperation,
    exports.RunMetadataDeleteKeyOperation,
    exports.RunMetadataAppendKeyOperation,
    exports.RunMetadataRemoveFromKeyOperation,
    exports.RunMetadataIncrementKeyOperation,
]);
exports.FlushedRunMetadata = zod_1.z.object({
    metadata: zod_1.z.record(json_js_1.DeserializedJsonSchema).optional(),
    operations: zod_1.z.array(exports.RunMetadataChangeOperation).optional(),
    parentOperations: zod_1.z.array(exports.RunMetadataChangeOperation).optional(),
    rootOperations: zod_1.z.array(exports.RunMetadataChangeOperation).optional(),
});
// Defaults to 0.5
exports.MachineCpu = zod_1.z.union([
    zod_1.z.literal(0.25),
    zod_1.z.literal(0.5),
    zod_1.z.literal(1),
    zod_1.z.literal(2),
    zod_1.z.literal(4),
]);
// Defaults to 1
exports.MachineMemory = zod_1.z.union([
    zod_1.z.literal(0.25),
    zod_1.z.literal(0.5),
    zod_1.z.literal(1),
    zod_1.z.literal(2),
    zod_1.z.literal(4),
    zod_1.z.literal(8),
]);
// Default is small-1x
exports.MachinePresetName = zod_1.z.enum([
    "micro",
    "small-1x",
    "small-2x",
    "medium-1x",
    "medium-2x",
    "large-1x",
    "large-2x",
]);
exports.MachineConfig = zod_1.z.object({
    cpu: exports.MachineCpu.optional(),
    memory: exports.MachineMemory.optional(),
    preset: exports.MachinePresetName.optional(),
});
exports.MachinePreset = zod_1.z.object({
    name: exports.MachinePresetName,
    /** unit: vCPU */
    cpu: zod_1.z.number(),
    /** unit: GB */
    memory: zod_1.z.number(),
    centsPerMs: zod_1.z.number(),
});
exports.TaskRunBuiltInError = zod_1.z.object({
    type: zod_1.z.literal("BUILT_IN_ERROR"),
    name: zod_1.z.string(),
    message: zod_1.z.string(),
    stackTrace: zod_1.z.string(),
});
exports.TaskRunCustomErrorObject = zod_1.z.object({
    type: zod_1.z.literal("CUSTOM_ERROR"),
    raw: zod_1.z.string(),
});
exports.TaskRunStringError = zod_1.z.object({
    type: zod_1.z.literal("STRING_ERROR"),
    raw: zod_1.z.string(),
});
exports.TaskRunInternalError = zod_1.z.object({
    type: zod_1.z.literal("INTERNAL_ERROR"),
    code: zod_1.z.enum([
        "COULD_NOT_FIND_EXECUTOR",
        "COULD_NOT_FIND_TASK",
        "COULD_NOT_IMPORT_TASK",
        "CONFIGURED_INCORRECTLY",
        "TASK_ALREADY_RUNNING",
        "TASK_EXECUTION_FAILED",
        "TASK_EXECUTION_ABORTED",
        "TASK_PROCESS_EXITED_WITH_NON_ZERO_CODE",
        "TASK_PROCESS_SIGKILL_TIMEOUT",
        "TASK_PROCESS_SIGSEGV",
        "TASK_PROCESS_SIGTERM",
        "TASK_PROCESS_OOM_KILLED",
        "TASK_PROCESS_MAYBE_OOM_KILLED",
        "TASK_RUN_CANCELLED",
        "TASK_INPUT_ERROR",
        "TASK_OUTPUT_ERROR",
        "TASK_MIDDLEWARE_ERROR",
        "HANDLE_ERROR_ERROR",
        "GRACEFUL_EXIT_TIMEOUT",
        "TASK_RUN_HEARTBEAT_TIMEOUT",
        "TASK_RUN_CRASHED",
        "MAX_DURATION_EXCEEDED",
        "DISK_SPACE_EXCEEDED",
        "POD_EVICTED",
        "POD_UNKNOWN_ERROR",
        "TASK_HAS_N0_EXECUTION_SNAPSHOT",
        "TASK_DEQUEUED_INVALID_STATE",
        "TASK_DEQUEUED_QUEUE_NOT_FOUND",
        "TASK_RUN_DEQUEUED_MAX_RETRIES",
        "TASK_RUN_STALLED_EXECUTING",
        "TASK_RUN_STALLED_EXECUTING_WITH_WAITPOINTS",
        "OUTDATED_SDK_VERSION",
        "TASK_DID_CONCURRENT_WAIT",
        "RECURSIVE_WAIT_DEADLOCK",
    ]),
    message: zod_1.z.string().optional(),
    stackTrace: zod_1.z.string().optional(),
});
exports.TaskRunErrorCodes = exports.TaskRunInternalError.shape.code.enum;
exports.TaskRunError = zod_1.z.discriminatedUnion("type", [
    exports.TaskRunBuiltInError,
    exports.TaskRunCustomErrorObject,
    exports.TaskRunStringError,
    exports.TaskRunInternalError,
]);
exports.TaskRun = zod_1.z.object({
    id: zod_1.z.string(),
    payload: zod_1.z.string(),
    payloadType: zod_1.z.string(),
    tags: zod_1.z.array(zod_1.z.string()),
    isTest: zod_1.z.boolean().default(false),
    createdAt: zod_1.z.coerce.date(),
    startedAt: zod_1.z.coerce.date().default(() => new Date()),
    /** The user-provided idempotency key (not the hash) */
    idempotencyKey: zod_1.z.string().optional(),
    /** The scope of the idempotency key */
    idempotencyKeyScope: zod_1.z.enum(["run", "attempt", "global"]).optional(),
    maxAttempts: zod_1.z.number().optional(),
    version: zod_1.z.string().optional(),
    metadata: zod_1.z.record(json_js_1.DeserializedJsonSchema).optional(),
    maxDuration: zod_1.z.number().optional(),
    /** The priority of the run. Wih a value of 10 it will be dequeued before runs that were triggered 9 seconds before it (assuming they had no priority set).  */
    priority: zod_1.z.number().optional(),
    baseCostInCents: zod_1.z.number().optional(),
    parentTaskRunId: zod_1.z.string().optional(),
    rootTaskRunId: zod_1.z.string().optional(),
    // These are only used during execution, not in run.ctx
    durationMs: zod_1.z.number().optional(),
    costInCents: zod_1.z.number().optional(),
    region: zod_1.z.string().optional(),
});
// newly added fields need to be optional for backwards compatibility
exports.GitMeta = zod_1.z.object({
    provider: zod_1.z.string().optional(),
    source: zod_1.z.enum(["trigger_github_app", "github_actions", "local"]).optional(),
    ghUsername: zod_1.z.string().optional(),
    ghUserAvatarUrl: zod_1.z.string().optional(),
    commitAuthorName: zod_1.z.string().optional(),
    commitMessage: zod_1.z.string().optional(),
    commitRef: zod_1.z.string().optional(),
    commitSha: zod_1.z.string().optional(),
    dirty: zod_1.z.boolean().optional(),
    remoteUrl: zod_1.z.string().optional(),
    pullRequestNumber: zod_1.z.number().optional(),
    pullRequestTitle: zod_1.z.string().optional(),
    pullRequestState: zod_1.z.enum(["open", "closed", "merged"]).optional(),
});
exports.TaskRunExecutionTask = zod_1.z.object({
    id: zod_1.z.string(),
    filePath: zod_1.z.string(),
});
exports.TaskRunExecutionAttempt = zod_1.z.object({
    number: zod_1.z.number(),
    startedAt: zod_1.z.coerce.date(),
});
exports.TaskRunExecutionEnvironment = zod_1.z.object({
    id: zod_1.z.string(),
    slug: zod_1.z.string(),
    type: zod_1.z.enum(["PRODUCTION", "STAGING", "DEVELOPMENT", "PREVIEW"]),
    branchName: zod_1.z.string().optional(),
    git: exports.GitMeta.optional(),
});
exports.TaskRunExecutionOrganization = zod_1.z.object({
    id: zod_1.z.string(),
    slug: zod_1.z.string(),
    name: zod_1.z.string(),
});
exports.TaskRunExecutionProject = zod_1.z.object({
    id: zod_1.z.string(),
    ref: zod_1.z.string(),
    slug: zod_1.z.string(),
    name: zod_1.z.string(),
});
exports.TaskRunExecutionQueue = zod_1.z.object({
    id: zod_1.z.string(),
    name: zod_1.z.string(),
});
exports.TaskRunExecutionBatch = zod_1.z.object({
    id: zod_1.z.string(),
});
exports.TaskRunExecutionDeployment = zod_1.z.object({
    id: zod_1.z.string(),
    shortCode: zod_1.z.string(),
    version: zod_1.z.string(),
    runtime: zod_1.z.string(),
    runtimeVersion: zod_1.z.string(),
    git: exports.GitMeta.optional(),
});
const StaticTaskRunExecutionShape = {
    // Passthrough needed for backwards compatibility
    task: exports.TaskRunExecutionTask.passthrough(),
    queue: exports.TaskRunExecutionQueue,
    environment: exports.TaskRunExecutionEnvironment,
    organization: exports.TaskRunExecutionOrganization,
    project: exports.TaskRunExecutionProject,
    machine: exports.MachinePreset,
    batch: exports.TaskRunExecutionBatch.optional(),
    deployment: exports.TaskRunExecutionDeployment.optional(),
};
exports.StaticTaskRunExecution = zod_1.z.object(StaticTaskRunExecutionShape);
exports.TaskRunExecution = zod_1.z.object({
    // Passthrough needed for backwards compatibility
    attempt: exports.TaskRunExecutionAttempt.passthrough(),
    run: exports.TaskRun.and(zod_1.z.object({
        traceContext: zod_1.z.record(zod_1.z.unknown()).optional(),
        realtimeStreamsVersion: zod_1.z.string().optional(),
    })),
    ...StaticTaskRunExecutionShape,
});
exports.V3TaskRunExecutionTask = zod_1.z.object({
    id: zod_1.z.string(),
    filePath: zod_1.z.string(),
    exportName: zod_1.z.string().optional(),
});
exports.V3TaskRunExecutionAttempt = zod_1.z.object({
    number: zod_1.z.number(),
    startedAt: zod_1.z.coerce.date(),
    id: zod_1.z.string(),
    backgroundWorkerId: zod_1.z.string(),
    backgroundWorkerTaskId: zod_1.z.string(),
    status: zod_1.z.string(),
});
exports.V3TaskRun = zod_1.z.object({
    id: zod_1.z.string(),
    payload: zod_1.z.string(),
    payloadType: zod_1.z.string(),
    tags: zod_1.z.array(zod_1.z.string()),
    isTest: zod_1.z.boolean().default(false),
    createdAt: zod_1.z.coerce.date(),
    startedAt: zod_1.z.coerce.date().default(() => new Date()),
    /** The user-provided idempotency key (not the hash) */
    idempotencyKey: zod_1.z.string().optional(),
    /** The scope of the idempotency key */
    idempotencyKeyScope: zod_1.z.enum(["run", "attempt", "global"]).optional(),
    maxAttempts: zod_1.z.number().optional(),
    version: zod_1.z.string().optional(),
    metadata: zod_1.z.record(json_js_1.DeserializedJsonSchema).optional(),
    maxDuration: zod_1.z.number().optional(),
    context: zod_1.z.unknown(),
    durationMs: zod_1.z.number(),
    costInCents: zod_1.z.number(),
    baseCostInCents: zod_1.z.number(),
});
exports.V3TaskRunExecution = zod_1.z.object({
    task: exports.V3TaskRunExecutionTask,
    attempt: exports.V3TaskRunExecutionAttempt,
    run: exports.V3TaskRun.and(zod_1.z.object({
        traceContext: zod_1.z.record(zod_1.z.unknown()).optional(),
    })),
    queue: exports.TaskRunExecutionQueue,
    environment: exports.TaskRunExecutionEnvironment,
    organization: exports.TaskRunExecutionOrganization,
    project: exports.TaskRunExecutionProject,
    machine: exports.MachinePreset,
    batch: exports.TaskRunExecutionBatch.optional(),
});
exports.TaskRunContext = zod_1.z.object({
    attempt: exports.TaskRunExecutionAttempt,
    run: exports.TaskRun.omit({
        payload: true,
        payloadType: true,
        metadata: true,
        durationMs: true,
        costInCents: true,
    }),
    ...StaticTaskRunExecutionShape,
});
exports.V3TaskRunExecutionEnvironment = zod_1.z.object({
    id: zod_1.z.string(),
    slug: zod_1.z.string(),
    type: zod_1.z.enum(["PRODUCTION", "STAGING", "DEVELOPMENT", "PREVIEW"]),
});
exports.V3TaskRunContext = zod_1.z.object({
    attempt: exports.V3TaskRunExecutionAttempt.omit({
        backgroundWorkerId: true,
        backgroundWorkerTaskId: true,
    }),
    run: exports.V3TaskRun.omit({
        payload: true,
        payloadType: true,
        metadata: true,
    }),
    task: exports.V3TaskRunExecutionTask,
    queue: exports.TaskRunExecutionQueue,
    environment: exports.V3TaskRunExecutionEnvironment,
    organization: exports.TaskRunExecutionOrganization,
    project: exports.TaskRunExecutionProject,
    batch: exports.TaskRunExecutionBatch.optional(),
    machine: exports.MachinePreset.optional(),
});
exports.TaskRunExecutionRetry = zod_1.z.object({
    timestamp: zod_1.z.number(),
    /** Retry delay in milliseconds */
    delay: zod_1.z.number(),
    error: zod_1.z.unknown().optional(),
});
exports.TaskRunExecutionUsage = zod_1.z.object({
    durationMs: zod_1.z.number(),
});
exports.TaskRunFailedExecutionResult = zod_1.z.object({
    ok: zod_1.z.literal(false),
    id: zod_1.z.string(),
    error: exports.TaskRunError,
    retry: exports.TaskRunExecutionRetry.optional(),
    skippedRetrying: zod_1.z.boolean().optional(),
    usage: exports.TaskRunExecutionUsage.optional(),
    // Optional for now for backwards compatibility
    taskIdentifier: zod_1.z.string().optional(),
    // This is deprecated, use flushedMetadata instead
    metadata: exports.FlushedRunMetadata.optional(),
    // This is the new way to flush metadata
    flushedMetadata: zod_1.z
        .object({
        data: zod_1.z.string().optional(),
        dataType: zod_1.z.string(),
    })
        .optional(),
});
exports.TaskRunSuccessfulExecutionResult = zod_1.z.object({
    ok: zod_1.z.literal(true),
    id: zod_1.z.string(),
    output: zod_1.z.string().optional(),
    outputType: zod_1.z.string(),
    usage: exports.TaskRunExecutionUsage.optional(),
    // Optional for now for backwards compatibility
    taskIdentifier: zod_1.z.string().optional(),
    // This is deprecated, use flushedMetadata instead
    metadata: exports.FlushedRunMetadata.optional(),
    // This is the new way to flush metadata
    flushedMetadata: zod_1.z
        .object({
        data: zod_1.z.string().optional(),
        dataType: zod_1.z.string(),
    })
        .optional(),
});
exports.TaskRunExecutionResult = zod_1.z.discriminatedUnion("ok", [
    exports.TaskRunSuccessfulExecutionResult,
    exports.TaskRunFailedExecutionResult,
]);
exports.BatchTaskRunExecutionResult = zod_1.z.object({
    id: zod_1.z.string(),
    items: exports.TaskRunExecutionResult.array(),
});
exports.WaitpointTokenResult = zod_1.z.object({
    ok: zod_1.z.boolean(),
    output: zod_1.z.string().optional(),
    outputType: zod_1.z.string().optional(),
});
exports.SerializedError = zod_1.z.object({
    message: zod_1.z.string(),
    name: zod_1.z.string().optional(),
    stackTrace: zod_1.z.string().optional(),
});
exports.RuntimeEnvironmentType = {
    PRODUCTION: "PRODUCTION",
    STAGING: "STAGING",
    DEVELOPMENT: "DEVELOPMENT",
    PREVIEW: "PREVIEW",
};
exports.RuntimeEnvironmentTypeSchema = zod_1.z.enum(Object.values(exports.RuntimeEnvironmentType));
//# sourceMappingURL=common.js.map