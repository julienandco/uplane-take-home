"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.StandardHeartbeatsManager = void 0;
const tryCatch_js_1 = require("../tryCatch.js");
const promises_1 = require("node:timers/promises");
class StandardHeartbeatsManager {
    intervalInMs;
    listener = undefined;
    currentAbortController = undefined;
    lastHeartbeatYieldTime = undefined;
    lastHeartbeatDate = undefined;
    constructor(intervalInMs) {
        this.intervalInMs = intervalInMs;
    }
    registerListener(callback) {
        this.listener = callback;
    }
    async yield() {
        if (!this.lastHeartbeatYieldTime) {
            return;
        }
        // Only call setImmediate if we haven't yielded in the last interval
        if (Date.now() - this.lastHeartbeatYieldTime >= this.intervalInMs) {
            // await setImmediate();
            await (0, promises_1.setTimeout)(24);
            this.lastHeartbeatYieldTime = Date.now();
        }
    }
    startHeartbeat(id) {
        this.stopHeartbeat();
        this.currentAbortController = new AbortController();
        this.lastHeartbeatYieldTime = Date.now();
        // Ignore errors as we expect them to be thrown when the heartbeat is stopped
        this.startHeartbeatLoop(id, this.currentAbortController.signal).catch((error) => { });
    }
    async startHeartbeatLoop(id, signal) {
        try {
            for await (const _ of (0, promises_1.setInterval)(this.intervalInMs, undefined, {
                signal,
            })) {
                if (this.listener) {
                    const [error] = await (0, tryCatch_js_1.tryCatch)(this.listener(id));
                    this.lastHeartbeatDate = new Date();
                    if (error) {
                        console.error("Failed to send HEARTBEAT message", { error: String(error) });
                    }
                }
            }
        }
        catch (error) {
            // Ignore errors as we expect them to be thrown when the heartbeat is stopped
            // And since we tryCatch inside the loop, we don't need to handle any other errors here
        }
    }
    stopHeartbeat() {
        this.currentAbortController?.abort();
    }
    get lastHeartbeat() {
        return this.lastHeartbeatDate;
    }
    reset() {
        this.stopHeartbeat();
        this.lastHeartbeatDate = undefined;
        this.lastHeartbeatYieldTime = undefined;
        this.currentAbortController = undefined;
        // NOTE: Don't reset the listener, it's really just a single global callback,
        // but because of the structure of the dev/managed-run-worker and the ZodIpc constructor,
        // we have to create the StandardHeartbeatsManager instance before the ZodIpc instance is created.
    }
}
exports.StandardHeartbeatsManager = StandardHeartbeatsManager;
//# sourceMappingURL=manager.js.map