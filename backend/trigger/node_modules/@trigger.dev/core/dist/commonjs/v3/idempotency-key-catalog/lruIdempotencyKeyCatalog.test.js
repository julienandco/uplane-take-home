"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const vitest_1 = require("vitest");
const lruIdempotencyKeyCatalog_js_1 = require("./lruIdempotencyKeyCatalog.js");
(0, vitest_1.describe)("LRUIdempotencyKeyCatalog", () => {
    (0, vitest_1.describe)("registerKeyOptions and getKeyOptions", () => {
        (0, vitest_1.it)("should store and retrieve options", () => {
            const catalog = new lruIdempotencyKeyCatalog_js_1.LRUIdempotencyKeyCatalog();
            const options = { key: "my-key", scope: "global" };
            catalog.registerKeyOptions("hash1", options);
            (0, vitest_1.expect)(catalog.getKeyOptions("hash1")).toEqual(options);
        });
        (0, vitest_1.it)("should return undefined for non-existent keys", () => {
            const catalog = new lruIdempotencyKeyCatalog_js_1.LRUIdempotencyKeyCatalog();
            (0, vitest_1.expect)(catalog.getKeyOptions("non-existent")).toBeUndefined();
        });
        (0, vitest_1.it)("should store multiple keys", () => {
            const catalog = new lruIdempotencyKeyCatalog_js_1.LRUIdempotencyKeyCatalog();
            const options1 = { key: "key1", scope: "global" };
            const options2 = { key: "key2", scope: "run" };
            const options3 = { key: "key3", scope: "attempt" };
            catalog.registerKeyOptions("hash1", options1);
            catalog.registerKeyOptions("hash2", options2);
            catalog.registerKeyOptions("hash3", options3);
            (0, vitest_1.expect)(catalog.getKeyOptions("hash1")).toEqual(options1);
            (0, vitest_1.expect)(catalog.getKeyOptions("hash2")).toEqual(options2);
            (0, vitest_1.expect)(catalog.getKeyOptions("hash3")).toEqual(options3);
        });
        (0, vitest_1.it)("should update options when registering same key twice", () => {
            const catalog = new lruIdempotencyKeyCatalog_js_1.LRUIdempotencyKeyCatalog();
            const options1 = { key: "key1", scope: "global" };
            const options2 = { key: "key1-updated", scope: "run" };
            catalog.registerKeyOptions("hash1", options1);
            catalog.registerKeyOptions("hash1", options2);
            (0, vitest_1.expect)(catalog.getKeyOptions("hash1")).toEqual(options2);
        });
    });
    (0, vitest_1.describe)("LRU eviction", () => {
        (0, vitest_1.it)("should evict oldest entry when over capacity", () => {
            const catalog = new lruIdempotencyKeyCatalog_js_1.LRUIdempotencyKeyCatalog(3);
            catalog.registerKeyOptions("hash1", { key: "key1", scope: "global" });
            catalog.registerKeyOptions("hash2", { key: "key2", scope: "global" });
            catalog.registerKeyOptions("hash3", { key: "key3", scope: "global" });
            // All three should exist
            (0, vitest_1.expect)(catalog.getKeyOptions("hash1")).toBeDefined();
            (0, vitest_1.expect)(catalog.getKeyOptions("hash2")).toBeDefined();
            (0, vitest_1.expect)(catalog.getKeyOptions("hash3")).toBeDefined();
            // After the gets above, the LRU order from oldest to newest is: hash1, hash2, hash3
            // (each get moves the key to the most recent position)
            // Add a fourth - hash1 should be evicted (it was accessed first, so it's the oldest)
            catalog.registerKeyOptions("hash4", { key: "key4", scope: "global" });
            (0, vitest_1.expect)(catalog.getKeyOptions("hash1")).toBeUndefined();
            (0, vitest_1.expect)(catalog.getKeyOptions("hash2")).toBeDefined();
            (0, vitest_1.expect)(catalog.getKeyOptions("hash3")).toBeDefined();
            (0, vitest_1.expect)(catalog.getKeyOptions("hash4")).toBeDefined();
        });
        (0, vitest_1.it)("should evict least recently registered entry when capacity exceeded", () => {
            const catalog = new lruIdempotencyKeyCatalog_js_1.LRUIdempotencyKeyCatalog(3);
            catalog.registerKeyOptions("hash1", { key: "key1", scope: "global" });
            catalog.registerKeyOptions("hash2", { key: "key2", scope: "global" });
            catalog.registerKeyOptions("hash3", { key: "key3", scope: "global" });
            // Adding fourth should evict hash1 (oldest)
            catalog.registerKeyOptions("hash4", { key: "key4", scope: "global" });
            (0, vitest_1.expect)(catalog.getKeyOptions("hash1")).toBeUndefined();
            (0, vitest_1.expect)(catalog.getKeyOptions("hash2")).toBeDefined();
            (0, vitest_1.expect)(catalog.getKeyOptions("hash3")).toBeDefined();
            (0, vitest_1.expect)(catalog.getKeyOptions("hash4")).toBeDefined();
        });
        (0, vitest_1.it)("should evict multiple entries when adding many at once would exceed capacity", () => {
            const catalog = new lruIdempotencyKeyCatalog_js_1.LRUIdempotencyKeyCatalog(2);
            catalog.registerKeyOptions("hash1", { key: "key1", scope: "global" });
            catalog.registerKeyOptions("hash2", { key: "key2", scope: "global" });
            catalog.registerKeyOptions("hash3", { key: "key3", scope: "global" });
            catalog.registerKeyOptions("hash4", { key: "key4", scope: "global" });
            // Only hash3 and hash4 should remain
            (0, vitest_1.expect)(catalog.getKeyOptions("hash1")).toBeUndefined();
            (0, vitest_1.expect)(catalog.getKeyOptions("hash2")).toBeUndefined();
            (0, vitest_1.expect)(catalog.getKeyOptions("hash3")).toBeDefined();
            (0, vitest_1.expect)(catalog.getKeyOptions("hash4")).toBeDefined();
        });
        (0, vitest_1.it)("should work with maxSize of 1", () => {
            const catalog = new lruIdempotencyKeyCatalog_js_1.LRUIdempotencyKeyCatalog(1);
            catalog.registerKeyOptions("hash1", { key: "key1", scope: "global" });
            (0, vitest_1.expect)(catalog.getKeyOptions("hash1")).toBeDefined();
            catalog.registerKeyOptions("hash2", { key: "key2", scope: "global" });
            (0, vitest_1.expect)(catalog.getKeyOptions("hash1")).toBeUndefined();
            (0, vitest_1.expect)(catalog.getKeyOptions("hash2")).toBeDefined();
        });
    });
    (0, vitest_1.describe)("LRU ordering", () => {
        (0, vitest_1.it)("should move accessed key to most recent position", () => {
            const catalog = new lruIdempotencyKeyCatalog_js_1.LRUIdempotencyKeyCatalog(3);
            catalog.registerKeyOptions("hash1", { key: "key1", scope: "global" });
            catalog.registerKeyOptions("hash2", { key: "key2", scope: "global" });
            catalog.registerKeyOptions("hash3", { key: "key3", scope: "global" });
            // Access hash1, moving it to most recent
            catalog.getKeyOptions("hash1");
            // Add hash4 - should evict hash2 (now the oldest)
            catalog.registerKeyOptions("hash4", { key: "key4", scope: "global" });
            (0, vitest_1.expect)(catalog.getKeyOptions("hash1")).toBeDefined();
            (0, vitest_1.expect)(catalog.getKeyOptions("hash2")).toBeUndefined();
            (0, vitest_1.expect)(catalog.getKeyOptions("hash3")).toBeDefined();
            (0, vitest_1.expect)(catalog.getKeyOptions("hash4")).toBeDefined();
        });
        (0, vitest_1.it)("should move re-registered key to most recent position", () => {
            const catalog = new lruIdempotencyKeyCatalog_js_1.LRUIdempotencyKeyCatalog(3);
            catalog.registerKeyOptions("hash1", { key: "key1", scope: "global" });
            catalog.registerKeyOptions("hash2", { key: "key2", scope: "global" });
            catalog.registerKeyOptions("hash3", { key: "key3", scope: "global" });
            // Re-register hash1, moving it to most recent
            catalog.registerKeyOptions("hash1", { key: "key1-updated", scope: "run" });
            // Add hash4 - should evict hash2 (now the oldest)
            catalog.registerKeyOptions("hash4", { key: "key4", scope: "global" });
            (0, vitest_1.expect)(catalog.getKeyOptions("hash1")).toEqual({ key: "key1-updated", scope: "run" });
            (0, vitest_1.expect)(catalog.getKeyOptions("hash2")).toBeUndefined();
            (0, vitest_1.expect)(catalog.getKeyOptions("hash3")).toBeDefined();
            (0, vitest_1.expect)(catalog.getKeyOptions("hash4")).toBeDefined();
        });
        (0, vitest_1.it)("should not affect order when getting non-existent key", () => {
            const catalog = new lruIdempotencyKeyCatalog_js_1.LRUIdempotencyKeyCatalog(2);
            catalog.registerKeyOptions("hash1", { key: "key1", scope: "global" });
            catalog.registerKeyOptions("hash2", { key: "key2", scope: "global" });
            // Try to get non-existent key
            catalog.getKeyOptions("non-existent");
            // Add hash3 - should still evict hash1 (oldest)
            catalog.registerKeyOptions("hash3", { key: "key3", scope: "global" });
            (0, vitest_1.expect)(catalog.getKeyOptions("hash1")).toBeUndefined();
            (0, vitest_1.expect)(catalog.getKeyOptions("hash2")).toBeDefined();
            (0, vitest_1.expect)(catalog.getKeyOptions("hash3")).toBeDefined();
        });
    });
    (0, vitest_1.describe)("default maxSize", () => {
        (0, vitest_1.it)("should use default maxSize of 1000", () => {
            const catalog = new lruIdempotencyKeyCatalog_js_1.LRUIdempotencyKeyCatalog();
            // Register 1001 entries
            for (let i = 0; i < 1001; i++) {
                catalog.registerKeyOptions(`hash${i}`, { key: `key${i}`, scope: "global" });
            }
            // First entry should be evicted
            (0, vitest_1.expect)(catalog.getKeyOptions("hash0")).toBeUndefined();
            // Last entry should exist
            (0, vitest_1.expect)(catalog.getKeyOptions("hash1000")).toBeDefined();
        });
    });
    (0, vitest_1.describe)("edge cases", () => {
        (0, vitest_1.it)("should handle negative maxSize by clamping to 0", () => {
            const catalog = new lruIdempotencyKeyCatalog_js_1.LRUIdempotencyKeyCatalog(-5);
            // With maxSize clamped to 0, nothing should be stored
            catalog.registerKeyOptions("hash1", { key: "key1", scope: "global" });
            // Should be immediately evicted since maxSize is 0
            (0, vitest_1.expect)(catalog.getKeyOptions("hash1")).toBeUndefined();
        });
        (0, vitest_1.it)("should handle maxSize of 0", () => {
            const catalog = new lruIdempotencyKeyCatalog_js_1.LRUIdempotencyKeyCatalog(0);
            catalog.registerKeyOptions("hash1", { key: "key1", scope: "global" });
            // Should be immediately evicted since maxSize is 0
            (0, vitest_1.expect)(catalog.getKeyOptions("hash1")).toBeUndefined();
        });
    });
});
//# sourceMappingURL=lruIdempotencyKeyCatalog.test.js.map