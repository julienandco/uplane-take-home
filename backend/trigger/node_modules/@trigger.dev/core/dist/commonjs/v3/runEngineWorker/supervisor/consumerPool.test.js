"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const vitest_1 = require("vitest");
const consumerPool_js_1 = require("./consumerPool.js");
// Mock only the logger
vitest_1.vi.mock("../../utils/structuredLogger.js");
// Test implementation of QueueConsumer
class TestQueueConsumer {
    started = false;
    stopped = false;
    onDequeue;
    constructor(opts) {
        this.onDequeue = opts.onDequeue;
    }
    start() {
        this.started = true;
        this.stopped = false;
    }
    stop() {
        this.stopped = true;
        this.started = false;
    }
}
(0, vitest_1.describe)("RunQueueConsumerPool", () => {
    let mockClient;
    let mockOnDequeue;
    let pool;
    let defaultOptions;
    let testConsumers;
    let testConsumerFactory;
    (0, vitest_1.beforeEach)(() => {
        vitest_1.vi.clearAllMocks();
        vitest_1.vi.useFakeTimers();
        mockClient = {};
        mockOnDequeue = vitest_1.vi.fn();
        testConsumers = [];
        testConsumerFactory = (opts) => {
            const consumer = new TestQueueConsumer(opts);
            testConsumers.push(consumer);
            return consumer;
        };
        defaultOptions = {
            consumer: {
                client: mockClient,
                intervalMs: 0,
                idleIntervalMs: 1000,
                onDequeue: mockOnDequeue,
            },
            consumerFactory: testConsumerFactory,
        };
    });
    (0, vitest_1.afterEach)(() => {
        vitest_1.vi.useRealTimers();
        if (pool) {
            pool.stop();
        }
    });
    function advanceTimeAndProcessMetrics(ms) {
        vitest_1.vi.advanceTimersByTime(ms);
        // Trigger batch processing if ready (without adding a sample)
        if (pool["metricsProcessor"].shouldProcessBatch()) {
            pool["processMetricsBatch"]();
        }
    }
    (0, vitest_1.describe)("Static mode (strategy='none')", () => {
        (0, vitest_1.it)("should start with maxConsumerCount in static mode", async () => {
            pool = new consumerPool_js_1.RunQueueConsumerPool({
                ...defaultOptions,
                scaling: { strategy: "none", maxConsumerCount: 5 },
            });
            await pool.start();
            (0, vitest_1.expect)(pool.size).toBe(5);
            (0, vitest_1.expect)(testConsumers.length).toBe(5);
        });
        (0, vitest_1.it)("should not scale in static mode even with queue length updates", async () => {
            pool = new consumerPool_js_1.RunQueueConsumerPool({
                ...defaultOptions,
                scaling: { strategy: "none", maxConsumerCount: 3 },
            });
            await pool.start();
            const initialCount = pool.size;
            pool.updateQueueLength(100);
            vitest_1.vi.advanceTimersByTime(2000);
            (0, vitest_1.expect)(pool.size).toBe(initialCount);
            (0, vitest_1.expect)(pool.size).toBe(3);
        });
    });
    (0, vitest_1.describe)("Smooth scaling strategy", () => {
        (0, vitest_1.it)("should scale smoothly with damping", async () => {
            pool = new consumerPool_js_1.RunQueueConsumerPool({
                ...defaultOptions,
                scaling: {
                    strategy: "smooth",
                    minConsumerCount: 1,
                    maxConsumerCount: 10,
                    scaleUpCooldownMs: 0,
                    disableJitter: true,
                },
            });
            await pool.start();
            (0, vitest_1.expect)(pool.size).toBe(1);
            pool.updateQueueLength(5);
            advanceTimeAndProcessMetrics(1100);
            (0, vitest_1.expect)(pool.size).toBe(4); // Damped scaling
            pool.updateQueueLength(5);
            advanceTimeAndProcessMetrics(1100);
            (0, vitest_1.expect)(pool.size).toBe(5); // Gradually approaches target
        });
        (0, vitest_1.it)("should respect max consumer count", async () => {
            pool = new consumerPool_js_1.RunQueueConsumerPool({
                ...defaultOptions,
                scaling: {
                    strategy: "smooth",
                    minConsumerCount: 1,
                    maxConsumerCount: 5,
                    scaleUpCooldownMs: 0,
                    disableJitter: true,
                },
            });
            await pool.start();
            (0, vitest_1.expect)(pool.size).toBe(1);
            pool.updateQueueLength(100);
            advanceTimeAndProcessMetrics(1100);
            (0, vitest_1.expect)(pool.size).toBe(5);
            pool.updateQueueLength(100);
            advanceTimeAndProcessMetrics(1100);
            (0, vitest_1.expect)(pool.size).toBe(5);
        });
    });
    (0, vitest_1.describe)("Aggressive scaling strategy", () => {
        (0, vitest_1.it)("should scale up quickly based on queue pressure", async () => {
            pool = new consumerPool_js_1.RunQueueConsumerPool({
                ...defaultOptions,
                scaling: {
                    strategy: "aggressive",
                    minConsumerCount: 2,
                    maxConsumerCount: 10,
                    scaleUpCooldownMs: 0,
                    disableJitter: true,
                },
            });
            await pool.start();
            (0, vitest_1.expect)(pool.size).toBe(2);
            pool.updateQueueLength(10);
            advanceTimeAndProcessMetrics(1100);
            (0, vitest_1.expect)(pool.size).toBe(3);
            pool.updateQueueLength(20);
            advanceTimeAndProcessMetrics(1100);
            (0, vitest_1.expect)(pool.size).toBe(4);
        });
        (0, vitest_1.it)("should scale down cautiously when queue is small", async () => {
            pool = new consumerPool_js_1.RunQueueConsumerPool({
                ...defaultOptions,
                scaling: {
                    strategy: "aggressive",
                    minConsumerCount: 1,
                    maxConsumerCount: 10,
                    scaleUpCooldownMs: 0,
                    scaleDownCooldownMs: 0,
                    disableJitter: true,
                },
            });
            await pool.start();
            (0, vitest_1.expect)(pool.size).toBe(1);
            pool.updateQueueLength(10);
            advanceTimeAndProcessMetrics(1100);
            (0, vitest_1.expect)(pool.size).toBe(2);
            pool.updateQueueLength(0.5);
            advanceTimeAndProcessMetrics(1100);
            (0, vitest_1.expect)(pool.size).toBe(3); // EWMA smoothing delays scale down
            pool.updateQueueLength(0.5);
            advanceTimeAndProcessMetrics(1100);
            (0, vitest_1.expect)(pool.size).toBeGreaterThanOrEqual(3); // Stays in optimal zone
        });
        (0, vitest_1.it)("should maintain current level in optimal zone", async () => {
            pool = new consumerPool_js_1.RunQueueConsumerPool({
                ...defaultOptions,
                scaling: {
                    strategy: "aggressive",
                    minConsumerCount: 3,
                    maxConsumerCount: 10,
                    scaleUpCooldownMs: 0,
                    disableJitter: true,
                },
            });
            await pool.start();
            (0, vitest_1.expect)(pool.size).toBe(3);
            pool.updateQueueLength(3);
            advanceTimeAndProcessMetrics(1100);
            (0, vitest_1.expect)(pool.size).toBe(3);
            pool.updateQueueLength(4);
            advanceTimeAndProcessMetrics(1100);
            (0, vitest_1.expect)(pool.size).toBe(3);
        });
    });
    (0, vitest_1.describe)("Smooth scaling with EWMA", () => {
        (0, vitest_1.it)("should use exponential smoothing for stable scaling", async () => {
            pool = new consumerPool_js_1.RunQueueConsumerPool({
                ...defaultOptions,
                scaling: {
                    strategy: "smooth",
                    minConsumerCount: 1,
                    maxConsumerCount: 10,
                    disableJitter: true,
                },
            });
            await pool.start();
            const queueLengths = [10, 2, 8, 3, 9, 1, 7];
            for (const length of queueLengths) {
                pool.updateQueueLength(length);
                vitest_1.vi.advanceTimersByTime(200);
            }
            vitest_1.vi.advanceTimersByTime(900);
            const metrics = pool.getMetrics();
            (0, vitest_1.expect)(metrics.smoothedQueueLength).toBeGreaterThan(0);
            (0, vitest_1.expect)(metrics.smoothedQueueLength).toBeLessThan(10);
        });
        (0, vitest_1.it)("should apply damping factor to avoid rapid changes", async () => {
            pool = new consumerPool_js_1.RunQueueConsumerPool({
                ...defaultOptions,
                scaling: {
                    strategy: "smooth",
                    minConsumerCount: 1,
                    maxConsumerCount: 10,
                    disableJitter: true,
                },
            });
            await pool.start();
            pool.updateQueueLength(2);
            advanceTimeAndProcessMetrics(1100);
            const metrics1 = pool.getMetrics();
            (0, vitest_1.expect)(metrics1.smoothedQueueLength).toBe(2);
            pool.updateQueueLength(20);
            advanceTimeAndProcessMetrics(1100);
            const metrics2 = pool.getMetrics();
            (0, vitest_1.expect)(metrics2.smoothedQueueLength).toBeGreaterThan(2);
            (0, vitest_1.expect)(metrics2.smoothedQueueLength).toBeLessThan(20);
        });
    });
    (0, vitest_1.describe)("High throughput parallel dequeuing", () => {
        (0, vitest_1.it)("should handle rapid parallel queue updates", async () => {
            pool = new consumerPool_js_1.RunQueueConsumerPool({
                ...defaultOptions,
                scaling: {
                    strategy: "aggressive",
                    minConsumerCount: 1,
                    maxConsumerCount: 20,
                    disableJitter: true,
                },
            });
            await pool.start();
            const updates = [];
            for (let i = 0; i < 100; i++) {
                updates.push(Math.floor(Math.random() * 50) + 10);
            }
            updates.forEach((length, index) => {
                setTimeout(() => pool.updateQueueLength(length), index * 10);
            });
            advanceTimeAndProcessMetrics(1100);
            const metrics = pool.getMetrics();
            (0, vitest_1.expect)(metrics.queueLength).toBeDefined();
        });
        (0, vitest_1.it)("should batch metrics updates to avoid excessive scaling", async () => {
            pool = new consumerPool_js_1.RunQueueConsumerPool({
                ...defaultOptions,
                scaling: {
                    strategy: "smooth",
                    minConsumerCount: 1,
                    maxConsumerCount: 10,
                    disableJitter: true,
                },
            });
            await pool.start();
            const evaluateScalingSpy = vitest_1.vi.spyOn(pool, "evaluateScaling");
            pool.updateQueueLength(10);
            for (let i = 1; i < 50; i++) {
                pool.updateQueueLength(Math.floor(Math.random() * 20) + 5);
            }
            (0, vitest_1.expect)(evaluateScalingSpy).not.toHaveBeenCalled();
            advanceTimeAndProcessMetrics(1000);
            (0, vitest_1.expect)(evaluateScalingSpy).toHaveBeenCalledTimes(1);
        });
        (0, vitest_1.it)("should use median to filter outliers in high-frequency updates", async () => {
            pool = new consumerPool_js_1.RunQueueConsumerPool({
                ...defaultOptions,
                scaling: {
                    strategy: "aggressive",
                    minConsumerCount: 1,
                    maxConsumerCount: 10,
                    disableJitter: true,
                },
            });
            await pool.start();
            const updates = [10, 11, 9, 12, 10, 100, 11, 10, 9, 11, 1];
            updates.forEach((length) => pool.updateQueueLength(length));
            advanceTimeAndProcessMetrics(1100);
            const metrics = pool.getMetrics();
            (0, vitest_1.expect)(metrics.queueLength).toBeGreaterThanOrEqual(9);
            (0, vitest_1.expect)(metrics.queueLength).toBeLessThanOrEqual(12);
        });
    });
    (0, vitest_1.describe)("Scaling cooldowns and jitter", () => {
        (0, vitest_1.it)("should respect scale-up cooldown", async () => {
            pool = new consumerPool_js_1.RunQueueConsumerPool({
                ...defaultOptions,
                scaling: {
                    strategy: "smooth",
                    scaleUpCooldownMs: 5000,
                    minConsumerCount: 1,
                    maxConsumerCount: 10,
                    disableJitter: true,
                },
            });
            await pool.start();
            pool["scaleToTarget"](5);
            const scaleToTargetSpy = vitest_1.vi.spyOn(pool, "scaleToTarget");
            pool.updateQueueLength(10);
            advanceTimeAndProcessMetrics(1100);
            (0, vitest_1.expect)(scaleToTargetSpy).not.toHaveBeenCalled();
            vitest_1.vi.advanceTimersByTime(10000);
            pool.updateQueueLength(20);
            advanceTimeAndProcessMetrics(1100);
        });
        (0, vitest_1.it)("should respect scale-down cooldown (longer than scale-up)", async () => {
            pool = new consumerPool_js_1.RunQueueConsumerPool({
                ...defaultOptions,
                scaling: {
                    strategy: "aggressive",
                    minConsumerCount: 1,
                    maxConsumerCount: 10,
                    disableJitter: true,
                },
            });
            await pool.start();
            for (let i = 0; i < 4; i++) {
                pool["addConsumers"](1);
            }
            pool["scaleToTarget"](5);
            pool["metrics"].lastScaleTime = new Date(Date.now() - 70000);
            pool.updateQueueLength(1);
            advanceTimeAndProcessMetrics(1100);
            const metrics = pool.getMetrics();
            (0, vitest_1.expect)(metrics.queueLength).toBe(1);
        });
        (0, vitest_1.it)("should add random jitter to prevent thundering herd", async () => {
            const pools = [];
            const scaleTimes = [];
            for (let i = 0; i < 3; i++) {
                const p = new consumerPool_js_1.RunQueueConsumerPool({
                    ...defaultOptions,
                    scaling: {
                        strategy: "smooth",
                        minConsumerCount: 1,
                        maxConsumerCount: 10,
                        disableJitter: true,
                    },
                });
                const originalScale = p["scaleToTarget"];
                p["scaleToTarget"] = vitest_1.vi.fn(async (target) => {
                    scaleTimes.push(Date.now());
                    return originalScale.call(p, target);
                });
                pools.push(p);
                await p.start();
            }
            pools.forEach((p) => p.updateQueueLength(20));
            advanceTimeAndProcessMetrics(1100);
            vitest_1.vi.advanceTimersByTime(15000);
            await Promise.all(pools.map((p) => p.stop()));
        });
    });
    (0, vitest_1.describe)("Consumer lifecycle management", () => {
        (0, vitest_1.it)("should properly start and stop consumers", async () => {
            pool = new consumerPool_js_1.RunQueueConsumerPool({
                ...defaultOptions,
                scaling: {
                    strategy: "none",
                    maxConsumerCount: 3,
                    disableJitter: true,
                },
            });
            await pool.start();
            (0, vitest_1.expect)(pool.size).toBe(3);
            (0, vitest_1.expect)(testConsumers.length).toBe(3);
            testConsumers.forEach((consumer) => {
                (0, vitest_1.expect)(consumer.started).toBe(true);
            });
            await pool.stop();
            testConsumers.forEach((consumer) => {
                (0, vitest_1.expect)(consumer.stopped).toBe(true);
            });
        });
        (0, vitest_1.it)("should forward dequeue messages with queue length updates", async () => {
            pool = new consumerPool_js_1.RunQueueConsumerPool({
                ...defaultOptions,
                scaling: {
                    strategy: "aggressive",
                    maxConsumerCount: 2,
                    disableJitter: true,
                },
            });
            await pool.start();
            const messages = [{ workerQueueLength: 15 }];
            if (testConsumers[0]?.onDequeue) {
                await testConsumers[0].onDequeue(messages);
            }
            (0, vitest_1.expect)(mockOnDequeue).toHaveBeenCalledWith(messages);
            advanceTimeAndProcessMetrics(1100);
            const metrics = pool.getMetrics();
            (0, vitest_1.expect)(metrics.queueLength).toBe(15);
        });
    });
    (0, vitest_1.describe)("Memory leak prevention", () => {
        (0, vitest_1.it)("should collect all samples within batch window without limit", async () => {
            pool = new consumerPool_js_1.RunQueueConsumerPool({
                ...defaultOptions,
                scaling: {
                    strategy: "aggressive",
                    minConsumerCount: 1,
                    maxConsumerCount: 10,
                    disableJitter: true,
                },
            });
            await pool.start();
            for (let i = 0; i < 100; i++) {
                pool.updateQueueLength(i);
            }
            const metrics = pool.getMetrics();
            (0, vitest_1.expect)(metrics.queueLength).toBeUndefined();
        });
        (0, vitest_1.it)("should clear consumer map on stop", async () => {
            pool = new consumerPool_js_1.RunQueueConsumerPool({
                ...defaultOptions,
                scaling: {
                    strategy: "none",
                    maxConsumerCount: 5,
                    disableJitter: true,
                },
            });
            await pool.start();
            (0, vitest_1.expect)(pool.size).toBe(5);
            await pool.stop();
            (0, vitest_1.expect)(pool.size).toBe(0);
        });
        (0, vitest_1.it)("should clear recentQueueLengths after processing batch", async () => {
            pool = new consumerPool_js_1.RunQueueConsumerPool({
                ...defaultOptions,
                scaling: { strategy: "smooth" },
            });
            await pool.start();
            for (let i = 0; i < 5; i++) {
                pool.updateQueueLength(10 + i);
            }
            advanceTimeAndProcessMetrics(1100);
            const metrics = pool.getMetrics();
            (0, vitest_1.expect)(metrics.queueLength).toBeDefined();
        });
        (0, vitest_1.it)("should not accumulate scaling operations in memory", async () => {
            pool = new consumerPool_js_1.RunQueueConsumerPool({
                ...defaultOptions,
                scaling: {
                    strategy: "aggressive",
                    scaleUpCooldownMs: 100,
                    scaleDownCooldownMs: 100,
                    minConsumerCount: 1,
                    maxConsumerCount: 10,
                    disableJitter: true,
                },
            });
            await pool.start();
            for (let i = 0; i < 5; i++) {
                pool["metrics"].lastScaleTime = new Date(0);
                pool.updateQueueLength(i % 2 === 0 ? 50 : 1);
                vitest_1.vi.advanceTimersByTime(1100);
            }
            (0, vitest_1.expect)(pool.size).toBeGreaterThanOrEqual(1);
            (0, vitest_1.expect)(pool.size).toBeLessThanOrEqual(10);
        });
    });
    (0, vitest_1.describe)("Edge cases", () => {
        (0, vitest_1.it)("should handle empty recent queue lengths", async () => {
            pool = new consumerPool_js_1.RunQueueConsumerPool({
                ...defaultOptions,
                scaling: { strategy: "aggressive" },
            });
            await pool.start();
            const metrics = pool.getMetrics();
            (0, vitest_1.expect)(metrics.queueLength).toBeUndefined();
        });
        (0, vitest_1.it)("should clamp consumer count to min/max bounds", async () => {
            pool = new consumerPool_js_1.RunQueueConsumerPool({
                ...defaultOptions,
                scaling: {
                    strategy: "smooth",
                    minConsumerCount: 2,
                    maxConsumerCount: 5,
                    disableJitter: true,
                },
            });
            await pool.start();
            (0, vitest_1.expect)(pool.size).toBe(2);
            pool.updateQueueLength(100);
            advanceTimeAndProcessMetrics(1100);
            (0, vitest_1.expect)(pool.size).toBeLessThanOrEqual(5);
        });
        (0, vitest_1.it)("should respect custom targetRatio with smooth strategy", async () => {
            pool = new consumerPool_js_1.RunQueueConsumerPool({
                ...defaultOptions,
                scaling: {
                    strategy: "smooth",
                    targetRatio: 5,
                    scaleUpCooldownMs: 0,
                    minConsumerCount: 1,
                    maxConsumerCount: 10,
                    disableJitter: true,
                },
            });
            await pool.start();
            (0, vitest_1.expect)(pool.size).toBe(1);
            pool.updateQueueLength(10);
            advanceTimeAndProcessMetrics(1100);
            const firstSize = pool.size;
            (0, vitest_1.expect)(firstSize).toBeGreaterThanOrEqual(1);
            (0, vitest_1.expect)(firstSize).toBeLessThanOrEqual(2);
            pool.updateQueueLength(10);
            advanceTimeAndProcessMetrics(1100);
            (0, vitest_1.expect)(pool.size).toBeLessThanOrEqual(2);
        });
        (0, vitest_1.it)("should respect custom targetRatio with aggressive strategy", async () => {
            pool = new consumerPool_js_1.RunQueueConsumerPool({
                ...defaultOptions,
                scaling: {
                    strategy: "aggressive",
                    targetRatio: 5,
                    scaleUpCooldownMs: 0,
                    minConsumerCount: 1,
                    maxConsumerCount: 10,
                    disableJitter: true,
                },
            });
            await pool.start();
            (0, vitest_1.expect)(pool.size).toBe(1);
            pool.updateQueueLength(20);
            advanceTimeAndProcessMetrics(1100);
            const sizeAfterFirstScale = pool.size;
            (0, vitest_1.expect)(sizeAfterFirstScale).toBeGreaterThanOrEqual(1);
            pool.updateQueueLength(20);
            advanceTimeAndProcessMetrics(1100);
            (0, vitest_1.expect)(pool.size).toBeLessThanOrEqual(6);
        });
        (0, vitest_1.it)("should scale down when no items are dequeued (zero queue length)", async () => {
            pool = new consumerPool_js_1.RunQueueConsumerPool({
                ...defaultOptions,
                scaling: {
                    strategy: "smooth",
                    minConsumerCount: 1,
                    maxConsumerCount: 10,
                    scaleUpCooldownMs: 0,
                    scaleDownCooldownMs: 0,
                    disableJitter: true,
                },
            });
            await pool.start();
            (0, vitest_1.expect)(pool.size).toBe(1);
            // Scale up first
            pool.updateQueueLength(20);
            advanceTimeAndProcessMetrics(1100);
            (0, vitest_1.expect)(pool.size).toBeGreaterThan(1);
            const sizeAfterScaleUp = pool.size;
            // Now send multiple zero queue lengths to converge EWMA to 0
            // The EWMA needs time to converge due to exponential smoothing
            for (let i = 0; i < 5; i++) {
                pool.updateQueueLength(0);
                advanceTimeAndProcessMetrics(1100);
            }
            // After multiple iterations with zero queue, should scale down but not to minimum yet
            (0, vitest_1.expect)(pool.size).toBeLessThan(sizeAfterScaleUp);
            (0, vitest_1.expect)(pool.size).toBeGreaterThan(1);
            // Continue until we reach minimum
            for (let i = 0; i < 5; i++) {
                pool.updateQueueLength(0);
                advanceTimeAndProcessMetrics(1100);
            }
            // Should eventually reach minimum
            (0, vitest_1.expect)(pool.size).toBe(1);
        });
    });
});
//# sourceMappingURL=consumerPool.test.js.map