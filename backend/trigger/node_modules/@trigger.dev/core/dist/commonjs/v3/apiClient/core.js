"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ZodFetchSSEResult = exports.OffsetLimitPagePromise = exports.CursorPagePromise = exports.ApiPromise = exports.isRequestOptions = exports.defaultRetryOptions = void 0;
exports.zodfetch = zodfetch;
exports.zodfetchCursorPage = zodfetchCursorPage;
exports.zodfetchOffsetLimitPage = zodfetchOffsetLimitPage;
exports.isEmptyObj = isEmptyObj;
exports.hasOwn = hasOwn;
exports.zodfetchSSE = zodfetchSSE;
exports.wrapZodFetch = wrapZodFetch;
const zod_1 = require("zod");
const zod_validation_error_1 = require("zod-validation-error");
const retries_js_1 = require("../utils/retries.js");
const errors_js_1 = require("./errors.js");
const api_1 = require("@opentelemetry/api");
const core_1 = require("@opentelemetry/core");
const semanticInternalAttributes_js_1 = require("../semanticInternalAttributes.js");
const styleAttributes_js_1 = require("../utils/styleAttributes.js");
const pagination_js_1 = require("./pagination.js");
const eventsource_1 = require("eventsource");
const crypto_js_1 = require("../utils/crypto.js");
exports.defaultRetryOptions = {
    maxAttempts: 3,
    factor: 2,
    minTimeoutInMs: 1000,
    maxTimeoutInMs: 60000,
    randomize: false,
};
// This is required so that we can determine if a given object matches the ApiRequestOptions
// type at runtime. While this requires duplication, it is enforced by the TypeScript
// compiler such that any missing / extraneous keys will cause an error.
const requestOptionsKeys = {
    retry: true,
};
const isRequestOptions = (obj) => {
    return (typeof obj === "object" &&
        obj !== null &&
        !isEmptyObj(obj) &&
        Object.keys(obj).every((k) => hasOwn(requestOptionsKeys, k)));
};
exports.isRequestOptions = isRequestOptions;
function zodfetch(schema, url, requestInit, options) {
    return new ApiPromise(_doZodFetch(schema, url, requestInit, options));
}
function zodfetchCursorPage(schema, url, params, requestInit, options) {
    const query = new URLSearchParams(params.query);
    if (params.limit) {
        query.set("page[size]", String(params.limit));
    }
    if (params.after) {
        query.set("page[after]", params.after);
    }
    if (params.before) {
        query.set("page[before]", params.before);
    }
    const cursorPageSchema = zod_1.z.object({
        data: zod_1.z.array(schema),
        pagination: zod_1.z.object({
            next: zod_1.z.string().optional(),
            previous: zod_1.z.string().optional(),
        }),
    });
    const $url = new URL(url);
    $url.search = query.toString();
    const fetchResult = _doZodFetch(cursorPageSchema, $url.href, requestInit, options);
    return new CursorPagePromise(fetchResult, schema, url, params, requestInit, options);
}
function zodfetchOffsetLimitPage(schema, url, params, requestInit, options) {
    const query = new URLSearchParams(params.query);
    if (params.limit) {
        query.set("perPage", String(params.limit));
    }
    if (params.page) {
        query.set("page", String(params.page));
    }
    const offsetLimitPageSchema = zod_1.z.object({
        data: zod_1.z.array(schema),
        pagination: zod_1.z.object({
            currentPage: zod_1.z.coerce.number(),
            totalPages: zod_1.z.coerce.number(),
            count: zod_1.z.coerce.number(),
        }),
    });
    const $url = new URL(url);
    $url.search = query.toString();
    const fetchResult = _doZodFetch(offsetLimitPageSchema, $url.href, requestInit, options);
    return new OffsetLimitPagePromise(fetchResult, schema, url, params, requestInit, options);
}
async function traceZodFetch(params, callback) {
    if (!params.options?.tracer) {
        return callback();
    }
    const url = new URL(params.url);
    const method = params.requestInit?.method ?? "GET";
    const name = params.options.name ?? `${method} ${url.pathname}`;
    return await params.options.tracer.startActiveSpan(name, async (span) => {
        return await callback(span);
    }, {
        attributes: {
            [semanticInternalAttributes_js_1.SemanticInternalAttributes.STYLE_ICON]: params.options?.icon ?? "api",
            ...params.options.attributes,
        },
    });
}
async function _doZodFetch(schema, url, requestInit, options) {
    let $requestInit = await requestInit;
    return traceZodFetch({ url, requestInit: $requestInit, options }, async (span) => {
        const requestIdempotencyKey = await (0, crypto_js_1.randomUUID)();
        $requestInit = injectPropagationHeadersIfInWorker($requestInit);
        $requestInit = injectRequestIdempotencyKey(requestIdempotencyKey, $requestInit);
        const result = await _doZodFetchWithRetries(schema, url, $requestInit, options);
        if (options?.onResponseBody && span) {
            options.onResponseBody(result.data, span);
        }
        if (options?.prepareData) {
            result.data = await options.prepareData(result.data, result.response);
        }
        return result;
    });
}
async function _doZodFetchWithRetries(schema, url, requestInit, options, attempt = 1) {
    try {
        const response = await api_1.context.with((0, core_1.suppressTracing)(api_1.context.active()), () => fetch(url, requestInitWithCache(requestInit)));
        const responseHeaders = createResponseHeaders(response.headers);
        if (!response.ok) {
            const retryResult = shouldRetry(response, attempt, options?.retry);
            if (retryResult.retry) {
                await waitForRetry(url, attempt + 1, retryResult.delay, options, requestInit, response);
                return await _doZodFetchWithRetries(schema, url, requestInit, options, attempt + 1);
            }
            else {
                const errText = await response.text().catch((e) => castToError(e).message);
                const errJSON = safeJsonParse(errText);
                const errMessage = errJSON ? undefined : errText;
                throw errors_js_1.ApiError.generate(response.status, errJSON, errMessage, responseHeaders);
            }
        }
        const jsonBody = await safeJsonFromResponse(response);
        const parsedResult = schema.safeParse(jsonBody);
        if (parsedResult.success) {
            return { data: parsedResult.data, response };
        }
        const validationError = (0, zod_validation_error_1.fromZodError)(parsedResult.error);
        throw new errors_js_1.ApiSchemaValidationError({
            status: response.status,
            cause: validationError,
            message: validationError.message,
            rawBody: jsonBody,
            headers: responseHeaders,
        });
    }
    catch (error) {
        if (error instanceof errors_js_1.ApiError) {
            throw error;
        }
        if (error instanceof zod_validation_error_1.ValidationError) {
        }
        if (options?.retry) {
            const retry = { ...exports.defaultRetryOptions, ...options.retry };
            const delay = (0, retries_js_1.calculateNextRetryDelay)(retry, attempt);
            if (delay) {
                await waitForRetry(url, attempt + 1, delay, options, requestInit);
                return await _doZodFetchWithRetries(schema, url, requestInit, options, attempt + 1);
            }
        }
        throw new errors_js_1.ApiConnectionError({ cause: castToError(error) });
    }
}
async function safeJsonFromResponse(response) {
    try {
        return await response.clone().json();
    }
    catch (error) {
        return;
    }
}
function castToError(err) {
    if (err instanceof Error)
        return err;
    return new Error(err);
}
function shouldRetry(response, attempt, retryOptions) {
    function shouldRetryForOptions() {
        const retry = { ...exports.defaultRetryOptions, ...retryOptions };
        const delay = (0, retries_js_1.calculateNextRetryDelay)(retry, attempt);
        if (delay) {
            return { retry: true, delay };
        }
        else {
            return { retry: false };
        }
    }
    // Note this is not a standard header.
    const shouldRetryHeader = response.headers.get("x-should-retry");
    // If the server explicitly says whether or not to retry, obey.
    if (shouldRetryHeader === "true")
        return shouldRetryForOptions();
    if (shouldRetryHeader === "false")
        return { retry: false };
    // Retry on request timeouts.
    if (response.status === 408)
        return shouldRetryForOptions();
    // Retry on lock timeouts.
    if (response.status === 409)
        return shouldRetryForOptions();
    // Retry on rate limits.
    if (response.status === 429) {
        if (attempt >= (typeof retryOptions?.maxAttempts === "number" ? retryOptions?.maxAttempts : 3)) {
            return { retry: false };
        }
        // x-ratelimit-reset is the unix timestamp in milliseconds when the rate limit will reset.
        const resetAtUnixEpochMs = response.headers.get("x-ratelimit-reset");
        if (resetAtUnixEpochMs) {
            const resetAtUnixEpoch = parseInt(resetAtUnixEpochMs, 10);
            const delay = resetAtUnixEpoch - Date.now() + Math.floor(Math.random() * 1000);
            if (delay > 0) {
                return { retry: true, delay };
            }
        }
        return shouldRetryForOptions();
    }
    // Retry internal errors.
    if (response.status >= 500)
        return shouldRetryForOptions();
    return { retry: false };
}
function safeJsonParse(text) {
    try {
        return JSON.parse(text);
    }
    catch (e) {
        return undefined;
    }
}
function createResponseHeaders(headers) {
    return new Proxy(Object.fromEntries(
    // @ts-ignore
    headers.entries()), {
        get(target, name) {
            const key = name.toString();
            return target[key.toLowerCase()] || target[key];
        },
    });
}
function requestInitWithCache(requestInit) {
    try {
        const withCache = {
            ...requestInit,
            cache: "no-cache",
        };
        const _ = new Request("http://localhost", withCache);
        return withCache;
    }
    catch (error) {
        return requestInit ?? {};
    }
}
/**
 * A subclass of `Promise` providing additional helper methods
 * for interacting with the SDK.
 */
class ApiPromise extends Promise {
    responsePromise;
    constructor(responsePromise) {
        super((resolve) => {
            // this is maybe a bit weird but this has to be a no-op to not implicitly
            // parse the response body; instead .then, .catch, .finally are overridden
            // to parse the response
            resolve(null);
        });
        this.responsePromise = responsePromise;
    }
    /**
     * Gets the raw `Response` instance instead of parsing the response
     * data.
     *
     * If you want to parse the response body but still get the `Response`
     * instance, you can use {@link withResponse()}.
     */
    asResponse() {
        return this.responsePromise.then((p) => p.response);
    }
    /**
     * Gets the parsed response data and the raw `Response` instance.
     *
     * If you just want to get the raw `Response` instance without parsing it,
     * you can use {@link asResponse()}.
     */
    async withResponse() {
        const [data, response] = await Promise.all([this.parse(), this.asResponse()]);
        return { data, response };
    }
    parse() {
        return this.responsePromise.then((result) => result.data);
    }
    then(onfulfilled, onrejected) {
        return this.parse().then(onfulfilled, onrejected);
    }
    catch(onrejected) {
        return this.parse().catch(onrejected);
    }
    finally(onfinally) {
        return this.parse().finally(onfinally);
    }
}
exports.ApiPromise = ApiPromise;
class CursorPagePromise extends ApiPromise {
    schema;
    url;
    params;
    requestInit;
    options;
    constructor(result, schema, url, params, requestInit, options) {
        super(result.then((result) => ({
            data: new pagination_js_1.CursorPage(result.data.data, result.data.pagination, this.#fetchPage.bind(this)),
            response: result.response,
        })));
        this.schema = schema;
        this.url = url;
        this.params = params;
        this.requestInit = requestInit;
        this.options = options;
    }
    #fetchPage(params) {
        return zodfetchCursorPage(this.schema, this.url, { ...this.params, ...params }, this.requestInit, this.options);
    }
    /**
     * Allow auto-paginating iteration on an unawaited list call, eg:
     *
     *    for await (const item of client.items.list()) {
     *      console.log(item)
     *    }
     */
    async *[Symbol.asyncIterator]() {
        const page = await this;
        for await (const item of page) {
            yield item;
        }
    }
}
exports.CursorPagePromise = CursorPagePromise;
class OffsetLimitPagePromise extends ApiPromise {
    schema;
    url;
    params;
    requestInit;
    options;
    constructor(result, schema, url, params, requestInit, options) {
        super(result.then((result) => ({
            data: new pagination_js_1.OffsetLimitPage(result.data.data, result.data.pagination, this.#fetchPage.bind(this)),
            response: result.response,
        })));
        this.schema = schema;
        this.url = url;
        this.params = params;
        this.requestInit = requestInit;
        this.options = options;
    }
    #fetchPage(params) {
        return zodfetchOffsetLimitPage(this.schema, this.url, { ...this.params, ...params }, this.requestInit, this.options);
    }
    /**
     * Allow auto-paginating iteration on an unawaited list call, eg:
     *
     *    for await (const item of client.items.list()) {
     *      console.log(item)
     *    }
     */
    async *[Symbol.asyncIterator]() {
        const page = await this;
        for await (const item of page) {
            yield item;
        }
    }
}
exports.OffsetLimitPagePromise = OffsetLimitPagePromise;
async function waitForRetry(url, attempt, delay, options, requestInit, response) {
    if (options?.tracer) {
        const method = requestInit?.method ?? "GET";
        return options.tracer.startActiveSpan(response ? `wait after ${response.status}` : `wait after error`, async (span) => {
            await new Promise((resolve) => setTimeout(resolve, delay));
        }, {
            attributes: {
                [semanticInternalAttributes_js_1.SemanticInternalAttributes.STYLE_ICON]: "wait",
                ...(0, styleAttributes_js_1.accessoryAttributes)({
                    items: [
                        {
                            text: `retrying ${options?.name ?? method.toUpperCase()} in ${delay}ms`,
                            variant: "normal",
                        },
                    ],
                    style: "codepath",
                }),
            },
        });
    }
    await new Promise((resolve) => setTimeout(resolve, delay));
}
// https://stackoverflow.com/a/34491287
function isEmptyObj(obj) {
    if (!obj)
        return true;
    for (const _k in obj)
        return false;
    return true;
}
// https://eslint.org/docs/latest/rules/no-prototype-builtins
function hasOwn(obj, key) {
    return Object.prototype.hasOwnProperty.call(obj, key);
}
// If the requestInit has a header x-trigger-worker = true, then we will do
// propagation.inject(context.active(), headers);
// and return the new requestInit.
function injectPropagationHeadersIfInWorker(requestInit) {
    const headers = new Headers(requestInit?.headers);
    const headersObject = Object.fromEntries(headers.entries());
    api_1.propagation.inject(api_1.context.active(), headersObject);
    return {
        ...requestInit,
        headers: new Headers(headersObject),
    };
}
function injectRequestIdempotencyKey(requestIdempotencyKey, requestInit) {
    const headers = new Headers(requestInit?.headers);
    headers.set("x-trigger-request-idempotency-key", requestIdempotencyKey);
    return {
        ...requestInit,
        headers,
    };
}
class ZodFetchSSEResult {
    options;
    _eventSource;
    constructor(options) {
        this.options = options;
        this._eventSource = new eventsource_1.EventSource(options.url, {
            fetch: (input, init) => {
                return fetch(input, {
                    ...init,
                    ...options.request,
                    headers: {
                        ...options.request?.headers,
                        Accept: "text/event-stream",
                    },
                });
            },
        });
    }
    onConnectionError(handler) {
        this._eventSource.onerror = handler;
    }
    onMessage(type, handler) {
        this._eventSource.addEventListener(type, (event) => {
            const payload = safeJsonParse(event.data);
            if (!payload) {
                return;
            }
            const schema = this.options.messages[type];
            const result = schema.safeParse(payload);
            if (result.success) {
                handler?.(result.data);
            }
            else {
                console.error(result.error);
            }
        });
    }
    stop() {
        this._eventSource.close();
    }
}
exports.ZodFetchSSEResult = ZodFetchSSEResult;
function zodfetchSSE(options) {
    return new ZodFetchSSEResult(options);
}
async function wrapZodFetch(schema, url, requestInit, options) {
    try {
        const response = await zodfetch(schema, url, requestInit, {
            retry: {
                minTimeoutInMs: 500,
                maxTimeoutInMs: 5000,
                maxAttempts: 5,
                factor: 2,
                randomize: false,
            },
            ...options,
        });
        return {
            success: true,
            data: response,
        };
    }
    catch (error) {
        if (error instanceof errors_js_1.ApiError) {
            return {
                success: false,
                error: error.message,
            };
        }
        else if (error instanceof Error) {
            return {
                success: false,
                error: error.message,
            };
        }
        else {
            return {
                success: false,
                error: String(error),
            };
        }
    }
}
//# sourceMappingURL=core.js.map