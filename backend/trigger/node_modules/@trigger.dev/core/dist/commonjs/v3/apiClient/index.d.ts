import { z } from "zod";
import { AddTagsRequestBody, ApiDeploymentListOptions, BatchItemNDJSON, BatchTaskRunExecutionResult, BatchTriggerTaskV3RequestBody, CompleteWaitpointTokenRequestBody, CreateBatchRequestBody, CreateBatchResponse, CreateEnvironmentVariableRequestBody, CreateScheduleOptions, CreateWaitpointTokenRequestBody, CreateWaitpointTokenResponseBody, ListQueueOptions, ListRunResponseItem, ListScheduleOptions, RescheduleRunRequestBody, RetrieveQueueParam, StreamBatchItemsResponse, TaskRunExecutionResult, TriggerTaskRequestBody, UpdateEnvironmentVariableRequestBody, UpdateMetadataRequestBody, UpdateScheduleOptions, WaitForDurationRequestBody, WaitpointTokenItem } from "@trigger.dev/core/v3/schemas";
import { AsyncIterableStream } from "@trigger.dev/core/dist/commonjs/v3/streams/asyncIterableStream.js";
import { AnyRunTypes, TriggerJwtOptions } from "@trigger.dev/core/dist/commonjs/v3/types/tasks.js";
import { Prettify } from "@trigger.dev/core/dist/commonjs/v3/types/utils.js";
import { AnyZodFetchOptions, ApiPromise, ApiRequestOptions, CursorPagePromise, ZodFetchOptions, isRequestOptions } from "@trigger.dev/core/dist/commonjs/v3/apiClient/core.js";
import { AnyRealtimeRun, AnyRunShape, RealtimeRun, RunShape, RunStreamCallback, RunSubscription, SSEStreamSubscription, TaskRunShape, RealtimeRunSkipColumns, type SSEStreamPart } from "@trigger.dev/core/dist/commonjs/v3/apiClient/runStream.js";
import { CreateEnvironmentVariableParams, ImportEnvironmentVariablesParams, ListProjectRunsQueryParams, ListRunsQueryParams, ListWaitpointTokensQueryParams, SubscribeToRunsQueryParams, UpdateEnvironmentVariableParams } from "@trigger.dev/core/dist/commonjs/v3/apiClient/types.js";
import { ApiClientConfiguration } from "@trigger.dev/core/dist/commonjs/v3/apiClientManager-api.js";
export type CreateWaitpointTokenResponse = Prettify<CreateWaitpointTokenResponseBody & {
    publicAccessToken: string;
}>;
export type CreateBatchApiResponse = Prettify<CreateBatchResponse & {
    publicAccessToken: string;
}>;
export type { CreateEnvironmentVariableParams, ImportEnvironmentVariablesParams, SubscribeToRunsQueryParams, UpdateEnvironmentVariableParams, RealtimeRunSkipColumns, };
export type ClientTriggerOptions = {
    spanParentAsLink?: boolean;
};
export type ClientBatchTriggerOptions = ClientTriggerOptions & {
    processingStrategy?: "parallel" | "sequential";
};
export type TriggerRequestOptions = ZodFetchOptions & {
    publicAccessToken?: TriggerJwtOptions;
};
export type TriggerApiRequestOptions = ApiRequestOptions & {
    publicAccessToken?: TriggerJwtOptions;
    clientConfig?: ApiClientConfiguration;
};
export type ApiClientFutureFlags = {
    v2RealtimeStreams?: boolean;
};
export { isRequestOptions, SSEStreamSubscription };
export type { AnyRealtimeRun, AnyRunShape, ApiRequestOptions, RealtimeRun, RunShape, RunStreamCallback, RunSubscription, TaskRunShape, SSEStreamPart, };
export * from "@trigger.dev/core/dist/commonjs/v3/apiClient/getBranch.js";
/**
 * Trigger.dev v3 API client
 */
export declare class ApiClient {
    #private;
    readonly baseUrl: string;
    readonly accessToken: string;
    readonly previewBranch?: string;
    readonly futureFlags: ApiClientFutureFlags;
    private readonly defaultRequestOptions;
    constructor(baseUrl: string, accessToken: string, previewBranch?: string, requestOptions?: ApiRequestOptions, futureFlags?: ApiClientFutureFlags);
    get fetchClient(): typeof fetch;
    getHeaders(): Record<string, string>;
    getRunResult(runId: string, requestOptions?: ZodFetchOptions): Promise<TaskRunExecutionResult | undefined>;
    getBatchResults(batchId: string, requestOptions?: ZodFetchOptions): Promise<BatchTaskRunExecutionResult | undefined>;
    triggerTask(taskId: string, body: TriggerTaskRequestBody, clientOptions?: ClientTriggerOptions, requestOptions?: TriggerRequestOptions): Promise<{
        publicAccessToken: string;
        id: string;
        isCached?: boolean | undefined;
    }>;
    batchTriggerV3(body: BatchTriggerTaskV3RequestBody, clientOptions?: ClientBatchTriggerOptions, requestOptions?: TriggerRequestOptions): Promise<{
        publicAccessToken: string;
        id: string;
        runCount: number;
    }>;
    /**
     * Phase 1 of 2-phase batch API: Create a batch
     *
     * Creates a new batch and returns its ID. For batchTriggerAndWait,
     * the parent run is blocked immediately on batch creation.
     *
     * @param body - The batch creation parameters
     * @param clientOptions - Options for trace context handling
     * @param clientOptions.spanParentAsLink - If true, child runs will have separate trace IDs with a link to parent
     * @param requestOptions - Optional request options
     * @returns The created batch with ID and metadata
     */
    createBatch(body: CreateBatchRequestBody, clientOptions?: ClientTriggerOptions, requestOptions?: TriggerRequestOptions): Promise<{
        publicAccessToken: string;
        id: string;
        isCached: boolean;
        runCount: number;
        idempotencyKey?: string | undefined;
    }>;
    /**
     * Phase 2 of 2-phase batch API: Stream batch items
     *
     * Streams batch items as NDJSON to the server. Each item is enqueued
     * as it arrives. The batch is automatically sealed when the stream completes.
     *
     * Includes automatic retry with exponential backoff. Since items are deduplicated
     * by index on the server, retrying the entire stream is safe.
     *
     * Uses ReadableStream.tee() for retry capability without buffering all items
     * upfront - only items consumed before a failure are buffered for retry.
     *
     * @param batchId - The batch ID from createBatch
     * @param items - Array or async iterable of batch items
     * @param requestOptions - Optional request options
     * @returns Summary of items accepted and deduplicated
     */
    streamBatchItems(batchId: string, items: BatchItemNDJSON[] | AsyncIterable<BatchItemNDJSON>, requestOptions?: ApiRequestOptions): Promise<StreamBatchItemsResponse>;
    createUploadPayloadUrl(filename: string, requestOptions?: ZodFetchOptions): ApiPromise<{
        presignedUrl: string;
    }>;
    getPayloadUrl(filename: string, requestOptions?: ZodFetchOptions): ApiPromise<{
        presignedUrl: string;
    }>;
    retrieveRun(runId: string, requestOptions?: ZodFetchOptions): ApiPromise<{
        status: "PENDING_VERSION" | "QUEUED" | "DEQUEUED" | "EXECUTING" | "WAITING" | "COMPLETED" | "CANCELED" | "FAILED" | "CRASHED" | "SYSTEM_FAILURE" | "DELAYED" | "EXPIRED" | "TIMED_OUT";
        id: string;
        tags: string[];
        isTest: boolean;
        createdAt: Date;
        baseCostInCents: number;
        durationMs: number;
        costInCents: number;
        taskIdentifier: string;
        relatedRuns: {
            root?: {
                status: "PENDING_VERSION" | "QUEUED" | "DEQUEUED" | "EXECUTING" | "WAITING" | "COMPLETED" | "CANCELED" | "FAILED" | "CRASHED" | "SYSTEM_FAILURE" | "DELAYED" | "EXPIRED" | "TIMED_OUT";
                id: string;
                tags: string[];
                isTest: boolean;
                createdAt: Date;
                baseCostInCents: number;
                durationMs: number;
                costInCents: number;
                taskIdentifier: string;
                depth: number;
                triggerFunction: "trigger" | "batchTrigger" | "triggerAndWait" | "batchTriggerAndWait";
                isQueued: boolean;
                isExecuting: boolean;
                isWaiting: boolean;
                isCompleted: boolean;
                isSuccess: boolean;
                isFailed: boolean;
                isCancelled: boolean;
                updatedAt: Date;
                metadata?: Record<string, any> | undefined;
                startedAt?: Date | undefined;
                idempotencyKey?: string | undefined;
                version?: string | undefined;
                ttl?: string | undefined;
                batchId?: string | undefined;
                finishedAt?: Date | undefined;
                delayedUntil?: Date | undefined;
                expiredAt?: Date | undefined;
            } | undefined;
            parent?: {
                status: "PENDING_VERSION" | "QUEUED" | "DEQUEUED" | "EXECUTING" | "WAITING" | "COMPLETED" | "CANCELED" | "FAILED" | "CRASHED" | "SYSTEM_FAILURE" | "DELAYED" | "EXPIRED" | "TIMED_OUT";
                id: string;
                tags: string[];
                isTest: boolean;
                createdAt: Date;
                baseCostInCents: number;
                durationMs: number;
                costInCents: number;
                taskIdentifier: string;
                depth: number;
                triggerFunction: "trigger" | "batchTrigger" | "triggerAndWait" | "batchTriggerAndWait";
                isQueued: boolean;
                isExecuting: boolean;
                isWaiting: boolean;
                isCompleted: boolean;
                isSuccess: boolean;
                isFailed: boolean;
                isCancelled: boolean;
                updatedAt: Date;
                metadata?: Record<string, any> | undefined;
                startedAt?: Date | undefined;
                idempotencyKey?: string | undefined;
                version?: string | undefined;
                ttl?: string | undefined;
                batchId?: string | undefined;
                finishedAt?: Date | undefined;
                delayedUntil?: Date | undefined;
                expiredAt?: Date | undefined;
            } | undefined;
            children?: {
                status: "PENDING_VERSION" | "QUEUED" | "DEQUEUED" | "EXECUTING" | "WAITING" | "COMPLETED" | "CANCELED" | "FAILED" | "CRASHED" | "SYSTEM_FAILURE" | "DELAYED" | "EXPIRED" | "TIMED_OUT";
                id: string;
                tags: string[];
                isTest: boolean;
                createdAt: Date;
                baseCostInCents: number;
                durationMs: number;
                costInCents: number;
                taskIdentifier: string;
                depth: number;
                triggerFunction: "trigger" | "batchTrigger" | "triggerAndWait" | "batchTriggerAndWait";
                isQueued: boolean;
                isExecuting: boolean;
                isWaiting: boolean;
                isCompleted: boolean;
                isSuccess: boolean;
                isFailed: boolean;
                isCancelled: boolean;
                updatedAt: Date;
                metadata?: Record<string, any> | undefined;
                startedAt?: Date | undefined;
                idempotencyKey?: string | undefined;
                version?: string | undefined;
                ttl?: string | undefined;
                batchId?: string | undefined;
                finishedAt?: Date | undefined;
                delayedUntil?: Date | undefined;
                expiredAt?: Date | undefined;
            }[] | undefined;
        };
        depth: number;
        triggerFunction: "trigger" | "batchTrigger" | "triggerAndWait" | "batchTriggerAndWait";
        isQueued: boolean;
        isExecuting: boolean;
        isWaiting: boolean;
        isCompleted: boolean;
        isSuccess: boolean;
        isFailed: boolean;
        isCancelled: boolean;
        updatedAt: Date;
        attemptCount: number;
        payload?: any;
        error?: {
            message: string;
            name?: string | undefined;
            stackTrace?: string | undefined;
        } | undefined;
        metadata?: Record<string, any> | undefined;
        startedAt?: Date | undefined;
        idempotencyKey?: string | undefined;
        version?: string | undefined;
        output?: any;
        ttl?: string | undefined;
        schedule?: {
            id: string;
            generator: {
                type: "CRON";
                description: string;
                expression: string;
            };
            externalId?: string | undefined;
            deduplicationKey?: string | undefined;
        } | undefined;
        payloadPresignedUrl?: string | undefined;
        outputPresignedUrl?: string | undefined;
        batchId?: string | undefined;
        finishedAt?: Date | undefined;
        delayedUntil?: Date | undefined;
        expiredAt?: Date | undefined;
    }>;
    retrieveRunTrace(runId: string, requestOptions?: ZodFetchOptions): ApiPromise<{
        trace: {
            traceId: string;
            rootSpan: {
                id: string;
                data: {
                    message: string;
                    duration: number;
                    isCancelled: boolean;
                    level: string;
                    startTime: Date;
                    isError: boolean;
                    isPartial: boolean;
                    output?: unknown;
                    properties?: Record<string, any> | undefined;
                    taskSlug?: string | undefined;
                    taskPath?: string | undefined;
                    events?: any[] | undefined;
                    workerVersion?: string | undefined;
                    queueName?: string | undefined;
                    machinePreset?: string | undefined;
                };
                runId: string;
                parentId?: string | undefined;
            } & {
                children: Array<import("@trigger.dev/core/dist/commonjs/v3/schemas/api.js").RetrieveRunTraceSpan>;
            };
        };
    }>;
    listRuns(query?: ListRunsQueryParams, requestOptions?: ZodFetchOptions): CursorPagePromise<typeof ListRunResponseItem>;
    listProjectRuns(projectRef: string, query?: ListProjectRunsQueryParams, requestOptions?: ZodFetchOptions): CursorPagePromise<typeof ListRunResponseItem>;
    replayRun(runId: string, requestOptions?: ZodFetchOptions): ApiPromise<{
        id: string;
    }>;
    cancelRun(runId: string, requestOptions?: ZodFetchOptions): ApiPromise<{
        id: string;
    }>;
    resetIdempotencyKey(taskIdentifier: string, idempotencyKey: string, requestOptions?: ZodFetchOptions): ApiPromise<{
        id: string;
    }>;
    rescheduleRun(runId: string, body: RescheduleRunRequestBody, requestOptions?: ZodFetchOptions): ApiPromise<{
        status: "PENDING_VERSION" | "QUEUED" | "DEQUEUED" | "EXECUTING" | "WAITING" | "COMPLETED" | "CANCELED" | "FAILED" | "CRASHED" | "SYSTEM_FAILURE" | "DELAYED" | "EXPIRED" | "TIMED_OUT";
        id: string;
        tags: string[];
        isTest: boolean;
        createdAt: Date;
        baseCostInCents: number;
        durationMs: number;
        costInCents: number;
        taskIdentifier: string;
        relatedRuns: {
            root?: {
                status: "PENDING_VERSION" | "QUEUED" | "DEQUEUED" | "EXECUTING" | "WAITING" | "COMPLETED" | "CANCELED" | "FAILED" | "CRASHED" | "SYSTEM_FAILURE" | "DELAYED" | "EXPIRED" | "TIMED_OUT";
                id: string;
                tags: string[];
                isTest: boolean;
                createdAt: Date;
                baseCostInCents: number;
                durationMs: number;
                costInCents: number;
                taskIdentifier: string;
                depth: number;
                triggerFunction: "trigger" | "batchTrigger" | "triggerAndWait" | "batchTriggerAndWait";
                isQueued: boolean;
                isExecuting: boolean;
                isWaiting: boolean;
                isCompleted: boolean;
                isSuccess: boolean;
                isFailed: boolean;
                isCancelled: boolean;
                updatedAt: Date;
                metadata?: Record<string, any> | undefined;
                startedAt?: Date | undefined;
                idempotencyKey?: string | undefined;
                version?: string | undefined;
                ttl?: string | undefined;
                batchId?: string | undefined;
                finishedAt?: Date | undefined;
                delayedUntil?: Date | undefined;
                expiredAt?: Date | undefined;
            } | undefined;
            parent?: {
                status: "PENDING_VERSION" | "QUEUED" | "DEQUEUED" | "EXECUTING" | "WAITING" | "COMPLETED" | "CANCELED" | "FAILED" | "CRASHED" | "SYSTEM_FAILURE" | "DELAYED" | "EXPIRED" | "TIMED_OUT";
                id: string;
                tags: string[];
                isTest: boolean;
                createdAt: Date;
                baseCostInCents: number;
                durationMs: number;
                costInCents: number;
                taskIdentifier: string;
                depth: number;
                triggerFunction: "trigger" | "batchTrigger" | "triggerAndWait" | "batchTriggerAndWait";
                isQueued: boolean;
                isExecuting: boolean;
                isWaiting: boolean;
                isCompleted: boolean;
                isSuccess: boolean;
                isFailed: boolean;
                isCancelled: boolean;
                updatedAt: Date;
                metadata?: Record<string, any> | undefined;
                startedAt?: Date | undefined;
                idempotencyKey?: string | undefined;
                version?: string | undefined;
                ttl?: string | undefined;
                batchId?: string | undefined;
                finishedAt?: Date | undefined;
                delayedUntil?: Date | undefined;
                expiredAt?: Date | undefined;
            } | undefined;
            children?: {
                status: "PENDING_VERSION" | "QUEUED" | "DEQUEUED" | "EXECUTING" | "WAITING" | "COMPLETED" | "CANCELED" | "FAILED" | "CRASHED" | "SYSTEM_FAILURE" | "DELAYED" | "EXPIRED" | "TIMED_OUT";
                id: string;
                tags: string[];
                isTest: boolean;
                createdAt: Date;
                baseCostInCents: number;
                durationMs: number;
                costInCents: number;
                taskIdentifier: string;
                depth: number;
                triggerFunction: "trigger" | "batchTrigger" | "triggerAndWait" | "batchTriggerAndWait";
                isQueued: boolean;
                isExecuting: boolean;
                isWaiting: boolean;
                isCompleted: boolean;
                isSuccess: boolean;
                isFailed: boolean;
                isCancelled: boolean;
                updatedAt: Date;
                metadata?: Record<string, any> | undefined;
                startedAt?: Date | undefined;
                idempotencyKey?: string | undefined;
                version?: string | undefined;
                ttl?: string | undefined;
                batchId?: string | undefined;
                finishedAt?: Date | undefined;
                delayedUntil?: Date | undefined;
                expiredAt?: Date | undefined;
            }[] | undefined;
        };
        depth: number;
        triggerFunction: "trigger" | "batchTrigger" | "triggerAndWait" | "batchTriggerAndWait";
        isQueued: boolean;
        isExecuting: boolean;
        isWaiting: boolean;
        isCompleted: boolean;
        isSuccess: boolean;
        isFailed: boolean;
        isCancelled: boolean;
        updatedAt: Date;
        attemptCount: number;
        payload?: any;
        error?: {
            message: string;
            name?: string | undefined;
            stackTrace?: string | undefined;
        } | undefined;
        metadata?: Record<string, any> | undefined;
        startedAt?: Date | undefined;
        idempotencyKey?: string | undefined;
        version?: string | undefined;
        output?: any;
        ttl?: string | undefined;
        schedule?: {
            id: string;
            generator: {
                type: "CRON";
                description: string;
                expression: string;
            };
            externalId?: string | undefined;
            deduplicationKey?: string | undefined;
        } | undefined;
        payloadPresignedUrl?: string | undefined;
        outputPresignedUrl?: string | undefined;
        batchId?: string | undefined;
        finishedAt?: Date | undefined;
        delayedUntil?: Date | undefined;
        expiredAt?: Date | undefined;
    }>;
    listRunEvents(runId: string, requestOptions?: ZodFetchOptions): ApiPromise<any>;
    addTags(runId: string, body: AddTagsRequestBody, requestOptions?: ZodFetchOptions): ApiPromise<{
        message: string;
    }>;
    createSchedule(options: CreateScheduleOptions, requestOptions?: ZodFetchOptions): ApiPromise<{
        type: "DECLARATIVE" | "IMPERATIVE";
        id: string;
        task: string;
        timezone: string;
        environments: {
            type: string;
            id: string;
            userName?: string | null | undefined;
        }[];
        generator: {
            type: "CRON";
            description: string;
            expression: string;
        };
        active: boolean;
        externalId?: string | null | undefined;
        deduplicationKey?: string | null | undefined;
        nextRun?: Date | null | undefined;
    }>;
    listSchedules(options?: ListScheduleOptions, requestOptions?: ZodFetchOptions): import("@trigger.dev/core/dist/commonjs/v3/apiClient/core.js").OffsetLimitPagePromise<z.ZodObject<{
        id: z.ZodString;
        type: z.ZodUnion<[z.ZodLiteral<"DECLARATIVE">, z.ZodLiteral<"IMPERATIVE">]>;
        task: z.ZodString;
        active: z.ZodBoolean;
        deduplicationKey: z.ZodOptional<z.ZodNullable<z.ZodString>>;
        externalId: z.ZodOptional<z.ZodNullable<z.ZodString>>;
        generator: z.ZodObject<{
            type: z.ZodLiteral<"CRON">;
            expression: z.ZodString;
            description: z.ZodString;
        }, "strip", z.ZodTypeAny, {
            type: "CRON";
            description: string;
            expression: string;
        }, {
            type: "CRON";
            description: string;
            expression: string;
        }>;
        timezone: z.ZodString;
        nextRun: z.ZodOptional<z.ZodNullable<z.ZodDate>>;
        environments: z.ZodArray<z.ZodObject<{
            id: z.ZodString;
            type: z.ZodString;
            userName: z.ZodOptional<z.ZodNullable<z.ZodString>>;
        }, "strip", z.ZodTypeAny, {
            type: string;
            id: string;
            userName?: string | null | undefined;
        }, {
            type: string;
            id: string;
            userName?: string | null | undefined;
        }>, "many">;
    }, "strip", z.ZodTypeAny, {
        type: "DECLARATIVE" | "IMPERATIVE";
        id: string;
        task: string;
        timezone: string;
        environments: {
            type: string;
            id: string;
            userName?: string | null | undefined;
        }[];
        generator: {
            type: "CRON";
            description: string;
            expression: string;
        };
        active: boolean;
        externalId?: string | null | undefined;
        deduplicationKey?: string | null | undefined;
        nextRun?: Date | null | undefined;
    }, {
        type: "DECLARATIVE" | "IMPERATIVE";
        id: string;
        task: string;
        timezone: string;
        environments: {
            type: string;
            id: string;
            userName?: string | null | undefined;
        }[];
        generator: {
            type: "CRON";
            description: string;
            expression: string;
        };
        active: boolean;
        externalId?: string | null | undefined;
        deduplicationKey?: string | null | undefined;
        nextRun?: Date | null | undefined;
    }>>;
    retrieveSchedule(scheduleId: string, requestOptions?: ZodFetchOptions): ApiPromise<{
        type: "DECLARATIVE" | "IMPERATIVE";
        id: string;
        task: string;
        timezone: string;
        environments: {
            type: string;
            id: string;
            userName?: string | null | undefined;
        }[];
        generator: {
            type: "CRON";
            description: string;
            expression: string;
        };
        active: boolean;
        externalId?: string | null | undefined;
        deduplicationKey?: string | null | undefined;
        nextRun?: Date | null | undefined;
    }>;
    updateSchedule(scheduleId: string, options: UpdateScheduleOptions, requestOptions?: ZodFetchOptions): ApiPromise<{
        type: "DECLARATIVE" | "IMPERATIVE";
        id: string;
        task: string;
        timezone: string;
        environments: {
            type: string;
            id: string;
            userName?: string | null | undefined;
        }[];
        generator: {
            type: "CRON";
            description: string;
            expression: string;
        };
        active: boolean;
        externalId?: string | null | undefined;
        deduplicationKey?: string | null | undefined;
        nextRun?: Date | null | undefined;
    }>;
    deactivateSchedule(scheduleId: string, requestOptions?: ZodFetchOptions): ApiPromise<{
        type: "DECLARATIVE" | "IMPERATIVE";
        id: string;
        task: string;
        timezone: string;
        environments: {
            type: string;
            id: string;
            userName?: string | null | undefined;
        }[];
        generator: {
            type: "CRON";
            description: string;
            expression: string;
        };
        active: boolean;
        externalId?: string | null | undefined;
        deduplicationKey?: string | null | undefined;
        nextRun?: Date | null | undefined;
    }>;
    activateSchedule(scheduleId: string, requestOptions?: ZodFetchOptions): ApiPromise<{
        type: "DECLARATIVE" | "IMPERATIVE";
        id: string;
        task: string;
        timezone: string;
        environments: {
            type: string;
            id: string;
            userName?: string | null | undefined;
        }[];
        generator: {
            type: "CRON";
            description: string;
            expression: string;
        };
        active: boolean;
        externalId?: string | null | undefined;
        deduplicationKey?: string | null | undefined;
        nextRun?: Date | null | undefined;
    }>;
    deleteSchedule(scheduleId: string, requestOptions?: ZodFetchOptions): ApiPromise<{
        id: string;
    }>;
    listEnvVars(projectRef: string, slug: string, requestOptions?: ZodFetchOptions): ApiPromise<{
        value: string;
        name: string;
        isSecret: boolean;
    }[]>;
    importEnvVars(projectRef: string, slug: string, body: ImportEnvironmentVariablesParams, requestOptions?: ZodFetchOptions): ApiPromise<{
        success: boolean;
    }>;
    retrieveEnvVar(projectRef: string, slug: string, key: string, requestOptions?: ZodFetchOptions): ApiPromise<{
        value: string;
        name: string;
        isSecret: boolean;
    }>;
    createEnvVar(projectRef: string, slug: string, body: CreateEnvironmentVariableRequestBody, requestOptions?: ZodFetchOptions): ApiPromise<{
        success: boolean;
    }>;
    updateEnvVar(projectRef: string, slug: string, key: string, body: UpdateEnvironmentVariableRequestBody, requestOptions?: ZodFetchOptions): ApiPromise<{
        success: boolean;
    }>;
    deleteEnvVar(projectRef: string, slug: string, key: string, requestOptions?: ZodFetchOptions): ApiPromise<{
        success: boolean;
    }>;
    updateRunMetadata(runId: string, body: UpdateMetadataRequestBody, requestOptions?: ZodFetchOptions): ApiPromise<{
        metadata: Record<string, import("@trigger.dev/core").DeserializedJson>;
    }>;
    getRunMetadata(runId: string, requestOptions?: ZodFetchOptions): ApiPromise<{
        metadata: Record<string, import("@trigger.dev/core").DeserializedJson>;
    }>;
    createWaitpointToken(options: CreateWaitpointTokenRequestBody, requestOptions?: ZodFetchOptions): ApiPromise<CreateWaitpointTokenResponse>;
    listWaitpointTokens(params?: ListWaitpointTokensQueryParams, requestOptions?: ZodFetchOptions): CursorPagePromise<typeof WaitpointTokenItem>;
    retrieveWaitpointToken(friendlyId: string, requestOptions?: ZodFetchOptions): ApiPromise<{
        status: "WAITING" | "COMPLETED" | "TIMED_OUT";
        url: string;
        id: string;
        tags: string[];
        createdAt: Date;
        idempotencyKey?: string | undefined;
        completedAt?: Date | undefined;
        timeoutAt?: Date | undefined;
        idempotencyKeyExpiresAt?: Date | undefined;
    } & {
        output?: string | undefined;
        outputType?: string | undefined;
        outputIsError?: boolean | undefined;
    }>;
    completeWaitpointToken(friendlyId: string, options: CompleteWaitpointTokenRequestBody, requestOptions?: ZodFetchOptions): ApiPromise<{
        success: true;
    }>;
    waitForWaitpointToken({ runFriendlyId, waitpointFriendlyId, }: {
        runFriendlyId: string;
        waitpointFriendlyId: string;
    }, requestOptions?: ZodFetchOptions): ApiPromise<{
        success: boolean;
    }>;
    waitForDuration(runId: string, body: WaitForDurationRequestBody, requestOptions?: ZodFetchOptions): Promise<{
        waitUntil: Date;
        waitpoint: {
            id: string;
        };
    }>;
    listQueues(options?: ListQueueOptions, requestOptions?: ZodFetchOptions): import("@trigger.dev/core/dist/commonjs/v3/apiClient/core.js").OffsetLimitPagePromise<z.ZodObject<{
        id: z.ZodString;
        name: z.ZodString;
        type: z.ZodEnum<["task", "custom"]>;
        running: z.ZodNumber;
        queued: z.ZodNumber;
        paused: z.ZodBoolean;
        concurrencyLimit: z.ZodNullable<z.ZodNumber>;
        concurrency: z.ZodOptional<z.ZodObject<{
            current: z.ZodNullable<z.ZodNumber>;
            base: z.ZodNullable<z.ZodNumber>;
            override: z.ZodNullable<z.ZodNumber>;
            overriddenAt: z.ZodNullable<z.ZodDate>;
            overriddenBy: z.ZodNullable<z.ZodString>;
        }, "strip", z.ZodTypeAny, {
            base: number | null;
            override: number | null;
            current: number | null;
            overriddenAt: Date | null;
            overriddenBy: string | null;
        }, {
            base: number | null;
            override: number | null;
            current: number | null;
            overriddenAt: Date | null;
            overriddenBy: string | null;
        }>>;
    }, "strip", z.ZodTypeAny, {
        type: "custom" | "task";
        name: string;
        id: string;
        concurrencyLimit: number | null;
        running: number;
        queued: number;
        paused: boolean;
        concurrency?: {
            base: number | null;
            override: number | null;
            current: number | null;
            overriddenAt: Date | null;
            overriddenBy: string | null;
        } | undefined;
    }, {
        type: "custom" | "task";
        name: string;
        id: string;
        concurrencyLimit: number | null;
        running: number;
        queued: number;
        paused: boolean;
        concurrency?: {
            base: number | null;
            override: number | null;
            current: number | null;
            overriddenAt: Date | null;
            overriddenBy: string | null;
        } | undefined;
    }>>;
    retrieveQueue(queue: RetrieveQueueParam, requestOptions?: ZodFetchOptions): ApiPromise<{
        type: "custom" | "task";
        name: string;
        id: string;
        concurrencyLimit: number | null;
        running: number;
        queued: number;
        paused: boolean;
        concurrency?: {
            base: number | null;
            override: number | null;
            current: number | null;
            overriddenAt: Date | null;
            overriddenBy: string | null;
        } | undefined;
    }>;
    pauseQueue(queue: RetrieveQueueParam, action: "pause" | "resume", requestOptions?: ZodFetchOptions): ApiPromise<{
        type: "custom" | "task";
        name: string;
        id: string;
        concurrencyLimit: number | null;
        running: number;
        queued: number;
        paused: boolean;
        concurrency?: {
            base: number | null;
            override: number | null;
            current: number | null;
            overriddenAt: Date | null;
            overriddenBy: string | null;
        } | undefined;
    }>;
    overrideQueueConcurrencyLimit(queue: RetrieveQueueParam, concurrencyLimit: number, requestOptions?: ZodFetchOptions): ApiPromise<{
        type: "custom" | "task";
        name: string;
        id: string;
        concurrencyLimit: number | null;
        running: number;
        queued: number;
        paused: boolean;
        concurrency?: {
            base: number | null;
            override: number | null;
            current: number | null;
            overriddenAt: Date | null;
            overriddenBy: string | null;
        } | undefined;
    }>;
    resetQueueConcurrencyLimit(queue: RetrieveQueueParam, requestOptions?: ZodFetchOptions): ApiPromise<{
        type: "custom" | "task";
        name: string;
        id: string;
        concurrencyLimit: number | null;
        running: number;
        queued: number;
        paused: boolean;
        concurrency?: {
            base: number | null;
            override: number | null;
            current: number | null;
            overriddenAt: Date | null;
            overriddenBy: string | null;
        } | undefined;
    }>;
    subscribeToRun<TRunTypes extends AnyRunTypes>(runId: string, options?: {
        signal?: AbortSignal;
        closeOnComplete?: boolean;
        onFetchError?: (error: Error) => void;
        skipColumns?: string[];
    }): RunSubscription<TRunTypes>;
    subscribeToRunsWithTag<TRunTypes extends AnyRunTypes>(tag: string | string[], filters?: {
        createdAt?: string;
        skipColumns?: string[];
    }, options?: {
        signal?: AbortSignal;
        onFetchError?: (error: Error) => void;
    }): RunSubscription<TRunTypes>;
    subscribeToBatch<TRunTypes extends AnyRunTypes>(batchId: string, options?: {
        signal?: AbortSignal;
        onFetchError?: (error: Error) => void;
        skipColumns?: string[];
    }): RunSubscription<TRunTypes>;
    listDeployments(options?: ApiDeploymentListOptions, requestOptions?: ZodFetchOptions): CursorPagePromise<z.ZodObject<{
        id: z.ZodString;
        createdAt: z.ZodDate;
        shortCode: z.ZodString;
        version: z.ZodString;
        runtime: z.ZodString;
        runtimeVersion: z.ZodString;
        status: z.ZodEnum<["PENDING", "BUILDING", "DEPLOYING", "DEPLOYED", "FAILED", "CANCELED", "TIMED_OUT"]>;
        deployedAt: z.ZodOptional<z.ZodDate>;
        git: z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodAny>>;
        error: z.ZodOptional<z.ZodObject<{
            name: z.ZodString;
            message: z.ZodString;
            stack: z.ZodOptional<z.ZodString>;
            stderr: z.ZodOptional<z.ZodString>;
        }, "strip", z.ZodTypeAny, {
            message: string;
            name: string;
            stack?: string | undefined;
            stderr?: string | undefined;
        }, {
            message: string;
            name: string;
            stack?: string | undefined;
            stderr?: string | undefined;
        }>>;
    }, "strip", z.ZodTypeAny, {
        status: "CANCELED" | "FAILED" | "TIMED_OUT" | "PENDING" | "BUILDING" | "DEPLOYING" | "DEPLOYED";
        id: string;
        createdAt: Date;
        version: string;
        shortCode: string;
        runtime: string;
        runtimeVersion: string;
        error?: {
            message: string;
            name: string;
            stack?: string | undefined;
            stderr?: string | undefined;
        } | undefined;
        git?: Record<string, any> | undefined;
        deployedAt?: Date | undefined;
    }, {
        status: "CANCELED" | "FAILED" | "TIMED_OUT" | "PENDING" | "BUILDING" | "DEPLOYING" | "DEPLOYED";
        id: string;
        createdAt: Date;
        version: string;
        shortCode: string;
        runtime: string;
        runtimeVersion: string;
        error?: {
            message: string;
            name: string;
            stack?: string | undefined;
            stderr?: string | undefined;
        } | undefined;
        git?: Record<string, any> | undefined;
        deployedAt?: Date | undefined;
    }>>;
    fetchStream<T>(runId: string, streamKey: string, options?: {
        signal?: AbortSignal;
        baseUrl?: string;
        timeoutInSeconds?: number;
        onComplete?: () => void;
        onError?: (error: Error) => void;
        lastEventId?: string;
    }): Promise<AsyncIterableStream<T>>;
    createStream(runId: string, target: string, streamId: string, requestOptions?: ZodFetchOptions): Promise<{
        headers: {
            [k: string]: string;
        };
        version: string;
    }>;
    appendToStream<TBody extends BodyInit>(runId: string, target: string, streamId: string, part: TBody, requestOptions?: ZodFetchOptions): Promise<{
        ok: boolean;
        message?: string | undefined;
    }>;
    generateJWTClaims(requestOptions?: ZodFetchOptions): Promise<Record<string, any>>;
    retrieveBatch(batchId: string, requestOptions?: ZodFetchOptions): ApiPromise<{
        status: "COMPLETED" | "PENDING" | "PROCESSING" | "PARTIAL_FAILED" | "ABORTED";
        id: string;
        createdAt: Date;
        updatedAt: Date;
        runs: string[];
        runCount: number;
        processing: {
            errors: {
                error: string;
                taskIdentifier: string;
                index: number;
                errorCode?: string | undefined;
            }[];
            completedAt?: Date | undefined;
        };
        idempotencyKey?: string | undefined;
    }>;
}
export declare function mergeRequestOptions(defaultOptions: AnyZodFetchOptions, options?: ApiRequestOptions): AnyZodFetchOptions;
