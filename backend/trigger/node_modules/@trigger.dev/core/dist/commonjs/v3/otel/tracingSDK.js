"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TracingSDK = void 0;
exports.parseOtelResourceAttributes = parseOtelResourceAttributes;
const api_1 = require("@opentelemetry/api");
const api_logs_1 = require("@opentelemetry/api-logs");
const core_1 = require("@opentelemetry/core");
const exporter_logs_otlp_http_1 = require("@opentelemetry/exporter-logs-otlp-http");
const exporter_trace_otlp_http_1 = require("@opentelemetry/exporter-trace-otlp-http");
const instrumentation_1 = require("@opentelemetry/instrumentation");
const resources_1 = require("@opentelemetry/resources");
const sdk_logs_1 = require("@opentelemetry/sdk-logs");
const sdk_trace_base_1 = require("@opentelemetry/sdk-trace-base");
const sdk_trace_node_1 = require("@opentelemetry/sdk-trace-node");
const semantic_conventions_1 = require("@opentelemetry/semantic-conventions");
const version_js_1 = require("../../version.js");
const limits_js_1 = require("../limits.js");
const semanticInternalAttributes_js_1 = require("../semanticInternalAttributes.js");
const task_context_api_js_1 = require("../task-context-api.js");
const otelProcessors_js_1 = require("../taskContext/otelProcessors.js");
const trace_context_api_js_1 = require("../trace-context-api.js");
const getEnv_js_1 = require("../utils/getEnv.js");
const idGenerator = new sdk_trace_base_1.RandomIdGenerator();
class TracingSDK {
    config;
    _logProvider;
    _spanExporter;
    _traceProvider;
    getLogger;
    getTracer;
    constructor(config) {
        this.config = config;
        setLogLevel(config.diagLogLevel ?? "none");
        const envResourceAttributesSerialized = (0, getEnv_js_1.getEnvVar)("TRIGGER_OTEL_RESOURCE_ATTRIBUTES");
        const envResourceAttributes = envResourceAttributesSerialized
            ? JSON.parse(envResourceAttributesSerialized)
            : {};
        const customEnvResourceAttributes = parseOtelResourceAttributes((0, getEnv_js_1.getEnvVar)("CUSTOM_OTEL_RESOURCE_ATTRIBUTES"));
        const commonResources = (0, resources_1.detectResources)({
            detectors: [resources_1.processDetector],
        })
            .merge((0, resources_1.resourceFromAttributes)({
            [semantic_conventions_1.SemanticResourceAttributes.CLOUD_PROVIDER]: "trigger.dev",
            [semantic_conventions_1.SemanticResourceAttributes.SERVICE_NAME]: (0, getEnv_js_1.getEnvVar)("TRIGGER_OTEL_SERVICE_NAME") ?? "trigger.dev",
            [semanticInternalAttributes_js_1.SemanticInternalAttributes.TRIGGER]: true,
            [semanticInternalAttributes_js_1.SemanticInternalAttributes.CLI_VERSION]: version_js_1.VERSION,
            [semanticInternalAttributes_js_1.SemanticInternalAttributes.SDK_VERSION]: version_js_1.VERSION,
            [semanticInternalAttributes_js_1.SemanticInternalAttributes.SDK_LANGUAGE]: "typescript",
        }))
            .merge((0, resources_1.resourceFromAttributes)(envResourceAttributes))
            .merge((0, resources_1.resourceFromAttributes)(customEnvResourceAttributes))
            .merge((0, resources_1.resourceFromAttributes)(task_context_api_js_1.taskContext.resourceAttributes))
            .merge(config.resource ?? (0, resources_1.resourceFromAttributes)({}));
        const spanExporter = new exporter_trace_otlp_http_1.OTLPTraceExporter({
            url: `${config.url}/v1/traces`,
            timeoutMillis: config.forceFlushTimeoutMillis,
        });
        const spanProcessors = [];
        spanProcessors.push(new otelProcessors_js_1.TaskContextSpanProcessor(version_js_1.VERSION, (0, getEnv_js_1.getEnvVar)("TRIGGER_OTEL_BATCH_PROCESSING_ENABLED") === "1"
            ? new sdk_trace_node_1.BatchSpanProcessor(spanExporter, {
                maxExportBatchSize: parseInt((0, getEnv_js_1.getEnvVar)("TRIGGER_OTEL_SPAN_MAX_EXPORT_BATCH_SIZE") ?? "64"),
                scheduledDelayMillis: parseInt((0, getEnv_js_1.getEnvVar)("TRIGGER_OTEL_SPAN_SCHEDULED_DELAY_MILLIS") ?? "200"),
                exportTimeoutMillis: parseInt((0, getEnv_js_1.getEnvVar)("TRIGGER_OTEL_SPAN_EXPORT_TIMEOUT_MILLIS") ?? "30000"),
                maxQueueSize: parseInt((0, getEnv_js_1.getEnvVar)("TRIGGER_OTEL_SPAN_MAX_QUEUE_SIZE") ?? "512"),
            })
            : new sdk_trace_node_1.SimpleSpanProcessor(spanExporter)));
        const externalTraceId = idGenerator.generateTraceId();
        const externalTraceContext = trace_context_api_js_1.traceContext.getExternalTraceContext();
        for (const exporter of config.exporters ?? []) {
            spanProcessors.push((0, getEnv_js_1.getEnvVar)("TRIGGER_OTEL_BATCH_PROCESSING_ENABLED") === "1"
                ? new sdk_trace_node_1.BatchSpanProcessor(new ExternalSpanExporterWrapper(exporter, externalTraceId, externalTraceContext), {
                    maxExportBatchSize: parseInt((0, getEnv_js_1.getEnvVar)("TRIGGER_OTEL_SPAN_MAX_EXPORT_BATCH_SIZE") ?? "64"),
                    scheduledDelayMillis: parseInt((0, getEnv_js_1.getEnvVar)("TRIGGER_OTEL_SPAN_SCHEDULED_DELAY_MILLIS") ?? "200"),
                    exportTimeoutMillis: parseInt((0, getEnv_js_1.getEnvVar)("TRIGGER_OTEL_SPAN_EXPORT_TIMEOUT_MILLIS") ?? "30000"),
                    maxQueueSize: parseInt((0, getEnv_js_1.getEnvVar)("TRIGGER_OTEL_SPAN_MAX_QUEUE_SIZE") ?? "512"),
                })
                : new sdk_trace_node_1.SimpleSpanProcessor(new ExternalSpanExporterWrapper(exporter, externalTraceId, externalTraceContext)));
        }
        const traceProvider = new sdk_trace_node_1.NodeTracerProvider({
            forceFlushTimeoutMillis: config.forceFlushTimeoutMillis,
            resource: commonResources,
            spanLimits: {
                attributeCountLimit: limits_js_1.OTEL_SPAN_ATTRIBUTE_COUNT_LIMIT,
                attributeValueLengthLimit: limits_js_1.OTEL_SPAN_ATTRIBUTE_VALUE_LENGTH_LIMIT,
                eventCountLimit: limits_js_1.OTEL_SPAN_EVENT_COUNT_LIMIT,
                attributePerEventCountLimit: limits_js_1.OTEL_ATTRIBUTE_PER_EVENT_COUNT_LIMIT,
                linkCountLimit: limits_js_1.OTEL_LINK_COUNT_LIMIT,
                attributePerLinkCountLimit: limits_js_1.OTEL_ATTRIBUTE_PER_LINK_COUNT_LIMIT,
            },
            spanProcessors,
        });
        traceProvider.register();
        (0, instrumentation_1.registerInstrumentations)({
            instrumentations: config.instrumentations ?? [],
            tracerProvider: traceProvider,
        });
        const logExporter = new exporter_logs_otlp_http_1.OTLPLogExporter({
            url: `${config.url}/v1/logs`,
        });
        const logProcessors = [
            new otelProcessors_js_1.TaskContextLogProcessor((0, getEnv_js_1.getEnvVar)("TRIGGER_OTEL_BATCH_PROCESSING_ENABLED") === "1"
                ? new sdk_logs_1.BatchLogRecordProcessor(logExporter, {
                    maxExportBatchSize: parseInt((0, getEnv_js_1.getEnvVar)("TRIGGER_OTEL_LOG_MAX_EXPORT_BATCH_SIZE") ?? "64"),
                    scheduledDelayMillis: parseInt((0, getEnv_js_1.getEnvVar)("TRIGGER_OTEL_LOG_SCHEDULED_DELAY_MILLIS") ?? "200"),
                    exportTimeoutMillis: parseInt((0, getEnv_js_1.getEnvVar)("TRIGGER_OTEL_LOG_EXPORT_TIMEOUT_MILLIS") ?? "30000"),
                    maxQueueSize: parseInt((0, getEnv_js_1.getEnvVar)("TRIGGER_OTEL_LOG_MAX_QUEUE_SIZE") ?? "512"),
                })
                : new sdk_logs_1.SimpleLogRecordProcessor(logExporter)),
        ];
        for (const externalLogExporter of config.logExporters ?? []) {
            logProcessors.push((0, getEnv_js_1.getEnvVar)("TRIGGER_OTEL_BATCH_PROCESSING_ENABLED") === "1"
                ? new sdk_logs_1.BatchLogRecordProcessor(new ExternalLogRecordExporterWrapper(externalLogExporter, externalTraceId, externalTraceContext), {
                    maxExportBatchSize: parseInt((0, getEnv_js_1.getEnvVar)("TRIGGER_OTEL_LOG_MAX_EXPORT_BATCH_SIZE") ?? "64"),
                    scheduledDelayMillis: parseInt((0, getEnv_js_1.getEnvVar)("TRIGGER_OTEL_LOG_SCHEDULED_DELAY_MILLIS") ?? "200"),
                    exportTimeoutMillis: parseInt((0, getEnv_js_1.getEnvVar)("TRIGGER_OTEL_LOG_EXPORT_TIMEOUT_MILLIS") ?? "30000"),
                    maxQueueSize: parseInt((0, getEnv_js_1.getEnvVar)("TRIGGER_OTEL_LOG_MAX_QUEUE_SIZE") ?? "512"),
                })
                : new sdk_logs_1.SimpleLogRecordProcessor(new ExternalLogRecordExporterWrapper(externalLogExporter, externalTraceId, externalTraceContext)));
        }
        // To start a logger, you first need to initialize the Logger provider.
        const loggerProvider = new sdk_logs_1.LoggerProvider({
            resource: commonResources,
            logRecordLimits: {
                attributeCountLimit: limits_js_1.OTEL_LOG_ATTRIBUTE_COUNT_LIMIT,
                attributeValueLengthLimit: limits_js_1.OTEL_LOG_ATTRIBUTE_VALUE_LENGTH_LIMIT,
            },
            processors: logProcessors,
        });
        this._logProvider = loggerProvider;
        this._spanExporter = spanExporter;
        this._traceProvider = traceProvider;
        api_logs_1.logs.setGlobalLoggerProvider(loggerProvider);
        this.getLogger = loggerProvider.getLogger.bind(loggerProvider);
        this.getTracer = traceProvider.getTracer.bind(traceProvider);
    }
    async flush() {
        await Promise.all([this._traceProvider.forceFlush(), this._logProvider.forceFlush()]);
    }
    async shutdown() {
        await Promise.all([this._traceProvider.shutdown(), this._logProvider.shutdown()]);
    }
}
exports.TracingSDK = TracingSDK;
function setLogLevel(level) {
    let diagLogLevel;
    switch (level) {
        case "none":
            diagLogLevel = api_1.DiagLogLevel.NONE;
            break;
        case "error":
            diagLogLevel = api_1.DiagLogLevel.ERROR;
            break;
        case "warn":
            diagLogLevel = api_1.DiagLogLevel.WARN;
            break;
        case "info":
            diagLogLevel = api_1.DiagLogLevel.INFO;
            break;
        case "debug":
            diagLogLevel = api_1.DiagLogLevel.DEBUG;
            break;
        case "verbose":
            diagLogLevel = api_1.DiagLogLevel.VERBOSE;
            break;
        case "all":
            diagLogLevel = api_1.DiagLogLevel.ALL;
            break;
        default:
            diagLogLevel = api_1.DiagLogLevel.NONE;
    }
    api_1.diag.setLogger(new api_1.DiagConsoleLogger(), diagLogLevel);
}
class ExternalSpanExporterWrapper {
    underlyingExporter;
    externalTraceId;
    externalTraceContext;
    _isExternallySampled;
    constructor(underlyingExporter, externalTraceId, externalTraceContext) {
        this.underlyingExporter = underlyingExporter;
        this.externalTraceId = externalTraceId;
        this.externalTraceContext = externalTraceContext;
        this._isExternallySampled = externalTraceContext
            ? isTraceFlagSampled(externalTraceContext.traceFlags)
            : !!externalTraceId;
    }
    transformSpan(span) {
        if (!this._isExternallySampled) {
            return;
        }
        if (isSpanInternalOnly(span)) {
            return;
        }
        const externalTraceId = this.externalTraceContext
            ? this.externalTraceContext.traceId
            : this.externalTraceId;
        const isAttemptSpan = span.attributes[semanticInternalAttributes_js_1.SemanticInternalAttributes.SPAN_ATTEMPT];
        const spanContext = span.spanContext();
        let parentSpanContext = span.parentSpanContext;
        if (parentSpanContext) {
            parentSpanContext = {
                ...parentSpanContext,
                traceId: externalTraceId,
            };
        }
        if (isAttemptSpan && this.externalTraceContext) {
            parentSpanContext = {
                ...parentSpanContext,
                traceId: externalTraceId,
                spanId: this.externalTraceContext.spanId,
                traceState: this.externalTraceContext.tracestate
                    ? new core_1.TraceState(this.externalTraceContext.tracestate)
                    : undefined,
                traceFlags: this.externalTraceContext.traceFlags,
            };
        }
        else if (isAttemptSpan) {
            parentSpanContext = undefined;
        }
        return {
            ...span,
            spanContext: () => ({ ...spanContext, traceId: externalTraceId }),
            parentSpanContext,
        };
    }
    export(spans, resultCallback) {
        try {
            const modifiedSpans = spans.map(this.transformSpan.bind(this));
            this.underlyingExporter.export(modifiedSpans.filter(Boolean), resultCallback);
        }
        catch (e) {
            console.error(e);
        }
    }
    shutdown() {
        return this.underlyingExporter.shutdown();
    }
    forceFlush() {
        return this.underlyingExporter.forceFlush
            ? this.underlyingExporter.forceFlush()
            : Promise.resolve();
    }
}
class ExternalLogRecordExporterWrapper {
    underlyingExporter;
    externalTraceId;
    externalTraceContext;
    _isExternallySampled;
    constructor(underlyingExporter, externalTraceId, externalTraceContext) {
        this.underlyingExporter = underlyingExporter;
        this.externalTraceId = externalTraceId;
        this.externalTraceContext = externalTraceContext;
        this._isExternallySampled = externalTraceContext
            ? isTraceFlagSampled(externalTraceContext.traceFlags)
            : !!externalTraceId;
    }
    export(logs, resultCallback) {
        if (!this._isExternallySampled) {
            this.underlyingExporter.export([], resultCallback);
            return;
        }
        const modifiedLogs = logs.map(this.transformLogRecord.bind(this));
        this.underlyingExporter.export(modifiedLogs, resultCallback);
    }
    shutdown() {
        return this.underlyingExporter.shutdown();
    }
    transformLogRecord(logRecord) {
        // Capture externalTraceId for use within the proxy's scope.
        // Use externalTraceContext.traceId if available, otherwise fall back to generated externalTraceId
        const externalTraceId = this.externalTraceContext
            ? this.externalTraceContext.traceId
            : this.externalTraceId;
        // If there's no spanContext, or if the externalTraceId is not set, return the original logRecord.
        if (!logRecord.spanContext || !externalTraceId) {
            return logRecord;
        }
        return new Proxy(logRecord, {
            get(target, prop, receiver) {
                if (prop === "spanContext") {
                    // Intercept access to spanContext.
                    const originalSpanContext = target.spanContext;
                    // Ensure originalSpanContext exists (it should, due to the check above, but good for safety).
                    if (originalSpanContext) {
                        return {
                            ...originalSpanContext,
                            traceId: externalTraceId, // Override traceId.
                        };
                    }
                    // Fallback if, for some reason, originalSpanContext is undefined here.
                    return undefined;
                }
                // For all other properties, defer to the original object.
                return Reflect.get(target, prop, receiver);
            },
        });
    }
}
function isSpanInternalOnly(span) {
    if (span.attributes[semanticInternalAttributes_js_1.SemanticInternalAttributes.SPAN_PARTIAL]) {
        // Skip partial spans
        return true;
    }
    const urlPath = span.attributes["url.path"];
    if (typeof urlPath === "string" && urlPath === "/api/v1/usage/ingest") {
        return true;
    }
    const httpUrl = span.attributes[semantic_conventions_1.SEMATTRS_HTTP_URL] ?? span.attributes["url.full"];
    const url = safeParseUrl(httpUrl);
    if (!url) {
        return false;
    }
    const internalHosts = [
        "api.trigger.dev",
        "billing.trigger.dev",
        "cloud.trigger.dev",
        "engine.trigger.dev",
        "platform.trigger.dev",
    ];
    return (internalHosts.some((host) => url.hostname.includes(host)) ||
        url.pathname.includes("/api/v1/usage/ingest"));
}
function safeParseUrl(url) {
    if (typeof url !== "string") {
        return undefined;
    }
    try {
        return new URL(url);
    }
    catch (e) {
        return undefined;
    }
}
function isTraceFlagSampled(traceFlags) {
    if (typeof traceFlags !== "number") {
        return true;
    }
    return (traceFlags & api_1.TraceFlags.SAMPLED) === api_1.TraceFlags.SAMPLED;
}
function isPrintableAscii(str) {
    // printable ASCII: 0x20 (space) .. 0x7E (~)
    for (let i = 0; i < str.length; i++) {
        const code = str.charCodeAt(i);
        if (code < 0x20 || code > 0x7e)
            return false;
    }
    return true;
}
function isValid(name) {
    if (!name)
        return false;
    return typeof name === "string" && name.length <= 255 && isPrintableAscii(name);
}
function isValidAndNotEmpty(name) {
    if (!name)
        return false;
    return isValid(name) && name.length > 0;
}
function parseOtelResourceAttributes(rawEnvAttributes) {
    if (!rawEnvAttributes)
        return {};
    const COMMA = ",";
    const KV = "=";
    const attributes = {};
    // use negative limit to support trailing empty attribute
    const rawAttributes = rawEnvAttributes.split(COMMA, -1);
    for (const rawAttribute of rawAttributes) {
        const keyValuePair = rawAttribute.split(KV, -1);
        if (keyValuePair.length !== 2) {
            // skip invalid pair
            continue;
        }
        let [key, value] = keyValuePair;
        key = key?.trim();
        // trim and remove surrounding double quotes
        value = value?.trim().replace(/^"|"$/g, "");
        if (!value || !key) {
            continue;
        }
        if (!isValidAndNotEmpty(key)) {
            throw new Error(`Attribute key should be a ASCII string with a length greater than 0 and not exceed 255 characters.`);
        }
        if (!isValid(value)) {
            throw new Error(`Attribute value should be a ASCII string with a length not exceed 255 characters.`);
        }
        // decode percent-encoding (deployment%20name -> deployment name)
        try {
            attributes[key] = decodeURIComponent(value);
        }
        catch (e) {
            // decodeURIComponent can throw for malformed sequences; rethrow or handle
            if (e instanceof Error) {
                throw new Error(`Failed to decode attribute value for key ${key}: ${e.message}`);
            }
            throw new Error(`Failed to decode attribute value for key ${key}`);
        }
    }
    return attributes;
}
//# sourceMappingURL=tracingSDK.js.map