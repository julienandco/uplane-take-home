// Create a logger class that uses the debug package internally
/**
 * Represents different log levels.
 * - `"log"`: Only essential messages.
 * - `"error"`: Errors and essential messages.
 * - `"warn"`: Warnings, Errors and essential messages.
 * - `"info"`: Info, Warnings, Errors and essential messages.
 * - `"debug"`: Everything.
 */
import { env } from "node:process";
import { Buffer } from "node:buffer";
import { trace, context } from "@opentelemetry/api";
const logLevels = ["log", "error", "warn", "info", "debug", "verbose"];
export class Logger {
    #name;
    #level;
    #filteredKeys = [];
    #jsonReplacer;
    #additionalFields;
    // Add a static "onError" method that will be called when an error is logged
    static onError;
    constructor(name, level = "info", filteredKeys = [], jsonReplacer, additionalFields) {
        this.#name = name;
        this.#level = logLevels.indexOf((env.TRIGGER_LOG_LEVEL ?? level));
        this.#filteredKeys = filteredKeys;
        this.#jsonReplacer = createReplacer(jsonReplacer);
        this.#additionalFields = additionalFields ?? (() => ({}));
    }
    child(fields) {
        return new Logger(this.#name, logLevels[this.#level], this.#filteredKeys, this.#jsonReplacer, () => ({ ...this.#additionalFields(), ...fields }));
    }
    // Return a new Logger instance with the same name and a new log level
    // but filter out the keys from the log messages (at any level)
    filter(...keys) {
        return new Logger(this.#name, logLevels[this.#level], keys, this.#jsonReplacer);
    }
    static satisfiesLogLevel(logLevel, setLevel) {
        return logLevels.indexOf(logLevel) <= logLevels.indexOf(setLevel);
    }
    log(message, ...args) {
        if (this.#level < 0)
            return;
        this.#structuredLog(console.log, message, "log", ...args);
    }
    error(message, ...args) {
        if (this.#level < 1)
            return;
        this.#structuredLog(console.error, message, "error", ...args);
        const ignoreError = args.some((arg) => arg?.ignoreError);
        if (Logger.onError && !ignoreError) {
            Logger.onError(message, ...args);
        }
    }
    warn(message, ...args) {
        if (this.#level < 2)
            return;
        this.#structuredLog(console.warn, message, "warn", ...args);
    }
    info(message, ...args) {
        if (this.#level < 3)
            return;
        this.#structuredLog(console.info, message, "info", ...args);
    }
    debug(message, ...args) {
        if (this.#level < 4)
            return;
        this.#structuredLog(console.debug, message, "debug", ...args);
    }
    verbose(message, ...args) {
        if (this.#level < 5)
            return;
        this.#structuredLog(console.log, message, "verbose", ...args);
    }
    #structuredLog(loggerFunction, message, level, ...args) {
        // Get the current context from trace if it exists
        const currentSpan = trace.getSpan(context.active());
        const structuredError = extractStructuredErrorFromArgs(...args);
        const structuredMessage = extractStructuredMessageFromArgs(...args);
        const structuredLog = {
            ...structureArgs(safeJsonClone(args), this.#filteredKeys),
            ...this.#additionalFields(),
            ...(structuredError ? { error: structuredError } : {}),
            timestamp: new Date(),
            name: this.#name,
            message,
            ...(structuredMessage ? { $message: structuredMessage } : {}),
            level,
            traceId: currentSpan && currentSpan.isRecording() ? currentSpan?.spanContext().traceId : undefined,
            parentSpanId: currentSpan && currentSpan.isRecording() ? currentSpan?.spanContext().spanId : undefined,
        };
        // If the span is not recording, and it's a debug log, mark it so we can filter it out when we forward it
        if (currentSpan && !currentSpan.isRecording() && level === "debug") {
            structuredLog.skipForwarding = true;
        }
        loggerFunction(JSON.stringify(structuredLog, this.#jsonReplacer));
    }
}
// Detect if args is an error object
// Or if args contains an error object at the "error" key
// In both cases, return the error object as a structured error
function extractStructuredErrorFromArgs(...args) {
    const error = args.find((arg) => arg instanceof Error);
    if (error) {
        return {
            message: error.message,
            stack: error.stack,
            name: error.name,
            metadata: "metadata" in error ? error.metadata : undefined,
        };
    }
    const structuredError = args.find((arg) => arg?.error);
    if (structuredError && structuredError.error instanceof Error) {
        return {
            message: structuredError.error.message,
            stack: structuredError.error.stack,
            name: structuredError.error.name,
            metadata: "metadata" in structuredError.error ? structuredError.error.metadata : undefined,
        };
    }
    return;
}
function extractStructuredMessageFromArgs(...args) {
    // Check to see if there is a `message` key in the args, and if so, return it
    const structuredMessage = args.find((arg) => arg?.message);
    if (structuredMessage) {
        return structuredMessage.message;
    }
    return;
}
function createReplacer(replacer) {
    return (key, value) => {
        if (typeof value === "bigint") {
            return value.toString();
        }
        if (replacer) {
            return replacer(key, value);
        }
        return value;
    };
}
// Replacer function for JSON.stringify that converts BigInts to strings
function bigIntReplacer(_key, value) {
    if (typeof value === "bigint") {
        return value.toString();
    }
    return value;
}
function safeJsonClone(obj) {
    try {
        return JSON.parse(JSON.stringify(obj, bigIntReplacer));
    }
    catch (e) {
        return;
    }
}
// If args is has a single item that is an object, return that object
function structureArgs(args, filteredKeys = []) {
    if (!args) {
        return;
    }
    if (args.length === 0) {
        return;
    }
    if (args.length === 1 && typeof args[0] === "object") {
        return filterKeys(JSON.parse(JSON.stringify(args[0], bigIntReplacer)), filteredKeys);
    }
    return args;
}
// Recursively filter out keys from an object, including nested objects, and arrays
function filterKeys(obj, keys) {
    if (typeof obj !== "object" || obj === null) {
        return obj;
    }
    if (Array.isArray(obj)) {
        return obj.map((item) => filterKeys(item, keys));
    }
    const filteredObj = {};
    for (const [key, value] of Object.entries(obj)) {
        if (keys.includes(key)) {
            if (value) {
                filteredObj[key] = `[filtered ${prettyPrintBytes(value)}]`;
            }
            else {
                filteredObj[key] = value;
            }
            continue;
        }
        filteredObj[key] = filterKeys(value, keys);
    }
    return filteredObj;
}
function prettyPrintBytes(value) {
    if (env.NODE_ENV === "production") {
        return "skipped size";
    }
    const sizeInBytes = getSizeInBytes(value);
    if (sizeInBytes < 1024) {
        return `${sizeInBytes} bytes`;
    }
    if (sizeInBytes < 1024 * 1024) {
        return `${(sizeInBytes / 1024).toFixed(2)} KB`;
    }
    if (sizeInBytes < 1024 * 1024 * 1024) {
        return `${(sizeInBytes / (1024 * 1024)).toFixed(2)} MB`;
    }
    return `${(sizeInBytes / (1024 * 1024 * 1024)).toFixed(2)} GB`;
}
function getSizeInBytes(value) {
    const jsonString = JSON.stringify(value);
    return Buffer.byteLength(jsonString, "utf8");
}
//# sourceMappingURL=logger.js.map