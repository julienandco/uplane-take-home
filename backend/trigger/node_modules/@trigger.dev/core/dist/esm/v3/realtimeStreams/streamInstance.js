import { StreamsWriterV1 } from "./streamsWriterV1.js";
import { StreamsWriterV2 } from "./streamsWriterV2.js";
export class StreamInstance {
    options;
    streamPromise;
    constructor(options) {
        this.options = options;
        this.streamPromise = this.initializeWriter();
    }
    async initializeWriter() {
        const { version, headers } = await this.options.apiClient.createStream(this.options.runId, "self", this.options.key, this.options?.requestOptions);
        const parsedResponse = parseCreateStreamResponse(version, headers);
        const streamWriter = parsedResponse.version === "v1"
            ? new StreamsWriterV1({
                key: this.options.key,
                runId: this.options.runId,
                source: this.options.source,
                baseUrl: this.options.baseUrl,
                headers: this.options.apiClient.getHeaders(),
                signal: this.options.signal,
                version,
                target: "self",
            })
            : new StreamsWriterV2({
                basin: parsedResponse.basin,
                stream: parsedResponse.streamName ?? this.options.key,
                accessToken: parsedResponse.accessToken,
                source: this.options.source,
                signal: this.options.signal,
                debug: this.options.debug,
                flushIntervalMs: parsedResponse.flushIntervalMs,
                maxRetries: parsedResponse.maxRetries,
            });
        return streamWriter;
    }
    async wait() {
        return this.streamPromise.then((writer) => writer.wait());
    }
    get stream() {
        const self = this;
        return new ReadableStream({
            async start(controller) {
                const streamWriter = await self.streamPromise;
                const iterator = streamWriter[Symbol.asyncIterator]();
                while (true) {
                    if (self.options.signal?.aborted) {
                        controller.close();
                        break;
                    }
                    const { done, value } = await iterator.next();
                    if (done) {
                        controller.close();
                        break;
                    }
                    controller.enqueue(value);
                }
            },
        });
    }
}
function parseCreateStreamResponse(version, headers) {
    if (version === "v1") {
        return { version: "v1" };
    }
    const accessToken = headers?.["x-s2-access-token"];
    const basin = headers?.["x-s2-basin"];
    if (!accessToken || !basin) {
        return { version: "v1" };
    }
    const flushIntervalMs = headers?.["x-s2-flush-interval-ms"];
    const maxRetries = headers?.["x-s2-max-retries"];
    const streamName = headers?.["x-s2-stream-name"];
    return {
        version: "v2",
        accessToken,
        basin,
        flushIntervalMs: flushIntervalMs ? parseInt(flushIntervalMs) : undefined,
        maxRetries: maxRetries ? parseInt(maxRetries) : undefined,
        streamName,
    };
}
async function* streamToAsyncIterator(stream) {
    const reader = stream.getReader();
    try {
        while (true) {
            const { done, value } = await reader.read();
            if (done)
                return;
            yield value;
        }
    }
    finally {
        safeReleaseLock(reader);
    }
}
function safeReleaseLock(reader) {
    try {
        reader.releaseLock();
    }
    catch (error) { }
}
//# sourceMappingURL=streamInstance.js.map