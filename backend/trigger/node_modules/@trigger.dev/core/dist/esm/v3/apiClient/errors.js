export class ApiError extends Error {
    status;
    headers;
    error;
    code;
    param;
    type;
    constructor(status, error, message, headers) {
        super(`${ApiError.makeMessage(status, error, message)}`);
        this.name = "TriggerApiError";
        this.status = status;
        this.headers = headers;
        const data = error;
        this.error = data;
        this.code = data?.["code"];
        this.param = data?.["param"];
        this.type = data?.["type"];
    }
    static makeMessage(status, error, message) {
        const errorMessage = error?.message
            ? typeof error.message === "string"
                ? error.message
                : JSON.stringify(error.message)
            : typeof error === "string"
                ? error
                : error
                    ? JSON.stringify(error)
                    : undefined;
        if (errorMessage) {
            return errorMessage;
        }
        if (status && message) {
            return `${status} ${message}`;
        }
        if (status) {
            return `${status} status code (no body)`;
        }
        if (message) {
            return message;
        }
        return "(no status code or body)";
    }
    static generate(status, errorResponse, message, headers) {
        if (!status) {
            return new ApiConnectionError({ cause: castToError(errorResponse) });
        }
        const error = errorResponse?.["error"];
        if (status === 400) {
            return new BadRequestError(status, error, message, headers);
        }
        if (status === 401) {
            return new AuthenticationError(status, error, message, headers);
        }
        if (status === 403) {
            return new PermissionDeniedError(status, error, message, headers);
        }
        if (status === 404) {
            return new NotFoundError(status, error, message, headers);
        }
        if (status === 409) {
            return new ConflictError(status, error, message, headers);
        }
        if (status === 422) {
            return new UnprocessableEntityError(status, error, message, headers);
        }
        if (status === 429) {
            return new RateLimitError(status, error, message, headers);
        }
        if (status >= 500) {
            return new InternalServerError(status, error, message, headers);
        }
        return new ApiError(status, error, message, headers);
    }
}
export class ApiConnectionError extends ApiError {
    status = undefined;
    constructor({ message, cause }) {
        super(undefined, undefined, message || "Connection error.", undefined);
        // in some environments the 'cause' property is already declared
        // @ts-ignore
        if (cause)
            this.cause = cause;
    }
}
export class BadRequestError extends ApiError {
    status = 400;
}
export class AuthenticationError extends ApiError {
    status = 401;
}
export class PermissionDeniedError extends ApiError {
    status = 403;
}
export class NotFoundError extends ApiError {
    status = 404;
}
export class ConflictError extends ApiError {
    status = 409;
}
export class UnprocessableEntityError extends ApiError {
    status = 422;
}
export class RateLimitError extends ApiError {
    status = 429;
    get millisecondsUntilReset() {
        // x-ratelimit-reset is the unix timestamp in milliseconds when the rate limit will reset.
        const resetAtUnixEpochMs = (this.headers ?? {})["x-ratelimit-reset"];
        if (typeof resetAtUnixEpochMs === "string") {
            const resetAtUnixEpoch = parseInt(resetAtUnixEpochMs, 10);
            if (isNaN(resetAtUnixEpoch)) {
                return;
            }
            // Add between 0 and 2000ms to the reset time to add jitter
            return Math.max(resetAtUnixEpoch - Date.now() + Math.floor(Math.random() * 2000), 0);
        }
        return;
    }
}
export class InternalServerError extends ApiError {
}
export class ApiSchemaValidationError extends ApiError {
    status = 200;
    rawBody;
    constructor({ message, cause, status, rawBody, headers, }) {
        super(status, undefined, message || "Validation error.", headers);
        // in some environments the 'cause' property is already declared
        // @ts-ignore
        if (cause)
            this.cause = cause;
        this.rawBody = rawBody;
    }
}
/**
 * Error thrown when a batch stream completes but the batch was not sealed.
 * This indicates that not all expected items were received by the server.
 * The client should retry sending all items, or investigate the mismatch.
 */
export class BatchNotSealedError extends Error {
    name = "BatchNotSealedError";
    /** The batch ID that was not sealed */
    batchId;
    /** Number of items currently enqueued on the server */
    enqueuedCount;
    /** Number of items expected to complete the batch */
    expectedCount;
    /** Number of items accepted in this request */
    itemsAccepted;
    /** Number of items deduplicated in this request */
    itemsDeduplicated;
    constructor(options) {
        const message = `Batch ${options.batchId} was not sealed: received ${options.enqueuedCount} of ${options.expectedCount} expected items (accepted: ${options.itemsAccepted}, deduplicated: ${options.itemsDeduplicated})`;
        super(message);
        this.batchId = options.batchId;
        this.enqueuedCount = options.enqueuedCount;
        this.expectedCount = options.expectedCount;
        this.itemsAccepted = options.itemsAccepted;
        this.itemsDeduplicated = options.itemsDeduplicated;
    }
}
function castToError(err) {
    if (err instanceof Error)
        return err;
    return new Error(err);
}
//# sourceMappingURL=errors.js.map