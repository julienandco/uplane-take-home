import { QueueMetricsProcessor } from "./queueMetricsProcessor.js";
export type ScalingStrategyKind = "none" | "smooth" | "aggressive";
export interface ScalingStrategyOptions {
    metricsProcessor?: QueueMetricsProcessor;
    dampingFactor?: number;
    minConsumerCount: number;
    maxConsumerCount: number;
    targetRatio: number;
}
export declare abstract class ScalingStrategy {
    abstract readonly name: string;
    private readonly minConsumerCount;
    private readonly maxConsumerCount;
    protected readonly targetRatio: number;
    constructor(options?: ScalingStrategyOptions);
    /**
     * Calculates the target consumer count with clamping to min/max bounds
     * Uses template method pattern to ensure consistent clamping across all strategies
     */
    calculateTargetCount(currentCount: number): number;
    /**
     * Internal method for subclasses to implement their specific scaling logic
     * Should return the unclamped target count
     */
    protected abstract calculateTargetCountInternal(currentCount: number): number;
    /**
     * Creates a scaling strategy by name
     */
    static create(strategy: ScalingStrategyKind, options?: ScalingStrategyOptions): ScalingStrategy;
}
/**
 * Static scaling strategy - maintains a fixed number of consumers
 */
export declare class NoneScalingStrategy extends ScalingStrategy {
    readonly name = "none";
    constructor(options?: ScalingStrategyOptions);
    protected calculateTargetCountInternal(currentCount: number): number;
}
/**
 * Smooth scaling strategy with EWMA smoothing and damping
 * Uses exponentially weighted moving average for queue length smoothing
 * and applies damping to prevent rapid oscillations.
 */
export declare class SmoothScalingStrategy extends ScalingStrategy {
    readonly name = "smooth";
    private readonly dampingFactor;
    private readonly metricsProcessor;
    constructor(options?: ScalingStrategyOptions);
    protected calculateTargetCountInternal(currentCount: number): number;
}
/**
 * Aggressive scaling strategy with threshold-based zones
 * Uses threshold-based zones for different scaling behaviors.
 * Scales up quickly when load increases but scales down cautiously.
 */
export declare class AggressiveScalingStrategy extends ScalingStrategy {
    readonly name = "aggressive";
    private readonly metricsProcessor;
    constructor(options?: ScalingStrategyOptions);
    protected calculateTargetCountInternal(currentCount: number): number;
    getThresholds(targetRatio: number): {
        scaleDownThreshold: number;
        scaleUpThreshold: number;
        criticalThreshold: number;
        highThreshold: number;
    };
}
