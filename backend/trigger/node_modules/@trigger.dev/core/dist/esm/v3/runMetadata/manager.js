import { dequal } from "dequal/lite";
import { realtimeStreams } from "../realtime-streams-api.js";
import { stringifyIO } from "../utils/ioSerialization.js";
import { applyMetadataOperations, collapseOperations } from "./operations.js";
export class StandardMetadataManager {
    apiClient;
    flushTimeoutId = null;
    isFlushing = false;
    store;
    queuedOperations = new Set();
    queuedParentOperations = new Set();
    queuedRootOperations = new Set();
    runId;
    runIdIsRoot = false;
    constructor(apiClient) {
        this.apiClient = apiClient;
    }
    reset() {
        this.queuedOperations.clear();
        this.queuedParentOperations.clear();
        this.queuedRootOperations.clear();
        this.store = undefined;
        this.runId = undefined;
        this.runIdIsRoot = false;
        if (this.flushTimeoutId) {
            clearTimeout(this.flushTimeoutId);
            this.flushTimeoutId = null;
        }
        this.isFlushing = false;
    }
    get parent() {
        // Store a reference to 'this' to ensure proper context
        const self = this;
        // Create the updater object and store it in a local variable
        const parentUpdater = {
            set: (key, value) => {
                // We have to check runIdIsRoot here because parent/root are executed before runIdIsRoot is set
                if (self.runIdIsRoot) {
                    return self.set(key, value);
                }
                self.queuedParentOperations.add({ type: "set", key, value });
                return parentUpdater;
            },
            del: (key) => {
                // We have to check runIdIsRoot here because parent/root are executed before runIdIsRoot is set
                if (self.runIdIsRoot) {
                    return self.del(key);
                }
                self.queuedParentOperations.add({ type: "delete", key });
                return parentUpdater;
            },
            append: (key, value) => {
                // We have to check runIdIsRoot here because parent/root are executed before runIdIsRoot is set
                if (self.runIdIsRoot) {
                    return self.append(key, value);
                }
                self.queuedParentOperations.add({ type: "append", key, value });
                return parentUpdater;
            },
            remove: (key, value) => {
                // We have to check runIdIsRoot here because parent/root are executed before runIdIsRoot is set
                if (self.runIdIsRoot) {
                    return self.remove(key, value);
                }
                self.queuedParentOperations.add({ type: "remove", key, value });
                return parentUpdater;
            },
            increment: (key, value) => {
                // We have to check runIdIsRoot here because parent/root are executed before runIdIsRoot is set
                if (self.runIdIsRoot) {
                    return self.increment(key, value);
                }
                self.queuedParentOperations.add({ type: "increment", key, value });
                return parentUpdater;
            },
            decrement: (key, value) => {
                // We have to check runIdIsRoot here because parent/root are executed before runIdIsRoot is set
                if (self.runIdIsRoot) {
                    return self.decrement(key, value);
                }
                self.queuedParentOperations.add({ type: "increment", key, value: -Math.abs(value) });
                return parentUpdater;
            },
            update: (value) => {
                // We have to check runIdIsRoot here because parent/root are executed before runIdIsRoot is set
                if (self.runIdIsRoot) {
                    return self.update(value);
                }
                self.queuedParentOperations.add({ type: "update", value });
                return parentUpdater;
            },
            stream: (key, value, signal) => {
                // We have to check runIdIsRoot here because parent/root are executed before runIdIsRoot is set
                if (self.runIdIsRoot) {
                    return self.doStream(key, value, "self", parentUpdater, signal);
                }
                return self.doStream(key, value, "parent", parentUpdater, signal);
            },
        };
        return parentUpdater;
    }
    get root() {
        // Store a reference to 'this' to ensure proper context
        const self = this;
        // Create the updater object and store it in a local variable
        const rootUpdater = {
            set: (key, value) => {
                // We have to check runIdIsRoot here because parent/root are executed before runIdIsRoot is set
                if (self.runIdIsRoot) {
                    return self.set(key, value);
                }
                self.queuedRootOperations.add({ type: "set", key, value });
                return rootUpdater;
            },
            del: (key) => {
                // We have to check runIdIsRoot here because parent/root are executed before runIdIsRoot is set
                if (self.runIdIsRoot) {
                    return self.del(key);
                }
                self.queuedRootOperations.add({ type: "delete", key });
                return rootUpdater;
            },
            append: (key, value) => {
                // We have to check runIdIsRoot here because parent/root are executed before runIdIsRoot is set
                if (self.runIdIsRoot) {
                    return self.append(key, value);
                }
                self.queuedRootOperations.add({ type: "append", key, value });
                return rootUpdater;
            },
            remove: (key, value) => {
                // We have to check runIdIsRoot here because parent/root are executed before runIdIsRoot is set
                if (self.runIdIsRoot) {
                    return self.remove(key, value);
                }
                self.queuedRootOperations.add({ type: "remove", key, value });
                return rootUpdater;
            },
            increment: (key, value) => {
                // We have to check runIdIsRoot here because parent/root are executed before runIdIsRoot is set
                if (self.runIdIsRoot) {
                    return self.increment(key, value);
                }
                self.queuedRootOperations.add({ type: "increment", key, value });
                return rootUpdater;
            },
            decrement: (key, value) => {
                // We have to check runIdIsRoot here because parent/root are executed before runIdIsRoot is set
                if (self.runIdIsRoot) {
                    return self.decrement(key, value);
                }
                self.queuedRootOperations.add({ type: "increment", key, value: -Math.abs(value) });
                return rootUpdater;
            },
            update: (value) => {
                // We have to check runIdIsRoot here because parent/root are executed before runIdIsRoot is set
                if (self.runIdIsRoot) {
                    return self.update(value);
                }
                self.queuedRootOperations.add({ type: "update", value });
                return rootUpdater;
            },
            stream: (key, value, signal) => {
                // We have to check runIdIsRoot here because parent/root are executed before runIdIsRoot is set
                if (self.runIdIsRoot) {
                    return self.doStream(key, value, "self", rootUpdater, signal);
                }
                return self.doStream(key, value, "root", rootUpdater, signal);
            },
        };
        return rootUpdater;
    }
    enterWithMetadata(metadata) {
        this.store = metadata ?? {};
    }
    current() {
        return this.store;
    }
    getKey(key) {
        return this.store?.[key];
    }
    enqueueOperation(operation) {
        const applyResults = applyMetadataOperations(this.store ?? {}, operation);
        if (applyResults.unappliedOperations.length > 0) {
            return;
        }
        if (dequal(this.store, applyResults.newMetadata)) {
            return;
        }
        this.queuedOperations.add(operation);
        this.store = applyResults.newMetadata;
    }
    set(key, value) {
        if (!this.runId) {
            return this;
        }
        this.enqueueOperation({ type: "set", key, value });
        return this;
    }
    del(key) {
        if (!this.runId) {
            return this;
        }
        this.enqueueOperation({ type: "delete", key });
        return this;
    }
    append(key, value) {
        if (!this.runId) {
            return this;
        }
        this.enqueueOperation({ type: "append", key, value });
        return this;
    }
    remove(key, value) {
        if (!this.runId) {
            return this;
        }
        this.enqueueOperation({ type: "remove", key, value });
        return this;
    }
    increment(key, increment = 1) {
        if (!this.runId) {
            return this;
        }
        this.enqueueOperation({ type: "increment", key, value: increment });
        return this;
    }
    decrement(key, decrement = 1) {
        return this.increment(key, -decrement);
    }
    update(metadata) {
        if (!this.runId) {
            return this;
        }
        this.enqueueOperation({ type: "update", value: metadata });
        return this;
    }
    async stream(key, value, signal) {
        return this.doStream(key, value, "self", this, signal);
    }
    async fetchStream(key, signal) {
        if (!this.runId) {
            throw new Error("Run ID is not set. fetchStream() can only be used inside a task.");
        }
        return await this.apiClient.fetchStream(this.runId, key, {
            signal,
            timeoutInSeconds: 60,
            lastEventId: undefined,
        });
    }
    async doStream(key, value, target, updater = this, signal) {
        const $value = value;
        if (!this.runId) {
            return $value;
        }
        const streamInstance = realtimeStreams.pipe(key, value, {
            signal,
            target,
        });
        return streamInstance.stream;
    }
    async refresh(requestOptions) {
        if (!this.runId) {
            return;
        }
        try {
            const metadata = await this.apiClient.getRunMetadata(this.runId, requestOptions);
            this.store = metadata.metadata;
        }
        catch (error) {
            console.error("Failed to refresh metadata", error);
            throw error;
        }
    }
    async flush(requestOptions) {
        if (!this.runId) {
            return;
        }
        if (!this.#needsFlush()) {
            return;
        }
        if (this.isFlushing) {
            return;
        }
        this.isFlushing = true;
        const operations = Array.from(this.queuedOperations);
        this.queuedOperations.clear();
        const parentOperations = Array.from(this.queuedParentOperations);
        this.queuedParentOperations.clear();
        const rootOperations = Array.from(this.queuedRootOperations);
        this.queuedRootOperations.clear();
        try {
            const collapsedOperations = collapseOperations(operations);
            const collapsedParentOperations = collapseOperations(parentOperations);
            const collapsedRootOperations = collapseOperations(rootOperations);
            const response = await this.apiClient.updateRunMetadata(this.runId, {
                operations: collapsedOperations,
                parentOperations: collapsedParentOperations,
                rootOperations: collapsedRootOperations,
            }, requestOptions);
            this.store = response.metadata;
        }
        catch (error) {
            console.error("Failed to flush metadata", error);
        }
        finally {
            this.isFlushing = false;
        }
    }
    startPeriodicFlush(intervalMs = 1000) {
        const periodicFlush = async (intervalMs) => {
            if (this.isFlushing) {
                return;
            }
            try {
                await this.flush();
            }
            catch (error) {
                console.error("Failed to flush metadata", error);
                throw error;
            }
            finally {
                this.isFlushing = false;
                scheduleNext();
            }
        };
        const scheduleNext = () => {
            this.flushTimeoutId = setTimeout(() => periodicFlush(intervalMs), intervalMs);
        };
        scheduleNext();
    }
    stopPeriodicFlush() {
        if (this.flushTimeoutId) {
            clearTimeout(this.flushTimeoutId);
            this.flushTimeoutId = null;
        }
    }
    async stopAndReturnLastFlush() {
        this.stopPeriodicFlush();
        this.isFlushing = true;
        if (!this.#needsFlush()) {
            return { dataType: "application/json" };
        }
        const operations = Array.from(this.queuedOperations);
        const parentOperations = Array.from(this.queuedParentOperations);
        const rootOperations = Array.from(this.queuedRootOperations);
        const data = {
            operations: collapseOperations(operations),
            parentOperations: collapseOperations(parentOperations),
            rootOperations: collapseOperations(rootOperations),
        };
        const packet = await stringifyIO(data);
        return packet;
    }
    #needsFlush() {
        return (this.queuedOperations.size > 0 ||
            this.queuedParentOperations.size > 0 ||
            this.queuedRootOperations.size > 0);
    }
}
//# sourceMappingURL=manager.js.map