"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BatchTriggerError = exports.TaskRunPromise = exports.SubtaskUnwrapError = void 0;
exports.queue = queue;
exports.createTask = createTask;
exports.createToolTask = createToolTask;
exports.createSchemaTask = createSchemaTask;
exports.trigger = trigger;
exports.triggerAndWait = triggerAndWait;
exports.batchTriggerAndWait = batchTriggerAndWait;
exports.batchTrigger = batchTrigger;
exports.batchTriggerById = batchTriggerById;
exports.batchTriggerByIdAndWait = batchTriggerByIdAndWait;
exports.batchTriggerTasks = batchTriggerTasks;
exports.batchTriggerAndWaitTasks = batchTriggerAndWaitTasks;
exports.readableStreamToAsyncIterable = readableStreamToAsyncIterable;
const api_1 = require("@opentelemetry/api");
const v3_1 = require("@trigger.dev/core/v3");
Object.defineProperty(exports, "SubtaskUnwrapError", { enumerable: true, get: function () { return v3_1.SubtaskUnwrapError; } });
Object.defineProperty(exports, "TaskRunPromise", { enumerable: true, get: function () { return v3_1.TaskRunPromise; } });
const tracer_js_1 = require("./tracer.js");
function queue(options) {
    v3_1.resourceCatalog.registerQueueMetadata(options);
    // @ts-expect-error
    options[Symbol.for("trigger.dev/queue")] = true;
    return options;
}
function createTask(params) {
    const task = {
        id: params.id,
        description: params.description,
        jsonSchema: params.jsonSchema,
        trigger: async (payload, options) => {
            return await trigger_internal("trigger()", params.id, payload, undefined, {
                queue: params.queue?.name,
                ...options,
            });
        },
        batchTrigger: async (items, options) => {
            return await batchTrigger_internal("batchTrigger()", params.id, items, options, undefined, undefined, params.queue?.name);
        },
        triggerAndWait: (payload, options, requestOptions) => {
            return new v3_1.TaskRunPromise((resolve, reject) => {
                triggerAndWait_internal("triggerAndWait()", params.id, payload, undefined, {
                    queue: params.queue?.name,
                    ...options,
                }, requestOptions)
                    .then((result) => {
                    resolve(result);
                })
                    .catch((error) => {
                    reject(error);
                });
            }, params.id);
        },
        batchTriggerAndWait: async (items, options) => {
            return await batchTriggerAndWait_internal("batchTriggerAndWait()", params.id, items, undefined, options, undefined, params.queue?.name);
        },
    };
    registerTaskLifecycleHooks(params.id, params);
    v3_1.resourceCatalog.registerTaskMetadata({
        id: params.id,
        description: params.description,
        queue: params.queue,
        retry: params.retry ? { ...v3_1.defaultRetryOptions, ...params.retry } : undefined,
        machine: typeof params.machine === "string" ? { preset: params.machine } : params.machine,
        maxDuration: params.maxDuration,
        payloadSchema: params.jsonSchema,
        fns: {
            run: params.run,
        },
    });
    const queue = params.queue;
    if (queue && typeof queue.name === "string") {
        v3_1.resourceCatalog.registerQueueMetadata({
            name: queue.name,
            concurrencyLimit: queue.concurrencyLimit,
        });
    }
    // @ts-expect-error
    task[Symbol.for("trigger.dev/task")] = true;
    return task;
}
/**
 * @deprecated use ai.tool() instead
 */
function createToolTask(params) {
    const task = createSchemaTask({
        ...params,
        schema: (0, v3_1.convertToolParametersToSchema)(params.parameters),
    });
    return {
        ...task,
        tool: {
            parameters: params.parameters,
            description: params.description,
            execute: async (args) => {
                return task.triggerAndWait(args).unwrap();
            },
        },
    };
}
function createSchemaTask(params) {
    const parsePayload = params.schema
        ? (0, v3_1.getSchemaParseFn)(params.schema)
        : undefined;
    const task = {
        id: params.id,
        description: params.description,
        schema: params.schema,
        trigger: async (payload, options, requestOptions) => {
            return await trigger_internal("trigger()", params.id, payload, parsePayload, {
                queue: params.queue?.name,
                ...options,
            }, requestOptions);
        },
        batchTrigger: async (items, options, requestOptions) => {
            return await batchTrigger_internal("batchTrigger()", params.id, items, options, parsePayload, requestOptions, params.queue?.name);
        },
        triggerAndWait: (payload, options) => {
            return new v3_1.TaskRunPromise((resolve, reject) => {
                triggerAndWait_internal("triggerAndWait()", params.id, payload, parsePayload, {
                    queue: params.queue?.name,
                    ...options,
                })
                    .then((result) => {
                    resolve(result);
                })
                    .catch((error) => {
                    reject(error);
                });
            }, params.id);
        },
        batchTriggerAndWait: async (items, options) => {
            return await batchTriggerAndWait_internal("batchTriggerAndWait()", params.id, items, parsePayload, options, undefined, params.queue?.name);
        },
    };
    registerTaskLifecycleHooks(params.id, params);
    v3_1.resourceCatalog.registerTaskMetadata({
        id: params.id,
        description: params.description,
        queue: params.queue,
        retry: params.retry ? { ...v3_1.defaultRetryOptions, ...params.retry } : undefined,
        machine: typeof params.machine === "string" ? { preset: params.machine } : params.machine,
        maxDuration: params.maxDuration,
        fns: {
            run: params.run,
            parsePayload,
        },
        schema: params.schema,
    });
    const queue = params.queue;
    if (queue && typeof queue.name === "string") {
        v3_1.resourceCatalog.registerQueueMetadata({
            name: queue.name,
            concurrencyLimit: queue.concurrencyLimit,
        });
    }
    // @ts-expect-error
    task[Symbol.for("trigger.dev/task")] = true;
    return task;
}
/**
 * Trigger a task by its identifier with the given payload. Returns a typesafe `RunHandle`.
 *
 * @example
 *
 * ```ts
 * import { tasks, runs } from "@trigger.dev/sdk/v3";
 * import type { myTask } from "./myTasks"; // Import just the type of the task
 *
 * const handle = await tasks.trigger<typeof myTask>("my-task", { foo: "bar" }); // The id and payload are fully typesafe
 * const run = await runs.retrieve(handle);
 * console.log(run.output) // The output is also fully typed
 * ```
 *
 * @returns {RunHandle} An object with the `id` of the run. Can be used to retrieve the completed run output in a typesafe manner.
 */
async function trigger(id, payload, options, requestOptions) {
    return await trigger_internal("tasks.trigger()", id, payload, undefined, options, requestOptions);
}
/**
 * Trigger a task with the given payload, and wait for the result. Returns the result of the task run
 * @param id - The id of the task to trigger
 * @param payload
 * @param options - Options for the task run
 * @returns TaskRunResult
 * @example
 * ```ts
 * import { tasks } from "@trigger.dev/sdk/v3";
 * const result = await tasks.triggerAndWait("my-task", { foo: "bar" });
 *
 * if (result.ok) {
 *  console.log(result.output);
 * } else {
 *  console.error(result.error);
 * }
 * ```
 */
function triggerAndWait(id, payload, options, requestOptions) {
    return new v3_1.TaskRunPromise((resolve, reject) => {
        triggerAndWait_internal("tasks.triggerAndWait()", id, payload, undefined, options, requestOptions)
            .then((result) => {
            resolve(result);
        })
            .catch((error) => {
            reject(error);
        });
    }, id);
}
/**
 * Batch trigger multiple task runs with the given payloads, and wait for the results. Returns the results of the task runs.
 * @param id - The id of the task to trigger
 * @param items
 * @returns BatchResult
 * @example
 *
 * ```ts
 * import { tasks } from "@trigger.dev/sdk/v3";
 *
 * const result = await tasks.batchTriggerAndWait("my-task", [
 *  { payload: { foo: "bar" } },
 *  { payload: { foo: "baz" } },
 * ]);
 *
 * for (const run of result.runs) {
 *  if (run.ok) {
 *    console.log(run.output);
 *  } else {
 *    console.error(run.error);
 *  }
 * }
 * ```
 */
async function batchTriggerAndWait(id, items, options, requestOptions) {
    return await batchTriggerAndWait_internal("tasks.batchTriggerAndWait()", id, items, undefined, options, requestOptions);
}
async function batchTrigger(id, items, options, requestOptions) {
    return await batchTrigger_internal("tasks.batchTrigger()", id, items, options, undefined, requestOptions);
}
// Implementation
async function batchTriggerById(...args) {
    const [items, options, requestOptions] = args;
    const apiClient = v3_1.apiClientManager.clientOrThrow(requestOptions?.clientConfig);
    // Check if items is an array or a stream
    if (Array.isArray(items)) {
        // Array path: existing logic
        const ndJsonItems = await Promise.all(items.map(async (item, index) => {
            const taskMetadata = v3_1.resourceCatalog.getTask(item.id);
            const parsedPayload = taskMetadata?.fns.parsePayload
                ? await taskMetadata?.fns.parsePayload(item.payload)
                : item.payload;
            const payloadPacket = await (0, v3_1.stringifyIO)(parsedPayload);
            const batchItemIdempotencyKey = await (0, v3_1.makeIdempotencyKey)((0, v3_1.flattenIdempotencyKey)([options?.idempotencyKey, `${index}`]));
            return {
                index,
                task: item.id,
                payload: payloadPacket.data,
                options: {
                    queue: item.options?.queue ? { name: item.options.queue } : undefined,
                    concurrencyKey: item.options?.concurrencyKey,
                    test: v3_1.taskContext.ctx?.run.isTest,
                    payloadType: payloadPacket.dataType,
                    delay: item.options?.delay,
                    ttl: item.options?.ttl,
                    tags: item.options?.tags,
                    maxAttempts: item.options?.maxAttempts,
                    metadata: item.options?.metadata,
                    maxDuration: item.options?.maxDuration,
                    idempotencyKey: (await (0, v3_1.makeIdempotencyKey)(item.options?.idempotencyKey)) ?? batchItemIdempotencyKey,
                    idempotencyKeyTTL: item.options?.idempotencyKeyTTL ?? options?.idempotencyKeyTTL,
                    machine: item.options?.machine,
                    priority: item.options?.priority,
                    region: item.options?.region,
                    lockToVersion: item.options?.version ?? (0, v3_1.getEnvVar)("TRIGGER_VERSION"),
                    debounce: item.options?.debounce,
                },
            };
        }));
        // Execute 2-phase batch
        const response = await tracer_js_1.tracer.startActiveSpan("batch.trigger()", async (span) => {
            const result = await executeBatchTwoPhase(apiClient, ndJsonItems, {
                parentRunId: v3_1.taskContext.ctx?.run.id,
                idempotencyKey: await (0, v3_1.makeIdempotencyKey)(options?.idempotencyKey),
                spanParentAsLink: true, // Fire-and-forget: child runs get separate trace IDs
            }, requestOptions);
            span.setAttribute("batchId", result.id);
            span.setAttribute("runCount", result.runCount);
            return result;
        }, {
            kind: api_1.SpanKind.PRODUCER,
            attributes: {
                [v3_1.SemanticInternalAttributes.STYLE_ICON]: "trigger",
            },
        });
        const handle = {
            batchId: response.id,
            runCount: response.runCount,
            publicAccessToken: response.publicAccessToken,
        };
        return handle;
    }
    else {
        // Stream path: convert to AsyncIterable and transform
        const asyncItems = normalizeToAsyncIterable(items);
        const transformedItems = transformBatchItemsStream(asyncItems, options);
        // Execute streaming 2-phase batch
        const response = await tracer_js_1.tracer.startActiveSpan("batch.trigger()", async (span) => {
            const result = await executeBatchTwoPhaseStreaming(apiClient, transformedItems, {
                parentRunId: v3_1.taskContext.ctx?.run.id,
                idempotencyKey: await (0, v3_1.makeIdempotencyKey)(options?.idempotencyKey),
                spanParentAsLink: true, // Fire-and-forget: child runs get separate trace IDs
            }, requestOptions);
            span.setAttribute("batchId", result.id);
            span.setAttribute("runCount", result.runCount);
            return result;
        }, {
            kind: api_1.SpanKind.PRODUCER,
            attributes: {
                [v3_1.SemanticInternalAttributes.STYLE_ICON]: "trigger",
            },
        });
        const handle = {
            batchId: response.id,
            runCount: response.runCount,
            publicAccessToken: response.publicAccessToken,
        };
        return handle;
    }
}
// Implementation
async function batchTriggerByIdAndWait(...args) {
    const [items, options, requestOptions] = args;
    const ctx = v3_1.taskContext.ctx;
    if (!ctx) {
        throw new Error("batchTriggerAndWait can only be used from inside a task.run()");
    }
    const apiClient = v3_1.apiClientManager.clientOrThrow(requestOptions?.clientConfig);
    // Check if items is an array or a stream
    if (Array.isArray(items)) {
        // Array path: existing logic
        const ndJsonItems = await Promise.all(items.map(async (item, index) => {
            const taskMetadata = v3_1.resourceCatalog.getTask(item.id);
            const parsedPayload = taskMetadata?.fns.parsePayload
                ? await taskMetadata?.fns.parsePayload(item.payload)
                : item.payload;
            const payloadPacket = await (0, v3_1.stringifyIO)(parsedPayload);
            const batchItemIdempotencyKey = await (0, v3_1.makeIdempotencyKey)((0, v3_1.flattenIdempotencyKey)([options?.idempotencyKey, `${index}`]));
            return {
                index,
                task: item.id,
                payload: payloadPacket.data,
                options: {
                    lockToVersion: v3_1.taskContext.worker?.version,
                    queue: item.options?.queue ? { name: item.options.queue } : undefined,
                    concurrencyKey: item.options?.concurrencyKey,
                    test: v3_1.taskContext.ctx?.run.isTest,
                    payloadType: payloadPacket.dataType,
                    delay: item.options?.delay,
                    ttl: item.options?.ttl,
                    tags: item.options?.tags,
                    maxAttempts: item.options?.maxAttempts,
                    metadata: item.options?.metadata,
                    maxDuration: item.options?.maxDuration,
                    idempotencyKey: (await (0, v3_1.makeIdempotencyKey)(item.options?.idempotencyKey)) ?? batchItemIdempotencyKey,
                    idempotencyKeyTTL: item.options?.idempotencyKeyTTL ?? options?.idempotencyKeyTTL,
                    machine: item.options?.machine,
                    priority: item.options?.priority,
                    region: item.options?.region,
                    debounce: item.options?.debounce,
                },
            };
        }));
        return await tracer_js_1.tracer.startActiveSpan("batch.triggerAndWait()", async (span) => {
            // Execute 2-phase batch
            const response = await executeBatchTwoPhase(apiClient, ndJsonItems, {
                parentRunId: ctx.run.id,
                resumeParentOnCompletion: true,
                idempotencyKey: await (0, v3_1.makeIdempotencyKey)(options?.idempotencyKey),
                spanParentAsLink: false, // Waiting: child runs share parent's trace ID
            }, requestOptions);
            span.setAttribute("batchId", response.id);
            span.setAttribute("runCount", response.runCount);
            const result = await v3_1.runtime.waitForBatch({
                id: response.id,
                runCount: response.runCount,
                ctx,
            });
            const runs = await handleBatchTaskRunExecutionResultV2(result.items);
            return {
                id: result.id,
                runs,
            };
        }, {
            kind: api_1.SpanKind.PRODUCER,
            attributes: {
                [v3_1.SemanticInternalAttributes.STYLE_ICON]: "trigger",
            },
        });
    }
    else {
        // Stream path: convert to AsyncIterable and transform
        const asyncItems = normalizeToAsyncIterable(items);
        const transformedItems = transformBatchItemsStreamForWait(asyncItems, options);
        return await tracer_js_1.tracer.startActiveSpan("batch.triggerAndWait()", async (span) => {
            // Execute streaming 2-phase batch
            const response = await executeBatchTwoPhaseStreaming(apiClient, transformedItems, {
                parentRunId: ctx.run.id,
                resumeParentOnCompletion: true,
                idempotencyKey: await (0, v3_1.makeIdempotencyKey)(options?.idempotencyKey),
                spanParentAsLink: false, // Waiting: child runs share parent's trace ID
            }, requestOptions);
            span.setAttribute("batchId", response.id);
            span.setAttribute("runCount", response.runCount);
            const result = await v3_1.runtime.waitForBatch({
                id: response.id,
                runCount: response.runCount,
                ctx,
            });
            const runs = await handleBatchTaskRunExecutionResultV2(result.items);
            return {
                id: result.id,
                runs,
            };
        }, {
            kind: api_1.SpanKind.PRODUCER,
            attributes: {
                [v3_1.SemanticInternalAttributes.STYLE_ICON]: "trigger",
            },
        });
    }
}
// Implementation
async function batchTriggerTasks(...args) {
    const [items, options, requestOptions] = args;
    const apiClient = v3_1.apiClientManager.clientOrThrow(requestOptions?.clientConfig);
    // Check if items is an array or a stream
    if (Array.isArray(items)) {
        // Array path: existing logic
        const ndJsonItems = await Promise.all(items.map(async (item, index) => {
            const taskMetadata = v3_1.resourceCatalog.getTask(item.task.id);
            const parsedPayload = taskMetadata?.fns.parsePayload
                ? await taskMetadata?.fns.parsePayload(item.payload)
                : item.payload;
            const payloadPacket = await (0, v3_1.stringifyIO)(parsedPayload);
            const batchItemIdempotencyKey = await (0, v3_1.makeIdempotencyKey)((0, v3_1.flattenIdempotencyKey)([options?.idempotencyKey, `${index}`]));
            return {
                index,
                task: item.task.id,
                payload: payloadPacket.data,
                options: {
                    queue: item.options?.queue ? { name: item.options.queue } : undefined,
                    concurrencyKey: item.options?.concurrencyKey,
                    test: v3_1.taskContext.ctx?.run.isTest,
                    payloadType: payloadPacket.dataType,
                    delay: item.options?.delay,
                    ttl: item.options?.ttl,
                    tags: item.options?.tags,
                    maxAttempts: item.options?.maxAttempts,
                    metadata: item.options?.metadata,
                    maxDuration: item.options?.maxDuration,
                    idempotencyKey: (await (0, v3_1.makeIdempotencyKey)(item.options?.idempotencyKey)) ?? batchItemIdempotencyKey,
                    idempotencyKeyTTL: item.options?.idempotencyKeyTTL ?? options?.idempotencyKeyTTL,
                    machine: item.options?.machine,
                    priority: item.options?.priority,
                    region: item.options?.region,
                    lockToVersion: item.options?.version ?? (0, v3_1.getEnvVar)("TRIGGER_VERSION"),
                    debounce: item.options?.debounce,
                },
            };
        }));
        // Execute 2-phase batch
        const response = await tracer_js_1.tracer.startActiveSpan("batch.triggerByTask()", async (span) => {
            const result = await executeBatchTwoPhase(apiClient, ndJsonItems, {
                parentRunId: v3_1.taskContext.ctx?.run.id,
                idempotencyKey: await (0, v3_1.makeIdempotencyKey)(options?.idempotencyKey),
                spanParentAsLink: true, // Fire-and-forget: child runs get separate trace IDs
            }, requestOptions);
            span.setAttribute("batchId", result.id);
            span.setAttribute("runCount", result.runCount);
            return result;
        }, {
            kind: api_1.SpanKind.PRODUCER,
            attributes: {
                [v3_1.SemanticInternalAttributes.STYLE_ICON]: "trigger",
            },
        });
        const handle = {
            batchId: response.id,
            runCount: response.runCount,
            publicAccessToken: response.publicAccessToken,
        };
        return handle;
    }
    else {
        // Stream path: convert to AsyncIterable and transform
        const streamItems = items;
        const asyncItems = normalizeToAsyncIterable(streamItems);
        const transformedItems = transformBatchByTaskItemsStream(asyncItems, options);
        // Execute streaming 2-phase batch
        const response = await tracer_js_1.tracer.startActiveSpan("batch.triggerByTask()", async (span) => {
            const result = await executeBatchTwoPhaseStreaming(apiClient, transformedItems, {
                parentRunId: v3_1.taskContext.ctx?.run.id,
                idempotencyKey: await (0, v3_1.makeIdempotencyKey)(options?.idempotencyKey),
                spanParentAsLink: true, // Fire-and-forget: child runs get separate trace IDs
            }, requestOptions);
            span.setAttribute("batchId", result.id);
            span.setAttribute("runCount", result.runCount);
            return result;
        }, {
            kind: api_1.SpanKind.PRODUCER,
            attributes: {
                [v3_1.SemanticInternalAttributes.STYLE_ICON]: "trigger",
            },
        });
        const handle = {
            batchId: response.id,
            runCount: response.runCount,
            publicAccessToken: response.publicAccessToken,
        };
        return handle;
    }
}
// Implementation
async function batchTriggerAndWaitTasks(...args) {
    const [items, options, requestOptions] = args;
    const ctx = v3_1.taskContext.ctx;
    if (!ctx) {
        throw new Error("batchTriggerAndWait can only be used from inside a task.run()");
    }
    const apiClient = v3_1.apiClientManager.clientOrThrow(requestOptions?.clientConfig);
    // Check if items is an array or a stream
    if (Array.isArray(items)) {
        // Array path: existing logic
        const ndJsonItems = await Promise.all(items.map(async (item, index) => {
            const taskMetadata = v3_1.resourceCatalog.getTask(item.task.id);
            const parsedPayload = taskMetadata?.fns.parsePayload
                ? await taskMetadata?.fns.parsePayload(item.payload)
                : item.payload;
            const payloadPacket = await (0, v3_1.stringifyIO)(parsedPayload);
            const batchItemIdempotencyKey = await (0, v3_1.makeIdempotencyKey)((0, v3_1.flattenIdempotencyKey)([options?.idempotencyKey, `${index}`]));
            return {
                index,
                task: item.task.id,
                payload: payloadPacket.data,
                options: {
                    lockToVersion: v3_1.taskContext.worker?.version,
                    queue: item.options?.queue ? { name: item.options.queue } : undefined,
                    concurrencyKey: item.options?.concurrencyKey,
                    test: v3_1.taskContext.ctx?.run.isTest,
                    payloadType: payloadPacket.dataType,
                    delay: item.options?.delay,
                    ttl: item.options?.ttl,
                    tags: item.options?.tags,
                    maxAttempts: item.options?.maxAttempts,
                    metadata: item.options?.metadata,
                    maxDuration: item.options?.maxDuration,
                    idempotencyKey: (await (0, v3_1.makeIdempotencyKey)(item.options?.idempotencyKey)) ?? batchItemIdempotencyKey,
                    idempotencyKeyTTL: item.options?.idempotencyKeyTTL ?? options?.idempotencyKeyTTL,
                    machine: item.options?.machine,
                    priority: item.options?.priority,
                    region: item.options?.region,
                    debounce: item.options?.debounce,
                },
            };
        }));
        return await tracer_js_1.tracer.startActiveSpan("batch.triggerByTaskAndWait()", async (span) => {
            // Execute 2-phase batch
            const response = await executeBatchTwoPhase(apiClient, ndJsonItems, {
                parentRunId: ctx.run.id,
                resumeParentOnCompletion: true,
                idempotencyKey: await (0, v3_1.makeIdempotencyKey)(options?.idempotencyKey),
                spanParentAsLink: false, // Waiting: child runs share parent's trace ID
            }, requestOptions);
            span.setAttribute("batchId", response.id);
            span.setAttribute("runCount", response.runCount);
            const result = await v3_1.runtime.waitForBatch({
                id: response.id,
                runCount: response.runCount,
                ctx,
            });
            const runs = await handleBatchTaskRunExecutionResultV2(result.items);
            return {
                id: result.id,
                runs,
            };
        }, {
            kind: api_1.SpanKind.PRODUCER,
            attributes: {
                [v3_1.SemanticInternalAttributes.STYLE_ICON]: "trigger",
            },
        });
    }
    else {
        // Stream path: convert to AsyncIterable and transform
        const streamItems = items;
        const asyncItems = normalizeToAsyncIterable(streamItems);
        const transformedItems = transformBatchByTaskItemsStreamForWait(asyncItems, options);
        return await tracer_js_1.tracer.startActiveSpan("batch.triggerByTaskAndWait()", async (span) => {
            // Execute streaming 2-phase batch
            const response = await executeBatchTwoPhaseStreaming(apiClient, transformedItems, {
                parentRunId: ctx.run.id,
                resumeParentOnCompletion: true,
                idempotencyKey: await (0, v3_1.makeIdempotencyKey)(options?.idempotencyKey),
                spanParentAsLink: false, // Waiting: child runs share parent's trace ID
            }, requestOptions);
            span.setAttribute("batchId", response.id);
            span.setAttribute("runCount", response.runCount);
            const result = await v3_1.runtime.waitForBatch({
                id: response.id,
                runCount: response.runCount,
                ctx,
            });
            const runs = await handleBatchTaskRunExecutionResultV2(result.items);
            return {
                id: result.id,
                runs,
            };
        }, {
            kind: api_1.SpanKind.PRODUCER,
            attributes: {
                [v3_1.SemanticInternalAttributes.STYLE_ICON]: "trigger",
            },
        });
    }
}
/**
 * Helper function that executes a 2-phase batch trigger:
 * 1. Creates the batch record with expected run count
 * 2. Streams items as NDJSON to the server
 *
 * @param apiClient - The API client instance
 * @param items - Array of batch items
 * @param options - Batch options including trace context settings
 * @param options.spanParentAsLink - If true, child runs will have separate trace IDs with a link to parent.
 *                                   Use true for batchTrigger (fire-and-forget), false for batchTriggerAndWait.
 * @param requestOptions - Optional request options
 * @internal
 */
async function executeBatchTwoPhase(apiClient, items, options, requestOptions) {
    let batch;
    try {
        // Phase 1: Create batch
        batch = await apiClient.createBatch({
            runCount: items.length,
            parentRunId: options.parentRunId,
            resumeParentOnCompletion: options.resumeParentOnCompletion,
            idempotencyKey: options.idempotencyKey,
            idempotencyKeyOptions: options.idempotencyKeyOptions,
        }, { spanParentAsLink: options.spanParentAsLink }, requestOptions);
    }
    catch (error) {
        // Wrap with context about which phase failed
        throw new BatchTriggerError(`Failed to create batch with ${items.length} items`, {
            cause: error,
            phase: "create",
            itemCount: items.length,
        });
    }
    // If the batch was cached (idempotent replay), skip streaming items
    if (!batch.isCached) {
        try {
            // Phase 2: Stream items
            await apiClient.streamBatchItems(batch.id, items, requestOptions);
        }
        catch (error) {
            // Wrap with context about which phase failed and include batch ID
            throw new BatchTriggerError(`Failed to stream items for batch ${batch.id} (${items.length} items)`, { cause: error, phase: "stream", batchId: batch.id, itemCount: items.length });
        }
    }
    return {
        id: batch.id,
        runCount: batch.runCount,
        publicAccessToken: batch.publicAccessToken,
    };
}
/**
 * Error thrown when batch trigger operations fail.
 * Includes context about which phase failed and the batch details.
 *
 * When the underlying error is a rate limit (429), additional properties are exposed:
 * - `isRateLimited`: true
 * - `retryAfterMs`: milliseconds until the rate limit resets
 */
class BatchTriggerError extends Error {
    phase;
    batchId;
    itemCount;
    /** True if the error was caused by rate limiting (HTTP 429) */
    isRateLimited;
    /** Milliseconds until the rate limit resets. Only set when `isRateLimited` is true. */
    retryAfterMs;
    /** The underlying API error, if the cause was an ApiError */
    apiError;
    /** The underlying cause of the error */
    cause;
    constructor(message, options) {
        // Build enhanced message that includes the cause's message
        const fullMessage = buildBatchErrorMessage(message, options.cause);
        super(fullMessage, { cause: options.cause });
        this.name = "BatchTriggerError";
        this.cause = options.cause;
        this.phase = options.phase;
        this.batchId = options.batchId;
        this.itemCount = options.itemCount;
        // Extract rate limit info from cause
        if (options.cause instanceof v3_1.RateLimitError) {
            this.isRateLimited = true;
            this.retryAfterMs = options.cause.millisecondsUntilReset;
            this.apiError = options.cause;
        }
        else if (options.cause instanceof v3_1.ApiError) {
            this.isRateLimited = options.cause.status === 429;
            this.apiError = options.cause;
        }
        else {
            this.isRateLimited = false;
        }
    }
}
exports.BatchTriggerError = BatchTriggerError;
/**
 * Build an enhanced error message that includes context from the cause.
 */
function buildBatchErrorMessage(baseMessage, cause) {
    if (!cause) {
        return baseMessage;
    }
    // Handle RateLimitError specifically for better messaging
    if (cause instanceof v3_1.RateLimitError) {
        const retryMs = cause.millisecondsUntilReset;
        if (retryMs !== undefined) {
            const retrySeconds = Math.ceil(retryMs / 1000);
            return `${baseMessage}: Rate limit exceeded - retry after ${retrySeconds}s`;
        }
        return `${baseMessage}: Rate limit exceeded`;
    }
    // Handle other ApiErrors
    if (cause instanceof v3_1.ApiError) {
        return `${baseMessage}: ${cause.message}`;
    }
    // Handle generic errors
    if (cause instanceof Error) {
        return `${baseMessage}: ${cause.message}`;
    }
    return baseMessage;
}
/**
 * Execute a streaming 2-phase batch trigger where items are streamed from an AsyncIterable.
 * Unlike executeBatchTwoPhase, this doesn't know the count upfront.
 *
 * @param apiClient - The API client instance
 * @param items - AsyncIterable of batch items
 * @param options - Batch options including trace context settings
 * @param options.spanParentAsLink - If true, child runs will have separate trace IDs with a link to parent.
 *                                   Use true for batchTrigger (fire-and-forget), false for batchTriggerAndWait.
 * @param requestOptions - Optional request options
 * @internal
 */
async function executeBatchTwoPhaseStreaming(apiClient, items, options, requestOptions) {
    // For streaming, we need to buffer items to get the count first
    // This is because createBatch requires runCount upfront
    // In the future, we could add a streaming-first endpoint that doesn't require this
    const itemsArray = [];
    for await (const item of items) {
        itemsArray.push(item);
    }
    // Now we can use the regular 2-phase approach
    return executeBatchTwoPhase(apiClient, itemsArray, options, requestOptions);
}
// ============================================================================
// Streaming Helpers
// ============================================================================
/**
 * Type guard to check if a value is an AsyncIterable
 */
function isAsyncIterable(value) {
    return (value != null &&
        typeof value === "object" &&
        Symbol.asyncIterator in value &&
        typeof value[Symbol.asyncIterator] === "function");
}
/**
 * Type guard to check if a value is a ReadableStream
 */
function isReadableStream(value) {
    return (value != null &&
        typeof value === "object" &&
        "getReader" in value &&
        typeof value.getReader === "function");
}
/**
 * Convert a ReadableStream to an AsyncIterable.
 * Properly cancels the stream when the consumer terminates early.
 *
 * @internal Exported for testing purposes
 */
async function* readableStreamToAsyncIterable(stream) {
    const reader = stream.getReader();
    try {
        while (true) {
            const { done, value } = await reader.read();
            if (done)
                break;
            yield value;
        }
    }
    finally {
        try {
            await reader.cancel();
        }
        catch {
            // Ignore errors - stream might already be errored or closed
        }
        reader.releaseLock();
    }
}
/**
 * Normalize stream input to AsyncIterable
 */
function normalizeToAsyncIterable(input) {
    if (isReadableStream(input)) {
        return readableStreamToAsyncIterable(input);
    }
    return input;
}
/**
 * Transform a stream of BatchByIdItem to BatchItemNDJSON format.
 * Handles payload serialization and idempotency key generation.
 *
 * @internal
 */
async function* transformBatchItemsStream(items, options) {
    let index = 0;
    for await (const item of items) {
        const taskMetadata = v3_1.resourceCatalog.getTask(item.id);
        const parsedPayload = taskMetadata?.fns.parsePayload
            ? await taskMetadata?.fns.parsePayload(item.payload)
            : item.payload;
        const payloadPacket = await (0, v3_1.stringifyIO)(parsedPayload);
        const batchItemIdempotencyKey = await (0, v3_1.makeIdempotencyKey)((0, v3_1.flattenIdempotencyKey)([options?.idempotencyKey, `${index}`]));
        yield {
            index: index++,
            task: item.id,
            payload: payloadPacket.data,
            options: {
                queue: item.options?.queue ? { name: item.options.queue } : undefined,
                concurrencyKey: item.options?.concurrencyKey,
                test: v3_1.taskContext.ctx?.run.isTest,
                payloadType: payloadPacket.dataType,
                delay: item.options?.delay,
                ttl: item.options?.ttl,
                tags: item.options?.tags,
                maxAttempts: item.options?.maxAttempts,
                metadata: item.options?.metadata,
                maxDuration: item.options?.maxDuration,
                idempotencyKey: (await (0, v3_1.makeIdempotencyKey)(item.options?.idempotencyKey)) ?? batchItemIdempotencyKey,
                idempotencyKeyTTL: item.options?.idempotencyKeyTTL ?? options?.idempotencyKeyTTL,
                machine: item.options?.machine,
                priority: item.options?.priority,
                region: item.options?.region,
                lockToVersion: item.options?.version ?? (0, v3_1.getEnvVar)("TRIGGER_VERSION"),
                debounce: item.options?.debounce,
            },
        };
    }
}
/**
 * Transform a stream of BatchByIdAndWaitItem to BatchItemNDJSON format for triggerAndWait.
 * Uses the current worker version for lockToVersion.
 *
 * @internal
 */
async function* transformBatchItemsStreamForWait(items, options) {
    let index = 0;
    for await (const item of items) {
        const taskMetadata = v3_1.resourceCatalog.getTask(item.id);
        const parsedPayload = taskMetadata?.fns.parsePayload
            ? await taskMetadata?.fns.parsePayload(item.payload)
            : item.payload;
        const payloadPacket = await (0, v3_1.stringifyIO)(parsedPayload);
        const batchItemIdempotencyKey = await (0, v3_1.makeIdempotencyKey)((0, v3_1.flattenIdempotencyKey)([options?.idempotencyKey, `${index}`]));
        yield {
            index: index++,
            task: item.id,
            payload: payloadPacket.data,
            options: {
                lockToVersion: v3_1.taskContext.worker?.version,
                queue: item.options?.queue ? { name: item.options.queue } : undefined,
                concurrencyKey: item.options?.concurrencyKey,
                test: v3_1.taskContext.ctx?.run.isTest,
                payloadType: payloadPacket.dataType,
                delay: item.options?.delay,
                ttl: item.options?.ttl,
                tags: item.options?.tags,
                maxAttempts: item.options?.maxAttempts,
                metadata: item.options?.metadata,
                maxDuration: item.options?.maxDuration,
                idempotencyKey: (await (0, v3_1.makeIdempotencyKey)(item.options?.idempotencyKey)) ?? batchItemIdempotencyKey,
                idempotencyKeyTTL: item.options?.idempotencyKeyTTL ?? options?.idempotencyKeyTTL,
                machine: item.options?.machine,
                priority: item.options?.priority,
                region: item.options?.region,
                debounce: item.options?.debounce,
            },
        };
    }
}
/**
 * Transform a stream of BatchByTaskItem to BatchItemNDJSON format.
 *
 * @internal
 */
async function* transformBatchByTaskItemsStream(items, options) {
    let index = 0;
    for await (const item of items) {
        const taskMetadata = v3_1.resourceCatalog.getTask(item.task.id);
        const parsedPayload = taskMetadata?.fns.parsePayload
            ? await taskMetadata?.fns.parsePayload(item.payload)
            : item.payload;
        const payloadPacket = await (0, v3_1.stringifyIO)(parsedPayload);
        const batchItemIdempotencyKey = await (0, v3_1.makeIdempotencyKey)((0, v3_1.flattenIdempotencyKey)([options?.idempotencyKey, `${index}`]));
        yield {
            index: index++,
            task: item.task.id,
            payload: payloadPacket.data,
            options: {
                queue: item.options?.queue ? { name: item.options.queue } : undefined,
                concurrencyKey: item.options?.concurrencyKey,
                test: v3_1.taskContext.ctx?.run.isTest,
                payloadType: payloadPacket.dataType,
                delay: item.options?.delay,
                ttl: item.options?.ttl,
                tags: item.options?.tags,
                maxAttempts: item.options?.maxAttempts,
                metadata: item.options?.metadata,
                maxDuration: item.options?.maxDuration,
                idempotencyKey: (await (0, v3_1.makeIdempotencyKey)(item.options?.idempotencyKey)) ?? batchItemIdempotencyKey,
                idempotencyKeyTTL: item.options?.idempotencyKeyTTL ?? options?.idempotencyKeyTTL,
                machine: item.options?.machine,
                priority: item.options?.priority,
                region: item.options?.region,
                lockToVersion: item.options?.version ?? (0, v3_1.getEnvVar)("TRIGGER_VERSION"),
                debounce: item.options?.debounce,
            },
        };
    }
}
/**
 * Transform a stream of BatchByTaskAndWaitItem to BatchItemNDJSON format for triggerAndWait.
 *
 * @internal
 */
async function* transformBatchByTaskItemsStreamForWait(items, options) {
    let index = 0;
    for await (const item of items) {
        const taskMetadata = v3_1.resourceCatalog.getTask(item.task.id);
        const parsedPayload = taskMetadata?.fns.parsePayload
            ? await taskMetadata?.fns.parsePayload(item.payload)
            : item.payload;
        const payloadPacket = await (0, v3_1.stringifyIO)(parsedPayload);
        const batchItemIdempotencyKey = await (0, v3_1.makeIdempotencyKey)((0, v3_1.flattenIdempotencyKey)([options?.idempotencyKey, `${index}`]));
        yield {
            index: index++,
            task: item.task.id,
            payload: payloadPacket.data,
            options: {
                lockToVersion: v3_1.taskContext.worker?.version,
                queue: item.options?.queue ? { name: item.options.queue } : undefined,
                concurrencyKey: item.options?.concurrencyKey,
                test: v3_1.taskContext.ctx?.run.isTest,
                payloadType: payloadPacket.dataType,
                delay: item.options?.delay,
                ttl: item.options?.ttl,
                tags: item.options?.tags,
                maxAttempts: item.options?.maxAttempts,
                metadata: item.options?.metadata,
                maxDuration: item.options?.maxDuration,
                idempotencyKey: (await (0, v3_1.makeIdempotencyKey)(item.options?.idempotencyKey)) ?? batchItemIdempotencyKey,
                idempotencyKeyTTL: item.options?.idempotencyKeyTTL ?? options?.idempotencyKeyTTL,
                machine: item.options?.machine,
                priority: item.options?.priority,
                region: item.options?.region,
                debounce: item.options?.debounce,
            },
        };
    }
}
/**
 * Transform a stream of BatchItem (single task type) to BatchItemNDJSON format.
 *
 * @internal
 */
async function* transformSingleTaskBatchItemsStream(taskIdentifier, items, parsePayload, options, queue) {
    let index = 0;
    for await (const item of items) {
        const parsedPayload = parsePayload ? await parsePayload(item.payload) : item.payload;
        const payloadPacket = await (0, v3_1.stringifyIO)(parsedPayload);
        const batchItemIdempotencyKey = await (0, v3_1.makeIdempotencyKey)((0, v3_1.flattenIdempotencyKey)([options?.idempotencyKey, `${index}`]));
        yield {
            index: index++,
            task: taskIdentifier,
            payload: payloadPacket.data,
            options: {
                queue: item.options?.queue
                    ? { name: item.options.queue }
                    : queue
                        ? { name: queue }
                        : undefined,
                concurrencyKey: item.options?.concurrencyKey,
                test: v3_1.taskContext.ctx?.run.isTest,
                payloadType: payloadPacket.dataType,
                delay: item.options?.delay,
                ttl: item.options?.ttl,
                tags: item.options?.tags,
                maxAttempts: item.options?.maxAttempts,
                metadata: item.options?.metadata,
                maxDuration: item.options?.maxDuration,
                idempotencyKey: (await (0, v3_1.makeIdempotencyKey)(item.options?.idempotencyKey)) ?? batchItemIdempotencyKey,
                idempotencyKeyTTL: item.options?.idempotencyKeyTTL ?? options?.idempotencyKeyTTL,
                machine: item.options?.machine,
                priority: item.options?.priority,
                region: item.options?.region,
                lockToVersion: item.options?.version ?? (0, v3_1.getEnvVar)("TRIGGER_VERSION"),
                debounce: item.options?.debounce,
            },
        };
    }
}
/**
 * Transform a stream of BatchTriggerAndWaitItem (single task type) to BatchItemNDJSON format.
 *
 * @internal
 */
async function* transformSingleTaskBatchItemsStreamForWait(taskIdentifier, items, parsePayload, options, queue) {
    let index = 0;
    for await (const item of items) {
        const parsedPayload = parsePayload ? await parsePayload(item.payload) : item.payload;
        const payloadPacket = await (0, v3_1.stringifyIO)(parsedPayload);
        const batchItemIdempotencyKey = await (0, v3_1.makeIdempotencyKey)((0, v3_1.flattenIdempotencyKey)([options?.idempotencyKey, `${index}`]));
        // Process item-specific idempotency key and extract options
        const itemIdempotencyKey = await (0, v3_1.makeIdempotencyKey)(item.options?.idempotencyKey);
        const finalIdempotencyKey = itemIdempotencyKey ?? batchItemIdempotencyKey;
        const idempotencyKeyOptions = itemIdempotencyKey
            ? (0, v3_1.getIdempotencyKeyOptions)(itemIdempotencyKey)
            : undefined;
        yield {
            index: index++,
            task: taskIdentifier,
            payload: payloadPacket.data,
            options: {
                lockToVersion: v3_1.taskContext.worker?.version,
                queue: item.options?.queue
                    ? { name: item.options.queue }
                    : queue
                        ? { name: queue }
                        : undefined,
                concurrencyKey: item.options?.concurrencyKey,
                test: v3_1.taskContext.ctx?.run.isTest,
                payloadType: payloadPacket.dataType,
                delay: item.options?.delay,
                ttl: item.options?.ttl,
                tags: item.options?.tags,
                maxAttempts: item.options?.maxAttempts,
                metadata: item.options?.metadata,
                maxDuration: item.options?.maxDuration,
                idempotencyKey: finalIdempotencyKey?.toString(),
                idempotencyKeyTTL: item.options?.idempotencyKeyTTL ?? options?.idempotencyKeyTTL,
                idempotencyKeyOptions,
                machine: item.options?.machine,
                priority: item.options?.priority,
                region: item.options?.region,
                debounce: item.options?.debounce,
            },
        };
    }
}
async function trigger_internal(name, id, payload, parsePayload, options, requestOptions) {
    const apiClient = v3_1.apiClientManager.clientOrThrow(requestOptions?.clientConfig);
    const parsedPayload = parsePayload ? await parsePayload(payload) : payload;
    const payloadPacket = await (0, v3_1.stringifyIO)(parsedPayload);
    // Process idempotency key and extract options for storage
    const processedIdempotencyKey = await (0, v3_1.makeIdempotencyKey)(options?.idempotencyKey);
    const idempotencyKeyOptions = processedIdempotencyKey
        ? (0, v3_1.getIdempotencyKeyOptions)(processedIdempotencyKey)
        : undefined;
    const handle = await apiClient.triggerTask(id, {
        payload: payloadPacket.data,
        options: {
            queue: options?.queue ? { name: options.queue } : undefined,
            concurrencyKey: options?.concurrencyKey,
            test: v3_1.taskContext.ctx?.run.isTest,
            payloadType: payloadPacket.dataType,
            idempotencyKey: processedIdempotencyKey?.toString(),
            idempotencyKeyTTL: options?.idempotencyKeyTTL,
            idempotencyKeyOptions,
            delay: options?.delay,
            ttl: options?.ttl,
            tags: options?.tags,
            maxAttempts: options?.maxAttempts,
            metadata: options?.metadata,
            maxDuration: options?.maxDuration,
            parentRunId: v3_1.taskContext.ctx?.run.id,
            machine: options?.machine,
            priority: options?.priority,
            region: options?.region,
            lockToVersion: options?.version ?? (0, v3_1.getEnvVar)("TRIGGER_VERSION"),
            debounce: options?.debounce,
        },
    }, {
        spanParentAsLink: true,
    }, {
        name,
        tracer: tracer_js_1.tracer,
        icon: "trigger",
        onResponseBody: (body, span) => {
            if (body && typeof body === "object" && !Array.isArray(body)) {
                if ("id" in body && typeof body.id === "string") {
                    span.setAttribute("runId", body.id);
                }
            }
        },
        ...requestOptions,
    });
    return handle;
}
async function batchTrigger_internal(name, taskIdentifier, items, options, parsePayload, requestOptions, queue) {
    const apiClient = v3_1.apiClientManager.clientOrThrow(requestOptions?.clientConfig);
    const ctx = v3_1.taskContext.ctx;
    // Check if items is an array or a stream
    if (Array.isArray(items)) {
        // Prepare items as BatchItemNDJSON
        const ndJsonItems = await Promise.all(items.map(async (item, index) => {
            const parsedPayload = parsePayload ? await parsePayload(item.payload) : item.payload;
            const payloadPacket = await (0, v3_1.stringifyIO)(parsedPayload);
            const batchItemIdempotencyKey = await (0, v3_1.makeIdempotencyKey)((0, v3_1.flattenIdempotencyKey)([options?.idempotencyKey, `${index}`]));
            // Process item-specific idempotency key and extract options
            const itemIdempotencyKey = await (0, v3_1.makeIdempotencyKey)(item.options?.idempotencyKey);
            const finalIdempotencyKey = itemIdempotencyKey ?? batchItemIdempotencyKey;
            const idempotencyKeyOptions = itemIdempotencyKey
                ? (0, v3_1.getIdempotencyKeyOptions)(itemIdempotencyKey)
                : undefined;
            return {
                index,
                task: taskIdentifier,
                payload: payloadPacket.data,
                options: {
                    queue: item.options?.queue
                        ? { name: item.options.queue }
                        : queue
                            ? { name: queue }
                            : undefined,
                    concurrencyKey: item.options?.concurrencyKey,
                    test: v3_1.taskContext.ctx?.run.isTest,
                    payloadType: payloadPacket.dataType,
                    delay: item.options?.delay,
                    ttl: item.options?.ttl,
                    tags: item.options?.tags,
                    maxAttempts: item.options?.maxAttempts,
                    metadata: item.options?.metadata,
                    maxDuration: item.options?.maxDuration,
                    idempotencyKey: finalIdempotencyKey?.toString(),
                    idempotencyKeyTTL: item.options?.idempotencyKeyTTL ?? options?.idempotencyKeyTTL,
                    idempotencyKeyOptions,
                    machine: item.options?.machine,
                    priority: item.options?.priority,
                    region: item.options?.region,
                    lockToVersion: item.options?.version ?? (0, v3_1.getEnvVar)("TRIGGER_VERSION"),
                },
            };
        }));
        // Execute 2-phase batch
        // Process batch-level idempotency key
        const batchIdempotencyKey = await (0, v3_1.makeIdempotencyKey)(options?.idempotencyKey);
        const batchIdempotencyKeyOptions = batchIdempotencyKey
            ? (0, v3_1.getIdempotencyKeyOptions)(batchIdempotencyKey)
            : undefined;
        const response = await tracer_js_1.tracer.startActiveSpan(name, async (span) => {
            const result = await executeBatchTwoPhase(apiClient, ndJsonItems, {
                parentRunId: ctx?.run.id,
                idempotencyKey: batchIdempotencyKey?.toString(),
                idempotencyKeyOptions: batchIdempotencyKeyOptions,
                spanParentAsLink: true, // Fire-and-forget: child runs get separate trace IDs
            }, requestOptions);
            span.setAttribute("batchId", result.id);
            span.setAttribute("runCount", result.runCount);
            return result;
        }, {
            kind: api_1.SpanKind.PRODUCER,
            attributes: {
                [v3_1.SemanticInternalAttributes.STYLE_ICON]: "trigger",
                ...(0, v3_1.accessoryAttributes)({
                    items: [
                        {
                            text: taskIdentifier,
                            variant: "normal",
                        },
                    ],
                    style: "codepath",
                }),
            },
        });
        const handle = {
            batchId: response.id,
            runCount: response.runCount,
            publicAccessToken: response.publicAccessToken,
        };
        return handle;
    }
    else {
        // Stream path: convert to AsyncIterable and transform
        const asyncItems = normalizeToAsyncIterable(items);
        const transformedItems = transformSingleTaskBatchItemsStream(taskIdentifier, asyncItems, parsePayload, options, queue);
        // Execute streaming 2-phase batch
        // Process batch-level idempotency key
        const streamBatchIdempotencyKey = await (0, v3_1.makeIdempotencyKey)(options?.idempotencyKey);
        const streamBatchIdempotencyKeyOptions = streamBatchIdempotencyKey
            ? (0, v3_1.getIdempotencyKeyOptions)(streamBatchIdempotencyKey)
            : undefined;
        const response = await tracer_js_1.tracer.startActiveSpan(name, async (span) => {
            const result = await executeBatchTwoPhaseStreaming(apiClient, transformedItems, {
                parentRunId: ctx?.run.id,
                idempotencyKey: streamBatchIdempotencyKey?.toString(),
                idempotencyKeyOptions: streamBatchIdempotencyKeyOptions,
                spanParentAsLink: true, // Fire-and-forget: child runs get separate trace IDs
            }, requestOptions);
            span.setAttribute("batchId", result.id);
            span.setAttribute("runCount", result.runCount);
            return result;
        }, {
            kind: api_1.SpanKind.PRODUCER,
            attributes: {
                [v3_1.SemanticInternalAttributes.STYLE_ICON]: "trigger",
                ...(0, v3_1.accessoryAttributes)({
                    items: [
                        {
                            text: taskIdentifier,
                            variant: "normal",
                        },
                    ],
                    style: "codepath",
                }),
            },
        });
        const handle = {
            batchId: response.id,
            runCount: response.runCount,
            publicAccessToken: response.publicAccessToken,
        };
        return handle;
    }
}
async function triggerAndWait_internal(name, id, payload, parsePayload, options, requestOptions) {
    const ctx = v3_1.taskContext.ctx;
    if (!ctx) {
        throw new Error("triggerAndWait can only be used from inside a task.run()");
    }
    const apiClient = v3_1.apiClientManager.clientOrThrow(requestOptions?.clientConfig);
    const parsedPayload = parsePayload ? await parsePayload(payload) : payload;
    const payloadPacket = await (0, v3_1.stringifyIO)(parsedPayload);
    // Process idempotency key and extract options for storage
    const processedIdempotencyKey = await (0, v3_1.makeIdempotencyKey)(options?.idempotencyKey);
    const idempotencyKeyOptions = processedIdempotencyKey
        ? (0, v3_1.getIdempotencyKeyOptions)(processedIdempotencyKey)
        : undefined;
    return await tracer_js_1.tracer.startActiveSpan(name, async (span) => {
        const response = await apiClient.triggerTask(id, {
            payload: payloadPacket.data,
            options: {
                lockToVersion: v3_1.taskContext.worker?.version, // Lock to current version because we're waiting for it to finish
                queue: options?.queue ? { name: options.queue } : undefined,
                concurrencyKey: options?.concurrencyKey,
                test: v3_1.taskContext.ctx?.run.isTest,
                payloadType: payloadPacket.dataType,
                delay: options?.delay,
                ttl: options?.ttl,
                tags: options?.tags,
                maxAttempts: options?.maxAttempts,
                metadata: options?.metadata,
                maxDuration: options?.maxDuration,
                resumeParentOnCompletion: true,
                parentRunId: ctx.run.id,
                idempotencyKey: processedIdempotencyKey?.toString(),
                idempotencyKeyTTL: options?.idempotencyKeyTTL,
                idempotencyKeyOptions,
                machine: options?.machine,
                priority: options?.priority,
                region: options?.region,
                debounce: options?.debounce,
            },
        }, {}, requestOptions);
        span.setAttribute("runId", response.id);
        const result = await v3_1.runtime.waitForTask({
            id: response.id,
            ctx,
        });
        return await handleTaskRunExecutionResult(result, id);
    }, {
        kind: api_1.SpanKind.PRODUCER,
        attributes: {
            [v3_1.SemanticInternalAttributes.STYLE_ICON]: "trigger",
            ...(0, v3_1.accessoryAttributes)({
                items: [
                    {
                        text: id,
                        variant: "normal",
                    },
                ],
                style: "codepath",
            }),
        },
    });
}
async function batchTriggerAndWait_internal(name, id, items, parsePayload, options, requestOptions, queue) {
    const ctx = v3_1.taskContext.ctx;
    if (!ctx) {
        throw new Error("batchTriggerAndWait can only be used from inside a task.run()");
    }
    const apiClient = v3_1.apiClientManager.clientOrThrow(requestOptions?.clientConfig);
    // Check if items is an array or a stream
    if (Array.isArray(items)) {
        // Prepare items as BatchItemNDJSON
        const ndJsonItems = await Promise.all(items.map(async (item, index) => {
            const parsedPayload = parsePayload ? await parsePayload(item.payload) : item.payload;
            const payloadPacket = await (0, v3_1.stringifyIO)(parsedPayload);
            const batchItemIdempotencyKey = await (0, v3_1.makeIdempotencyKey)((0, v3_1.flattenIdempotencyKey)([options?.idempotencyKey, `${index}`]));
            // Process item-specific idempotency key and extract options
            const itemIdempotencyKey = await (0, v3_1.makeIdempotencyKey)(item.options?.idempotencyKey);
            const finalIdempotencyKey = itemIdempotencyKey ?? batchItemIdempotencyKey;
            const idempotencyKeyOptions = itemIdempotencyKey
                ? (0, v3_1.getIdempotencyKeyOptions)(itemIdempotencyKey)
                : undefined;
            return {
                index,
                task: id,
                payload: payloadPacket.data,
                options: {
                    lockToVersion: v3_1.taskContext.worker?.version,
                    queue: item.options?.queue
                        ? { name: item.options.queue }
                        : queue
                            ? { name: queue }
                            : undefined,
                    concurrencyKey: item.options?.concurrencyKey,
                    test: v3_1.taskContext.ctx?.run.isTest,
                    payloadType: payloadPacket.dataType,
                    delay: item.options?.delay,
                    ttl: item.options?.ttl,
                    tags: item.options?.tags,
                    maxAttempts: item.options?.maxAttempts,
                    metadata: item.options?.metadata,
                    maxDuration: item.options?.maxDuration,
                    idempotencyKey: finalIdempotencyKey?.toString(),
                    idempotencyKeyTTL: item.options?.idempotencyKeyTTL ?? options?.idempotencyKeyTTL,
                    idempotencyKeyOptions,
                    machine: item.options?.machine,
                    priority: item.options?.priority,
                    region: item.options?.region,
                },
            };
        }));
        // Process batch-level idempotency key
        const batchIdempotencyKey = await (0, v3_1.makeIdempotencyKey)(options?.idempotencyKey);
        const batchIdempotencyKeyOptions = batchIdempotencyKey
            ? (0, v3_1.getIdempotencyKeyOptions)(batchIdempotencyKey)
            : undefined;
        return await tracer_js_1.tracer.startActiveSpan(name, async (span) => {
            // Execute 2-phase batch
            const response = await executeBatchTwoPhase(apiClient, ndJsonItems, {
                parentRunId: ctx.run.id,
                resumeParentOnCompletion: true,
                idempotencyKey: batchIdempotencyKey?.toString(),
                idempotencyKeyOptions: batchIdempotencyKeyOptions,
                spanParentAsLink: false, // Waiting: child runs share parent's trace ID
            }, requestOptions);
            span.setAttribute("batchId", response.id);
            span.setAttribute("runCount", response.runCount);
            const result = await v3_1.runtime.waitForBatch({
                id: response.id,
                runCount: response.runCount,
                ctx,
            });
            const runs = await handleBatchTaskRunExecutionResult(result.items, id);
            return {
                id: result.id,
                runs,
            };
        }, {
            kind: api_1.SpanKind.PRODUCER,
            attributes: {
                [v3_1.SemanticInternalAttributes.STYLE_ICON]: "trigger",
                ...(0, v3_1.accessoryAttributes)({
                    items: [
                        {
                            text: id,
                            variant: "normal",
                        },
                    ],
                    style: "codepath",
                }),
            },
        });
    }
    else {
        // Stream path: convert to AsyncIterable and transform
        const asyncItems = normalizeToAsyncIterable(items);
        const transformedItems = transformSingleTaskBatchItemsStreamForWait(id, asyncItems, parsePayload, options, queue);
        // Process batch-level idempotency key for streaming path
        const streamBatchIdempotencyKey = await (0, v3_1.makeIdempotencyKey)(options?.idempotencyKey);
        const streamBatchIdempotencyKeyOptions = streamBatchIdempotencyKey
            ? (0, v3_1.getIdempotencyKeyOptions)(streamBatchIdempotencyKey)
            : undefined;
        return await tracer_js_1.tracer.startActiveSpan(name, async (span) => {
            // Execute streaming 2-phase batch
            const response = await executeBatchTwoPhaseStreaming(apiClient, transformedItems, {
                parentRunId: ctx.run.id,
                resumeParentOnCompletion: true,
                idempotencyKey: streamBatchIdempotencyKey?.toString(),
                idempotencyKeyOptions: streamBatchIdempotencyKeyOptions,
                spanParentAsLink: false, // Waiting: child runs share parent's trace ID
            }, requestOptions);
            span.setAttribute("batchId", response.id);
            span.setAttribute("runCount", response.runCount);
            const result = await v3_1.runtime.waitForBatch({
                id: response.id,
                runCount: response.runCount,
                ctx,
            });
            const runs = await handleBatchTaskRunExecutionResult(result.items, id);
            return {
                id: result.id,
                runs,
            };
        }, {
            kind: api_1.SpanKind.PRODUCER,
            attributes: {
                [v3_1.SemanticInternalAttributes.STYLE_ICON]: "trigger",
                ...(0, v3_1.accessoryAttributes)({
                    items: [
                        {
                            text: id,
                            variant: "normal",
                        },
                    ],
                    style: "codepath",
                }),
            },
        });
    }
}
async function handleBatchTaskRunExecutionResult(items, taskIdentifier) {
    const someObjectStoreOutputs = items.some((item) => item.ok && item.outputType === "application/store");
    if (!someObjectStoreOutputs) {
        const results = await Promise.all(items.map(async (item) => {
            return await handleTaskRunExecutionResult(item, taskIdentifier);
        }));
        return results;
    }
    return await tracer_js_1.tracer.startActiveSpan("store.downloadPayloads", async (span) => {
        const results = await Promise.all(items.map(async (item) => {
            return await handleTaskRunExecutionResult(item, taskIdentifier);
        }));
        return results;
    }, {
        kind: api_1.SpanKind.INTERNAL,
        [v3_1.SemanticInternalAttributes.STYLE_ICON]: "cloud-download",
    });
}
async function handleBatchTaskRunExecutionResultV2(items) {
    const someObjectStoreOutputs = items.some((item) => item.ok && item.outputType === "application/store");
    if (!someObjectStoreOutputs) {
        const results = await Promise.all(items.map(async (item) => {
            return await handleTaskRunExecutionResult(item, item.taskIdentifier ?? "unknown");
        }));
        return results;
    }
    return await tracer_js_1.tracer.startActiveSpan("store.downloadPayloads", async (span) => {
        const results = await Promise.all(items.map(async (item) => {
            return await handleTaskRunExecutionResult(item, item.taskIdentifier ?? "unknown");
        }));
        return results;
    }, {
        kind: api_1.SpanKind.INTERNAL,
        [v3_1.SemanticInternalAttributes.STYLE_ICON]: "cloud-download",
    });
}
async function handleTaskRunExecutionResult(execution, taskIdentifier) {
    if (execution.ok) {
        const outputPacket = { data: execution.output, dataType: execution.outputType };
        const importedPacket = await (0, v3_1.conditionallyImportPacket)(outputPacket, tracer_js_1.tracer);
        return {
            ok: true,
            id: execution.id,
            taskIdentifier: (execution.taskIdentifier ?? taskIdentifier),
            output: await (0, v3_1.parsePacket)(importedPacket),
        };
    }
    else {
        return {
            ok: false,
            id: execution.id,
            taskIdentifier: (execution.taskIdentifier ?? taskIdentifier),
            error: (0, v3_1.createErrorTaskError)(execution.error),
        };
    }
}
function registerTaskLifecycleHooks(taskId, params) {
    if (params.init) {
        v3_1.lifecycleHooks.registerTaskInitHook(taskId, {
            fn: params.init,
        });
    }
    if (params.onStart) {
        v3_1.lifecycleHooks.registerTaskStartHook(taskId, {
            fn: params.onStart,
        });
    }
    if (params.onStartAttempt) {
        v3_1.lifecycleHooks.registerTaskStartAttemptHook(taskId, {
            fn: params.onStartAttempt,
        });
    }
    if (params.onFailure) {
        v3_1.lifecycleHooks.registerTaskFailureHook(taskId, {
            fn: params.onFailure,
        });
    }
    if (params.onSuccess) {
        v3_1.lifecycleHooks.registerTaskSuccessHook(taskId, {
            fn: params.onSuccess,
        });
    }
    if (params.onComplete) {
        v3_1.lifecycleHooks.registerTaskCompleteHook(taskId, {
            fn: params.onComplete,
        });
    }
    if (params.onWait) {
        v3_1.lifecycleHooks.registerTaskWaitHook(taskId, {
            fn: params.onWait,
        });
    }
    if (params.onResume) {
        v3_1.lifecycleHooks.registerTaskResumeHook(taskId, {
            fn: params.onResume,
        });
    }
    if (params.catchError) {
        // We don't need to use an adapter here because catchError is the new version of handleError
        v3_1.lifecycleHooks.registerTaskCatchErrorHook(taskId, {
            fn: params.catchError,
        });
    }
    if (params.handleError) {
        v3_1.lifecycleHooks.registerTaskCatchErrorHook(taskId, {
            fn: params.handleError,
        });
    }
    if (params.middleware) {
        v3_1.lifecycleHooks.registerTaskMiddlewareHook(taskId, {
            fn: params.middleware,
        });
    }
    if (params.cleanup) {
        v3_1.lifecycleHooks.registerTaskCleanupHook(taskId, {
            fn: params.cleanup,
        });
    }
    if (params.onCancel) {
        v3_1.lifecycleHooks.registerTaskCancelHook(taskId, {
            fn: params.onCancel,
        });
    }
}
//# sourceMappingURL=shared.js.map