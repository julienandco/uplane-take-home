"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.streams = void 0;
const v3_1 = require("@trigger.dev/core/v3");
const tracer_js_1 = require("./tracer.js");
const api_1 = require("@opentelemetry/api");
const DEFAULT_STREAM_KEY = "default";
function pipe(keyOrValue, valueOrOptions, options) {
    // Handle overload: pipe(value, options?) or pipe(key, value, options?)
    let key;
    let value;
    let opts;
    if (typeof keyOrValue === "string") {
        // pipe(key, value, options?)
        key = keyOrValue;
        value = valueOrOptions;
        opts = options;
    }
    else {
        // pipe(value, options?)
        key = DEFAULT_STREAM_KEY;
        value = keyOrValue;
        opts = valueOrOptions;
    }
    return pipeInternal(key, value, opts, "streams.pipe()");
}
/**
 * Internal pipe implementation that allows customizing the span name.
 * This is used by both the public `pipe` method and the `writer` method.
 */
function pipeInternal(key, value, opts, spanName) {
    const runId = getRunIdForOptions(opts);
    if (!runId) {
        throw new Error("Could not determine the target run ID for the realtime stream. Please specify a target run ID using the `target` option or use this function from inside a task.");
    }
    const span = tracer_js_1.tracer.startSpan(spanName, {
        attributes: {
            key,
            runId,
            [v3_1.SemanticInternalAttributes.ENTITY_TYPE]: "realtime-stream",
            [v3_1.SemanticInternalAttributes.ENTITY_ID]: `${runId}:${key}`,
            [v3_1.SemanticInternalAttributes.STYLE_ICON]: "streams",
            ...(0, v3_1.accessoryAttributes)({
                items: [
                    {
                        text: key,
                        variant: "normal",
                    },
                ],
                style: "codepath",
            }),
        },
    });
    const requestOptions = (0, v3_1.mergeRequestOptions)({}, opts?.requestOptions);
    try {
        const instance = v3_1.realtimeStreams.pipe(key, value, {
            signal: opts?.signal,
            target: runId,
            requestOptions,
        });
        instance.wait().finally(() => {
            span.end();
        });
        return {
            stream: instance.stream,
            waitUntilComplete: () => instance.wait(),
        };
    }
    catch (error) {
        // if the error is a signal abort error, we need to end the span but not record an exception
        if (error instanceof Error && error.name === "AbortError") {
            span.end();
            throw error;
        }
        if (error instanceof Error || typeof error === "string") {
            span.recordException(error);
        }
        else {
            span.recordException(String(error));
        }
        span.setStatus({ code: api_1.SpanStatusCode.ERROR });
        span.end();
        throw error;
    }
}
async function read(runId, keyOrOptions, options) {
    // Handle overload: read(runId, options?) or read(runId, key, options?)
    let key;
    let opts;
    if (typeof keyOrOptions === "string") {
        // read(runId, key, options?)
        key = keyOrOptions;
        opts = options;
    }
    else {
        // read(runId, options?)
        key = DEFAULT_STREAM_KEY;
        opts = keyOrOptions;
    }
    // Rename to readStream for consistency with existing code
    return readStreamImpl(runId, key, opts);
}
async function readStreamImpl(runId, key, options) {
    const apiClient = v3_1.apiClientManager.clientOrThrow();
    const span = tracer_js_1.tracer.startSpan("streams.read()", {
        attributes: {
            key,
            runId,
            [v3_1.SemanticInternalAttributes.ENTITY_TYPE]: "realtime-stream",
            [v3_1.SemanticInternalAttributes.ENTITY_ID]: `${runId}:${key}`,
            [v3_1.SemanticInternalAttributes.ENTITY_METADATA]: JSON.stringify({
                startIndex: options?.startIndex,
            }),
            [v3_1.SemanticInternalAttributes.STYLE_ICON]: "streams",
            ...(0, v3_1.accessoryAttributes)({
                items: [
                    {
                        text: key,
                        variant: "normal",
                    },
                ],
                style: "codepath",
            }),
        },
    });
    return await apiClient.fetchStream(runId, key, {
        signal: options?.signal,
        timeoutInSeconds: options?.timeoutInSeconds ?? 60,
        lastEventId: options?.startIndex ? (options.startIndex - 1).toString() : undefined,
        onComplete: () => {
            span.end();
        },
        onError: (error) => {
            span.recordException(error);
            span.setStatus({ code: api_1.SpanStatusCode.ERROR });
            span.end();
        },
    });
}
function append(keyOrValue, valueOrOptions, options) {
    if (typeof keyOrValue === "string" && typeof valueOrOptions === "string") {
        return appendInternal(keyOrValue, valueOrOptions, options);
    }
    if (typeof keyOrValue === "string") {
        if (isAppendStreamOptions(valueOrOptions)) {
            return appendInternal(DEFAULT_STREAM_KEY, keyOrValue, valueOrOptions);
        }
        else {
            if (!valueOrOptions) {
                return appendInternal(DEFAULT_STREAM_KEY, keyOrValue, options);
            }
            return appendInternal(keyOrValue, valueOrOptions, options);
        }
    }
    else {
        if (isAppendStreamOptions(valueOrOptions)) {
            return appendInternal(DEFAULT_STREAM_KEY, keyOrValue, valueOrOptions);
        }
        else {
            return appendInternal(DEFAULT_STREAM_KEY, keyOrValue, options);
        }
    }
}
async function appendInternal(key, part, options) {
    const runId = getRunIdForOptions(options);
    if (!runId) {
        throw new Error("Could not determine the target run ID for the realtime stream. Please specify a target run ID using the `target` option or use this function from inside a task.");
    }
    const span = tracer_js_1.tracer.startSpan("streams.append()", {
        attributes: {
            key,
            runId,
            [v3_1.SemanticInternalAttributes.ENTITY_TYPE]: "realtime-stream",
            [v3_1.SemanticInternalAttributes.ENTITY_ID]: `${runId}:${key}`,
            [v3_1.SemanticInternalAttributes.STYLE_ICON]: "streams",
            ...(0, v3_1.accessoryAttributes)({
                items: [
                    {
                        text: key,
                        variant: "normal",
                    },
                ],
                style: "codepath",
            }),
        },
    });
    try {
        await v3_1.realtimeStreams.append(key, part, options);
        span.end();
    }
    catch (error) {
        // if the error is a signal abort error, we need to end the span but not record an exception
        if (error instanceof Error && error.name === "AbortError") {
            span.end();
            throw error;
        }
        if (error instanceof Error || typeof error === "string") {
            span.recordException(error);
        }
        else {
            span.recordException(String(error));
        }
        span.setStatus({ code: api_1.SpanStatusCode.ERROR });
        span.end();
        throw error;
    }
}
function isAppendStreamOptions(val) {
    return (typeof val === "object" &&
        val !== null &&
        !Array.isArray(val) &&
        (("target" in val && typeof val.target === "string") ||
            ("requestOptions" in val && typeof val.requestOptions === "object")));
}
function writer(keyOrOptions, valueOrOptions) {
    if (typeof keyOrOptions === "string") {
        return writerInternal(keyOrOptions, valueOrOptions);
    }
    return writerInternal(DEFAULT_STREAM_KEY, keyOrOptions);
}
function writerInternal(key, options) {
    let controller;
    const ongoingStreamPromises = [];
    const stream = new ReadableStream({
        start(controllerArg) {
            controller = controllerArg;
        },
    });
    function safeEnqueue(data) {
        try {
            controller.enqueue(data);
        }
        catch (error) {
            // suppress errors when the stream has been closed
        }
    }
    try {
        const result = options.execute({
            write(part) {
                safeEnqueue(part);
            },
            merge(streamArg) {
                ongoingStreamPromises.push((async () => {
                    const reader = streamArg.getReader();
                    while (true) {
                        const { done, value } = await reader.read();
                        if (done)
                            break;
                        safeEnqueue(value);
                    }
                })().catch((error) => {
                    console.error(error);
                }));
            },
        });
        if (result) {
            ongoingStreamPromises.push(result.catch((error) => {
                console.error(error);
            }));
        }
    }
    catch (error) {
        console.error(error);
    }
    const waitForStreams = new Promise((resolve, reject) => {
        (async () => {
            while (ongoingStreamPromises.length > 0) {
                await ongoingStreamPromises.shift();
            }
            resolve();
        })().catch(reject);
    });
    waitForStreams.finally(() => {
        try {
            controller.close();
        }
        catch (error) {
            // suppress errors when the stream has been closed
        }
    });
    return pipeInternal(key, stream, options, "streams.writer()");
}
function define(opts) {
    return {
        id: opts.id,
        pipe(value, options) {
            return pipe(opts.id, value, options);
        },
        read(runId, options) {
            return read(runId, opts.id, options);
        },
        append(value, options) {
            return append(opts.id, value, options);
        },
        writer(options) {
            return writer(opts.id, options);
        },
    };
}
exports.streams = {
    pipe,
    read,
    append,
    writer,
    define,
};
function getRunIdForOptions(options) {
    if (options?.target) {
        if (options.target === "parent") {
            return v3_1.taskContext.ctx?.run?.parentTaskRunId;
        }
        if (options.target === "root") {
            return v3_1.taskContext.ctx?.run?.rootTaskRunId;
        }
        if (options.target === "self") {
            return v3_1.taskContext.ctx?.run?.id;
        }
        return options.target;
    }
    return v3_1.taskContext.ctx?.run?.id;
}
//# sourceMappingURL=streams.js.map